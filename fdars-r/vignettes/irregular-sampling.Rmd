---
title: "Working with Irregular Functional Data"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Working with Irregular Functional Data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 5,
  out.width = "100%"
)
```

```{r setup}
library(fdars)
library(ggplot2)
theme_set(theme_minimal())
```

## Introduction

Many real-world functional data are irregularly sampled, meaning:

- Different curves are observed at different time points
- Observations may be sparse (few points per curve)
- Sampling density may vary within or across curves

The `fdars` package provides the `irregFdata` class to handle such data naturally, avoiding the need for imputation or interpolation before analysis.

### Common Applications

- **Longitudinal studies**: Patients visited at different times
- **Sensor data**: Measurements with gaps or varying frequency
- **Environmental monitoring**: Non-uniform temporal sampling
- **Financial data**: Trades occurring at irregular intervals

## The irregFdata Class

### Creating irregFdata Objects

An `irregFdata` object stores observation times and values as lists:

```{r create-irreg}
# Three curves with different observation points
argvals <- list(
  c(0.0, 0.3, 0.7, 1.0),       # 4 points
  c(0.0, 0.2, 0.4, 0.6, 0.8, 1.0),  # 6 points
  c(0.1, 0.5, 0.9)              # 3 points
)

X <- list(
  c(0.1, 0.5, 0.3, 0.2),
  c(0.0, 0.4, 0.8, 0.6, 0.4, 0.1),
  c(0.3, 0.7, 0.2)
)

ifd <- irregFdata(argvals, X)
print(ifd)
```

### Structure

```{r structure}
# Number of observations
ifd$n

# Observation counts per curve
sapply(ifd$X, length)

# Domain range
ifd$rangeval
```

### Checking Data Type

```{r is-irregular}
# Regular fdata
fd_regular <- fdata(matrix(rnorm(100), 10, 10))
is.irregular(fd_regular)

# Irregular fdata
is.irregular(ifd)
```

## Sparsifying Regular Data

Use `sparsify()` to convert regular `fdata` to `irregFdata`:

```{r sparsify}
# Start with regular data
t <- seq(0, 1, length.out = 100)
fd <- simFunData(n = 10, argvals = t, M = 5, seed = 42)

# Create sparse version with 15-30 observations per curve
ifd <- sparsify(fd, minObs = 15, maxObs = 30, seed = 123)
print(ifd)
```

### Visualizing Sparse Data

```{r plot-sparse}
plot(ifd, main = "Sparsified Functional Data")
```

Using ggplot2:

```{r autoplot-sparse}
autoplot(ifd) +
  labs(title = "Irregular Functional Data (ggplot2)")
```

### Non-Uniform Sparsification

Control sampling density with a probability function:

```{r nonuniform-sparsify, fig.height = 6}
# More observations in the middle
prob_middle <- function(t) dnorm(t, mean = 0.5, sd = 0.2)

# More observations at the edges (U-shaped probability)
prob_edges <- function(t) 0.1 + 4 * (t - 0.5)^2

fd <- simFunData(n = 20, argvals = t, M = 5, seed = 42)

par(mfrow = c(3, 1))
ifd_uniform <- sparsify(fd, minObs = 15, maxObs = 25, seed = 123)
plot(ifd_uniform, main = "Uniform Sampling")

ifd_middle <- sparsify(fd, minObs = 15, maxObs = 25, prob = prob_middle, seed = 123)
plot(ifd_middle, main = "Dense in Middle")

ifd_edges <- sparsify(fd, minObs = 15, maxObs = 25, prob = prob_edges, seed = 123)
plot(ifd_edges, main = "Dense at Edges")
par(mfrow = c(1, 1))
```

## Converting to Regular Grid

Use `as.fdata()` to convert back to regular `fdata`:

### Method: NA Fill

Only exact matches are filled; other points get `NA`:

```{r as-fdata-na}
ifd <- sparsify(fd[1:3], minObs = 10, maxObs = 20, seed = 123)

fd_na <- as.fdata(ifd, method = "na")

# Show some data with NAs
fd_na$data[1, 1:20]
```

### Method: Linear Interpolation

Interpolate between observed points:

```{r as-fdata-linear}
# Specify target grid
target_grid <- seq(0, 1, length.out = 50)
fd_interp <- as.fdata(ifd, argvals = target_grid, method = "linear")

# No NAs within observed range
sum(is.na(fd_interp$data))
```

```{r compare-methods, fig.height = 5}
par(mfrow = c(2, 1))
plot(ifd[1], main = "Original Sparse Data (1 curve)", lwd = 2)
plot(fd_interp[1], main = "After Linear Interpolation")
par(mfrow = c(1, 1))
```

## Operations on Irregular Data

### Integration

Compute integrals using trapezoidal rule:

```{r integration}
# Create data with known integral
argvals <- list(
  seq(0, 1, length.out = 50),
  seq(0, 1, length.out = 30)
)
# Constant function = 1 should integrate to 1
X <- list(rep(1, 50), rep(2, 30))
ifd <- irregFdata(argvals, X)

integrals <- int.simpson.irregFdata(ifd)
print(integrals)  # Should be approximately 1 and 2
```

### Lp Norms

```{r norms}
# L2 norm of constant function c is c
norms <- norm.irregFdata(ifd, p = 2)
print(norms)
```

### Mean Function Estimation

Estimate the mean using kernel smoothing:

```{r mean-estimation}
# Simulate many curves
fd <- simFunData(n = 50, argvals = t, M = 5, seed = 42)
ifd <- sparsify(fd, minObs = 15, maxObs = 30, seed = 123)

# Estimate mean
mean_fd <- mean.irregFdata(ifd, bandwidth = 0.1)
plot(mean_fd, main = "Estimated Mean Function")
```

```{r compare-mean}
# Compare to true sample mean (from original data)
true_mean <- colMeans(fd$data)

plot(t, true_mean, type = "l", lwd = 2, col = "blue",
     main = "Mean Comparison", xlab = "t", ylab = "Mean")
lines(mean_fd$argvals, mean_fd$data[1,], col = "red", lwd = 2)
legend("topright", c("True Sample Mean", "Kernel Estimate"),
       col = c("blue", "red"), lwd = 2)
```

### Distance Matrix

Compute pairwise Lp distances:

```{r distances}
ifd <- sparsify(fd[1:5], minObs = 20, maxObs = 40, seed = 123)
D <- metric.lp.irregFdata(ifd, p = 2)
round(D, 2)
```

## Subsetting

Extract specific observations:

```{r subsetting}
ifd <- sparsify(fd[1:10], minObs = 10, maxObs = 20, seed = 123)

# Single observation
ifd_sub1 <- ifd[1]
print(ifd_sub1)

# Multiple observations
ifd_sub23 <- ifd[2:3]
print(ifd_sub23)

# Negative indexing
ifd_not1 <- ifd[-1]
ifd_not1$n
```

## Metadata Support

Store additional covariates with the data:

```{r metadata}
argvals <- list(c(0, 0.5, 1), c(0, 1), c(0, 0.3, 0.7, 1))
X <- list(c(1, 2, 1), c(0, 2), c(1, 1.5, 1.5, 1))
meta <- data.frame(
  group = c("treatment", "control", "treatment"),
  age = c(45, 52, 38)
)

ifd <- irregFdata(argvals, X,
                  id = c("patient_001", "patient_002", "patient_003"),
                  metadata = meta)

# Access metadata
ifd$id
ifd$metadata

# Subsetting preserves metadata
ifd[1]$metadata
```

## Real-World Use Cases

### Case 1: Sparse Longitudinal Data

```{r longitudinal, fig.height = 4}
set.seed(42)

# Simulate patient growth curves with irregular visits
n_patients <- 15

argvals_list <- lapply(1:n_patients, function(i) {
  # Random number of visits (5-12)
  n_visits <- sample(5:12, 1)
  # Random visit times in [0, 2] years
  sort(runif(n_visits, 0, 2))
})

# Growth model: baseline + linear growth + random effect
X_list <- lapply(1:n_patients, function(i) {
  baseline <- rnorm(1, 50, 5)
  growth_rate <- rnorm(1, 10, 2)
  noise <- rnorm(length(argvals_list[[i]]), 0, 1)
  baseline + growth_rate * argvals_list[[i]] + noise
})

ifd_growth <- irregFdata(argvals_list, X_list,
                          names = list(main = "Growth Curves",
                                       xlab = "Age (years)",
                                       ylab = "Height (cm)"))

plot(ifd_growth, alpha = 0.8)

# Estimate mean growth curve
mean_growth <- mean.irregFdata(ifd_growth,
                                argvals = seq(0, 2, length.out = 50),
                                bandwidth = 0.2)
lines(mean_growth$argvals, mean_growth$data[1,], col = "red", lwd = 3)
```

### Case 2: Sensor Data with Gaps

```{r sensor-gaps, fig.height = 4}
set.seed(123)

# Simulate sensor data with random gaps
t_full <- seq(0, 24, by = 0.1)  # 24 hours

simulate_sensor <- function() {
  # Random gaps (sensor offline)
  n_gaps <- sample(3:8, 1)
  gap_starts <- sort(runif(n_gaps, 0, 23))
  gap_lengths <- runif(n_gaps, 0.5, 2)

  keep <- rep(TRUE, length(t_full))
  for (i in 1:n_gaps) {
    keep[t_full >= gap_starts[i] & t_full < gap_starts[i] + gap_lengths[i]] <- FALSE
  }

  t_obs <- t_full[keep]
  # Temperature with daily cycle
  temp <- 20 + 5 * sin(2 * pi * t_obs / 24) + rnorm(length(t_obs), 0, 0.5)

  list(t = t_obs, x = temp)
}

sensors <- lapply(1:5, function(i) simulate_sensor())

ifd_sensor <- irregFdata(
  argvals = lapply(sensors, `[[`, "t"),
  X = lapply(sensors, `[[`, "x"),
  names = list(main = "Temperature Sensors",
               xlab = "Hour of Day",
               ylab = "Temperature (C)")
)

plot(ifd_sensor, alpha = 0.8)
```

## Best Practices

### When to Use Irregular Representation

| Scenario | Recommendation |
|----------|----------------|
| Few missing points | Use regular `fdata` with NA |
| Systematic sparsity | Use `irregFdata` |
| Very dense data | Use regular `fdata` |
| Mixed observation times | Use `irregFdata` |

### Memory Considerations

`irregFdata` is more memory-efficient when data is sparse:

```{r memory}
# Regular: always stores n x m values
n <- 100
m <- 1000
regular_size <- n * m * 8  # bytes (double)

# Irregular: stores only observed values
avg_obs <- 50  # average observations per curve
irreg_size <- n * avg_obs * 8 * 2  # values + argvals

cat("Regular (n=100, m=1000):", regular_size / 1024, "KB\n")
cat("Irregular (n=100, ~50 obs each):", irreg_size / 1024, "KB\n")
```

### Preprocessing Recommendations

1. **Quality control**: Remove curves with too few observations
2. **Domain alignment**: Ensure all curves span similar ranges
3. **Outlier removal**: Check for obviously erroneous values
4. **Bandwidth selection**: Use cross-validation for kernel smoothing

```{r quality-control}
# Remove curves with fewer than 5 observations
min_obs <- 5
keep <- sapply(ifd$X, length) >= min_obs

if (any(!keep)) {
  ifd_clean <- ifd[keep]
  cat("Removed", sum(!keep), "curves with <", min_obs, "observations\n")
}
```

## Summary

| Function | Purpose |
|----------|---------|
| `irregFdata()` | Create irregular functional data objects |
| `is.irregular()` | Check if object is irregFdata |
| `sparsify()` | Convert regular to irregular data |
| `as.fdata()` | Convert irregular to regular (with interpolation) |
| `int.simpson.irregFdata()` | Compute integrals |
| `norm.irregFdata()` | Compute Lp norms |
| `mean.irregFdata()` | Estimate mean via kernel smoothing |
| `metric.lp.irregFdata()` | Compute pairwise distances |
