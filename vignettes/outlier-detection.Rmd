---
title: "Outlier Detection"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Outlier Detection}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 5
)
```

## Introduction

Outlier detection in functional data identifies curves that are atypical
or anomalous compared to the rest of the sample. **fdars** provides several
methods based on functional depth and likelihood ratio tests.

```{r setup}
library(fdars)

# Generate normal data
set.seed(42)
n <- 30
m <- 100
t_grid <- seq(0, 1, length.out = m)

X <- matrix(0, n, m)
for (i in 1:n) {
  X[i, ] <- sin(2 * pi * t_grid) + rnorm(m, sd = 0.15)
}

# Add different types of outliers
X[1, ] <- sin(2 * pi * t_grid) + 2           # Magnitude outlier (shift up)
X[2, ] <- -sin(2 * pi * t_grid)              # Shape outlier (inverted)
X[3, ] <- sin(4 * pi * t_grid)               # Frequency outlier

fd <- fdata(X, argvals = t_grid)
plot(fd)
```

## Depth-Based Methods

Depth-based outlier detection identifies curves with unusually low depth
(far from the center of the data).

### Weighted Depth Method (outliers.depth.pond)

Uses bootstrap resampling to estimate the distribution of depths and
identifies curves with depth below a data-driven cutoff.

```{r depth-pond}
out_pond <- outliers.depth.pond(fd, nb = 100, seed = 123)
print(out_pond)
```

### Visualizing Outliers

```{r plot-outliers}
plot(out_pond)
```

### Examining Results

```{r examine-pond}
# Which curves are outliers?
out_pond$outliers

# Depth values for all curves
head(out_pond$depths)

# Cutoff used
out_pond$cutoff
```

### Trimming-Based Method (outliers.depth.trim)

Iteratively removes curves with lowest depth:

```{r depth-trim}
out_trim <- outliers.depth.trim(fd, trim = 0.1, seed = 123)
print(out_trim)
plot(out_trim)
```

### Using Different Depth Functions

Both methods accept a `depth` parameter to specify the depth function:

```{r different-depths}
# Using Random Projection depth
out_rp <- outliers.depth.pond(fd, nb = 100, seed = 123)

# Using modal depth (default is FM)
out_mode <- outliers.depth.trim(fd, trim = 0.1, seed = 123)
```

## Likelihood Ratio Test (LRT) Method

The LRT method uses a likelihood ratio test to sequentially identify outliers.
It's particularly effective for detecting magnitude outliers.

### Computing the Threshold

First, compute a bootstrap threshold:

```{r lrt-threshold}
threshold <- outliers.thres.lrt(fd, nb = 100, seed = 123)
cat("LRT threshold:", threshold, "\n")
```

### Detecting Outliers

```{r lrt-detect}
out_lrt <- outliers.lrt(fd, nb = 100, seed = 123)
print(out_lrt)
plot(out_lrt)
```

### LRT Results

```{r lrt-results}
# Outlier indices
out_lrt$outliers

# Distance from center for each curve
head(out_lrt$distances)

# Threshold used
out_lrt$threshold
```

## Comparing Methods

Different methods may detect different types of outliers:

```{r compare-methods}
# Run all methods
out1 <- outliers.depth.pond(fd, nb = 100, seed = 123)
out2 <- outliers.depth.trim(fd, trim = 0.1, seed = 123)
out3 <- outliers.lrt(fd, nb = 100, seed = 123)

# Compare detected outliers
cat("Depth-pond outliers:", out1$outliers, "\n")
cat("Depth-trim outliers:", out2$outliers, "\n")
cat("LRT outliers:", out3$outliers, "\n")

# True outliers are curves 1, 2, 3
cat("True outliers: 1, 2, 3\n")
```

## Types of Outliers

### Magnitude Outliers

Curves shifted up or down from the main group:

```{r magnitude-outlier}
# Create data with magnitude outlier
X_mag <- X
X_mag[1, ] <- sin(2 * pi * t_grid) + 3  # Large shift

fd_mag <- fdata(X_mag, argvals = t_grid)
out_mag <- outliers.depth.pond(fd_mag, nb = 100, seed = 123)

cat("Detected magnitude outlier:", out_mag$outliers, "\n")
plot(out_mag)
```

### Shape Outliers

Curves with different patterns:

```{r shape-outlier}
# Create data with shape outlier
X_shape <- X
X_shape[1, ] <- cos(2 * pi * t_grid)  # Different shape

fd_shape <- fdata(X_shape, argvals = t_grid)
out_shape <- outliers.depth.pond(fd_shape, nb = 100, seed = 123)

cat("Detected shape outlier:", out_shape$outliers, "\n")
```

### Amplitude Outliers

Curves with unusual amplitude (scale):

```{r amplitude-outlier}
# Create data with amplitude outlier
X_amp <- X
X_amp[1, ] <- 3 * sin(2 * pi * t_grid)  # Larger amplitude

fd_amp <- fdata(X_amp, argvals = t_grid)
out_amp <- outliers.depth.pond(fd_amp, nb = 100, seed = 123)

cat("Detected amplitude outlier:", out_amp$outliers, "\n")
```

## Tuning Parameters

### Number of Bootstrap Samples

More bootstrap samples give more stable results but take longer:

```{r tuning-nb}
# Compare with different nb values
out_nb50 <- outliers.depth.pond(fd, nb = 50, seed = 123)
out_nb200 <- outliers.depth.pond(fd, nb = 200, seed = 123)

cat("nb=50 outliers:", out_nb50$outliers, "\n")
cat("nb=200 outliers:", out_nb200$outliers, "\n")
```

### Trim Proportion

For `outliers.depth.trim`, the trim proportion controls sensitivity:

```{r tuning-trim}
# More aggressive trimming
out_trim05 <- outliers.depth.trim(fd, trim = 0.05, seed = 123)
out_trim20 <- outliers.depth.trim(fd, trim = 0.2, seed = 123)

cat("trim=0.05 outliers:", out_trim05$outliers, "\n")
cat("trim=0.20 outliers:", out_trim20$outliers, "\n")
```

## Handling High Contamination

When outlier contamination is high, use robust methods:

```{r high-contamination}
# Create data with 20% outliers
X_contam <- X
n_outliers <- 6
for (i in 1:n_outliers) {
  X_contam[i, ] <- sin(2 * pi * t_grid) + rnorm(1, 0, 2)
}

fd_contam <- fdata(X_contam, argvals = t_grid)

# Depth-trim with higher trim proportion
out_contam <- outliers.depth.trim(fd_contam, trim = 0.2, seed = 123)
cat("Detected outliers:", out_contam$outliers, "\n")
cat("True outliers: 1-6\n")
```

## Visualizing Depth Distribution

```{r depth-distribution}
# Compute depths
depths <- depth.FM(fd)

# Create histogram
library(ggplot2)
df_depths <- data.frame(
  curve = 1:n,
  depth = depths,
  type = ifelse(1:n %in% c(1, 2, 3), "Outlier", "Normal")
)

ggplot(df_depths, aes(x = depth, fill = type)) +
  geom_histogram(bins = 10, alpha = 0.7, position = "identity") +
  labs(title = "Distribution of Functional Depths",
       x = "Depth", y = "Count", fill = "") +
  theme_minimal()
```

## Performance

The LRT method uses a parallel Rust backend for speed:

```{r performance, eval=FALSE}
# Benchmark with larger dataset
X_large <- matrix(rnorm(200 * 100), 200, 100)
fd_large <- fdata(X_large)

system.time(outliers.lrt(fd_large, nb = 200, seed = 123))
#>    user  system elapsed
#>   0.456   0.000   0.123
```

## Outliergram and MS-Plot

For visual outlier detection, use the outliergram (MEI vs MBD) or MS-plot
(Magnitude vs Shape outlyingness):

```{r outliergram}
# Outliergram
og <- outliergram(fd)
plot(og)
```

```{r msplot}
# Magnitude-Shape plot
ms <- MS.plot(fd)
```

### Labeling Outliers by ID or Metadata

When fdata has IDs or metadata, you can label outliers in plots:
```{r outlier-labeling}
# Create fdata with IDs and metadata
meta <- data.frame(
  subject = paste0("S", sprintf("%02d", 1:n)),
  group = rep(c("A", "B"), length.out = n)
)
fd_labeled <- fdata(X, argvals = t_grid,
                    id = paste0("patient_", 1:n),
                    metadata = meta)

# Outliergram with patient IDs
og_labeled <- outliergram(fd_labeled)
plot(og_labeled, label = "id")

# Or with metadata column
plot(og_labeled, label = "subject")

# Label ALL points, not just outliers
plot(og_labeled, label = "id", label_all = TRUE)
```

```{r ms-labeling}
# MS-plot with custom labels
MS.plot(fd_labeled, label = "subject")
```

## Method Selection Guide

| Method | Best For | Sensitivity |
|--------|----------|-------------|
| depth.pond | General purpose | Moderate |
| depth.trim | Known contamination rate | Controllable |
| LRT | Magnitude outliers | High |
| outliergram | Shape outliers | Visual |
| MS.plot | Both magnitude & shape | Visual |

## Best Practices

1. **Start with visualization**: Plot the data to understand outlier types
2. **Try multiple methods**: Different methods catch different outliers
3. **Use sufficient bootstrap samples**: At least 100 for stable results
4. **Consider domain knowledge**: Some "outliers" may be valid observations
5. **Validate findings**: Check detected outliers make sense contextually

## References

- Febrero, M., Galeano, P., and GonzÃ¡lez-Manteiga, W. (2008). Outlier
  detection in functional data by depth measures, with application to
  identify abnormal NOx levels. *Environmetrics*, 19(4), 331-345.
- Hyndman, R.J. and Shang, H.L. (2010). Rainbow plots, bagplots, and
  boxplots for functional data. *Journal of Computational and Graphical
  Statistics*, 19(1), 29-45.
