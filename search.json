[{"path":"https://sipemu.github.io/fdars/CHANGELOG.html","id":null,"dir":"","previous_headings":"","what":"Changelog","title":"Changelog","text":"notable changes fdars documented file.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/CHANGELOG.html","id":"added","dir":"","previous_headings":"[0.5.1] - 2024-12-16","what":"Added","title":"Changelog","text":"normalize() function scale curves unit Lp norm Vignette basis representation optimal basis selection","code":""},{"path":"https://sipemu.github.io/fdars/CHANGELOG.html","id":"changed","dir":"","previous_headings":"[0.5.1] - 2024-12-16","what":"Changed","title":"Changelog","text":"Renamed norm.fdata() norm() cleaner API Renamed covariance kernel functions cov.* kernel_* avoid S3 dispatch conflicts","code":""},{"path":"https://sipemu.github.io/fdars/CHANGELOG.html","id":"fixed","dir":"","previous_headings":"[0.5.1] - 2024-12-16","what":"Fixed","title":"Changelog","text":"Plot functions now display called directly (plot(fd) shows plot, p <- plot(fd) ) S3 method dispatch conflict cov() generic function","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/CHANGELOG.html","id":"added-1","dir":"","previous_headings":"[0.5.0] - 2024-12-14","what":"Added","title":"Changelog","text":"basis2fdata() - reconstruct functional data basis coefficients basis.gcv(), basis.aic(), basis.bic() - goodness--fit metrics fdata2basis.cv() - cross-validation optimal nbasis selection pspline() - P-spline smoothing automatic lambda selection fdata2basis.2d(), basis2fdata.2d() - 2D tensor product basis support pspline.2d() - 2D P-spline anisotropic penalties","code":""},{"path":"https://sipemu.github.io/fdars/CHANGELOG.html","id":"changed-1","dir":"","previous_headings":"[0.5.0] - 2024-12-14","what":"Changed","title":"Changelog","text":"Plot functions now return ggplot objects without auto-printing (use print(p) display) Removed hardcoded theme_minimal() plots - respects ggplot2::theme_set() Fixed white lines 2D surface plots using facets","code":""},{"path":"https://sipemu.github.io/fdars/CHANGELOG.html","id":"fixed-1","dir":"","previous_headings":"[0.5.0] - 2024-12-14","what":"Fixed","title":"Changelog","text":"Windows binary now built R 4.2.2 compatibility older R versions","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/CHANGELOG.html","id":"added-2","dir":"","previous_headings":"[0.4.0] - 2024-12-13","what":"Added","title":"Changelog","text":"id metadata slots fdata objects storing curve identifiers associated data Outlier plot labeling: plot(outliergram, label = \"id\") label = \"column_name\" magnitudeshape() labeling support (renamed MS.plot)","code":""},{"path":"https://sipemu.github.io/fdars/CHANGELOG.html","id":"changed-2","dir":"","previous_headings":"[0.4.0] - 2024-12-13","what":"Changed","title":"Changelog","text":"Auto-reduce alpha show.mean = TRUE plot.fdata()","code":""},{"path":"https://sipemu.github.io/fdars/CHANGELOG.html","id":"fixed-2","dir":"","previous_headings":"[0.4.0] - 2024-12-13","what":"Fixed","title":"Changelog","text":"Vignette error: extract data mean fdata object correctly","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/CHANGELOG.html","id":"added-3","dir":"","previous_headings":"[0.3.4] - 2024-12-13","what":"Added","title":"Changelog","text":"fregre.np.multi() regression multiple functional predictors","code":""},{"path":"https://sipemu.github.io/fdars/CHANGELOG.html","id":"fixed-3","dir":"","previous_headings":"[0.3.4] - 2024-12-13","what":"Fixed","title":"Changelog","text":"plot.group.distance() error handling Missing depth wrapper functions","code":""},{"path":"https://sipemu.github.io/fdars/CHANGELOG.html","id":"changed-3","dir":"","previous_headings":"[0.3.4] - 2024-12-13","what":"Changed","title":"Changelog","text":"Documented null hypothesis group.test()","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/CHANGELOG.html","id":"added-4","dir":"","previous_headings":"[0.3.3] - 2024-12-12","what":"Added","title":"Changelog","text":"Enhanced plot.fdata() group coloring, mean curves, confidence intervals group.distance() measuring distances groups curves group.test() permutation test group differences","code":""},{"path":"https://sipemu.github.io/fdars/CHANGELOG.html","id":"fixed-4","dir":"","previous_headings":"[0.3.3] - 2024-12-12","what":"Fixed","title":"Changelog","text":"Release workflow now generates documentation building","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/CHANGELOG.html","id":"fixed-5","dir":"","previous_headings":"[0.3.2] - 2024-12-12","what":"Fixed","title":"Changelog","text":"mean(fd) now returns fdata object (returning matrix) Missing %||% operator definition","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/CHANGELOG.html","id":"added-5","dir":"","previous_headings":"[0.3.1] - 2024-12-12","what":"Added","title":"Changelog","text":"outliergram() visualization (MEI vs MBD plot) plot.fdata2pc() FPCA visualization (components, variance, scores)","code":""},{"path":"https://sipemu.github.io/fdars/CHANGELOG.html","id":"changed-4","dir":"","previous_headings":"[0.3.1] - 2024-12-12","what":"Changed","title":"Changelog","text":"Renamed fdata.deriv() deriv() consistency","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/CHANGELOG.html","id":"added-6","dir":"","previous_headings":"[0.3.0] - 2024-12-11","what":"Added","title":"Changelog","text":"Covariance kernel functions: cov.Exponential(), cov.Matern(), cov.Gaussian(), etc. make_gaussian_process() simulating Gaussian process realizations 2D functional data support functions Unified API: depth(), median(), trimmed(), trimvar() method parameter","code":""},{"path":"https://sipemu.github.io/fdars/CHANGELOG.html","id":"changed-5","dir":"","previous_headings":"[0.3.0] - 2024-12-11","what":"Changed","title":"Changelog","text":"Cleaned API: removed backward compatibility shims Renamed functions consistency (e.g., fdata.mean -> mean.fdata) plots now use ggplot2 instead base R graphics","code":""},{"path":"https://sipemu.github.io/fdars/CHANGELOG.html","id":"added-from-02x-development","dir":"","previous_headings":"[0.3.0] - 2024-12-11","what":"Added (from 0.2.x development)","title":"Changelog","text":"Band depth (depth.BD, depth.MBD, depth.MEI) Functional boxplot (boxplot.fdata) MS-plot outlier detection Fuzzy c-means clustering (cluster.fcm) Geometric median (gmed) Curve registration (register.fd) Local averages feature extraction (localavg.fdata) Optimal k selection k-means (cluster.optim) k-NN bandwidth selection nonparametric regression","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/CHANGELOG.html","id":"initial-release","dir":"","previous_headings":"[0.1.0] - 2024-12-10","what":"Initial Release","title":"Changelog","text":"Core functional data structure: fdata() 1D 2D functional data Depth functions: FM, mode, RP, RT, FSD, KFSD, RPD (Rust backend) Statistics: mean, variance, standard deviation, covariance Distance metrics: Lp, Hausdorff, DTW, KL divergence Semimetrics: basis projection, Fourier, horizontal shift, PCA, derivative Regression: fregre.pc(), fregre.basis(), fregre.np() CV variants Outlier detection: outliers.depth.pond(), outliers.depth.trim(), outliers.lrt() Smoothing: Nadaraya-Watson, local linear, local polynomial, k-NN Clustering: functional k-means Hypothesis testing: flm.test(), fmean.test.fdata() Utilities: Simpson integration, inner product, derivatives","code":""},{"path":"https://sipemu.github.io/fdars/articles/basis-representation.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Finding the Best Basis Representation","text":"Basis representation fundamental functional data analysis. Instead working raw observations discrete points, represent curves linear combinations basis functions: X(t)=‚àëk=1KckBk(t)X(t) = \\sum_{k=1}^{K} c_k B_k(t) Bk(t)B_k(t) basis functions ckc_k coefficients. approach provides: Smoothing: Reduces noise projecting onto lower-dimensional space Dimensionality reduction: Represents infinite-dimensional functions finite coefficients Regularization: Controls curve smoothness basis choice penalties fdars provides tools find optimal basis representation data.","code":"library(fdars) #>  #> Attaching package: 'fdars' #> The following objects are masked from 'package:stats': #>  #>     cov, deriv, median, sd, var #> The following object is masked from 'package:base': #>  #>     norm library(ggplot2) theme_set(theme_minimal()) set.seed(42)"},{"path":"https://sipemu.github.io/fdars/articles/basis-representation.html","id":"creating-example-data","dir":"Articles","previous_headings":"","what":"Creating Example Data","title":"Finding the Best Basis Representation","text":"Let‚Äôs create functional data known signal plus noise:","code":"# Generate noisy functional data t <- seq(0, 1, length.out = 100) n <- 30  # number of curves  # True underlying signal: mixture of sin waves true_signal <- function(t) sin(2 * pi * t) + 0.5 * sin(4 * pi * t)  # Generate noisy observations X <- matrix(0, n, length(t)) for (i in 1:n) {   X[i, ] <- true_signal(t) + rnorm(length(t), sd = 0.3) } fd <- fdata(X, argvals = t)  # Plot the data plot(fd, alpha = 0.3)"},{"path":"https://sipemu.github.io/fdars/articles/basis-representation.html","id":"choosing-a-basis-type","dir":"Articles","previous_headings":"","what":"Choosing a Basis Type","title":"Finding the Best Basis Representation","text":"fdars supports two main basis types:","code":""},{"path":"https://sipemu.github.io/fdars/articles/basis-representation.html","id":"b-splines-default","dir":"Articles","previous_headings":"Choosing a Basis Type","what":"B-splines (default)","title":"Finding the Best Basis Representation","text":"Best non-periodic data Local support: basis function non-zero limited region Good capturing local features Computationally efficient","code":""},{"path":"https://sipemu.github.io/fdars/articles/basis-representation.html","id":"fourier-basis","dir":"Articles","previous_headings":"Choosing a Basis Type","what":"Fourier Basis","title":"Finding the Best Basis Representation","text":"Best periodic data (cycles, seasonal patterns) Global support: basis function spans entire domain Natural data harmonic structure  sinusoidal data, Fourier basis natural since true signal composed sine waves.","code":"# Compare B-spline and Fourier representations coefs_bspline <- fdata2basis(fd, nbasis = 15, type = \"bspline\") coefs_fourier <- fdata2basis(fd, nbasis = 15, type = \"fourier\")  # Reconstruct fd_bspline <- basis2fdata(coefs_bspline, argvals = t, type = \"bspline\") fd_fourier <- basis2fdata(coefs_fourier, argvals = t, type = \"fourier\")  # Plot comparison for first curve df_compare <- data.frame(   t = rep(t, 3),   value = c(fd$data[1, ], fd_bspline$data[1, ], fd_fourier$data[1, ]),   type = factor(rep(c(\"Original\", \"B-spline (K=15)\", \"Fourier (K=15)\"), each = length(t)),                 levels = c(\"Original\", \"B-spline (K=15)\", \"Fourier (K=15)\")) )  ggplot(df_compare, aes(x = t, y = value, color = type, linewidth = type)) +   geom_line() +   scale_color_manual(values = c(\"Original\" = \"gray50\", \"B-spline (K=15)\" = \"blue\",                                  \"Fourier (K=15)\" = \"red\")) +   scale_linewidth_manual(values = c(\"Original\" = 0.5, \"B-spline (K=15)\" = 1,                                      \"Fourier (K=15)\" = 1)) +   labs(x = \"t\", y = \"X(t)\", title = \"Basis Representation Comparison\") +   theme(legend.position = \"bottom\", legend.title = element_blank()) +   guides(linewidth = \"none\")"},{"path":"https://sipemu.github.io/fdars/articles/basis-representation.html","id":"selecting-the-number-of-basis-functions","dir":"Articles","previous_headings":"","what":"Selecting the Number of Basis Functions","title":"Finding the Best Basis Representation","text":"key question: many basis functions use? : Underfitting (misses important features) many: Overfitting (fits noise)","code":""},{"path":"https://sipemu.github.io/fdars/articles/basis-representation.html","id":"information-criteria","dir":"Articles","previous_headings":"Selecting the Number of Basis Functions","what":"Information Criteria","title":"Finding the Best Basis Representation","text":"fdars provides three criteria evaluate basis representations:  Interpretation: GCV (Generalized Cross-Validation): Often good default, balances fit complexity AIC: Tends select slightly complex models BIC: conservative, penalizes complexity strongly larger samples","code":"# Compute criteria for different nbasis values nbasis_range <- 5:25  gcv_scores <- sapply(nbasis_range, function(k) basis.gcv(fd, nbasis = k, type = \"fourier\")) aic_scores <- sapply(nbasis_range, function(k) basis.aic(fd, nbasis = k, type = \"fourier\")) bic_scores <- sapply(nbasis_range, function(k) basis.bic(fd, nbasis = k, type = \"fourier\"))  # Find optimal values opt_gcv <- nbasis_range[which.min(gcv_scores)] opt_aic <- nbasis_range[which.min(aic_scores)] opt_bic <- nbasis_range[which.min(bic_scores)]  # Create data frame for plotting df_criteria <- data.frame(   nbasis = rep(nbasis_range, 3),   score = c(gcv_scores, aic_scores, bic_scores),   criterion = rep(c(\"GCV\", \"AIC\", \"BIC\"), each = length(nbasis_range)),   optimal = c(nbasis_range == opt_gcv, nbasis_range == opt_aic, nbasis_range == opt_bic) )  df_optimal <- data.frame(   criterion = c(\"GCV\", \"AIC\", \"BIC\"),   nbasis = c(opt_gcv, opt_aic, opt_bic) )  ggplot(df_criteria, aes(x = nbasis, y = score)) +   geom_line(color = \"steelblue\") +   geom_point(color = \"steelblue\") +   geom_vline(data = df_optimal, aes(xintercept = nbasis),              linetype = \"dashed\", color = \"red\") +   facet_wrap(~ criterion, scales = \"free_y\") +   labs(x = \"Number of basis functions\", y = \"Score\",        title = \"Information Criteria for Basis Selection\") +   theme_minimal() cat(\"Optimal nbasis - GCV:\", opt_gcv, \"\\n\") #> Optimal nbasis - GCV: 5 cat(\"Optimal nbasis - AIC:\", opt_aic, \"\\n\") #> Optimal nbasis - AIC: 5 cat(\"Optimal nbasis - BIC:\", opt_bic, \"\\n\") #> Optimal nbasis - BIC: 5"},{"path":"https://sipemu.github.io/fdars/articles/basis-representation.html","id":"complex-signal-example-b-spline-vs-fourier","dir":"Articles","previous_headings":"Selecting the Number of Basis Functions","what":"Complex Signal Example: B-spline vs Fourier","title":"Finding the Best Basis Representation","text":"previous example used sinusoidal signal ideally suited Fourier basis. Let‚Äôs now consider complex non-periodic signal ‚Äôs better suited B-splines:  Key observations: B-splines better localized features (like Gaussian bump) Fourier basis needs functions approximate non-periodic signals Information criteria help select basis type number functions","code":"# Generate data with non-periodic features set.seed(123) t2 <- seq(0, 1, length.out = 100) n2 <- 30  # Complex signal: polynomial trend + localized bump complex_signal <- function(t) {   trend <- 2 * t^2 - t   bump <- 0.8 * exp(-((t - 0.3)^2) / (2 * 0.05^2))   sharp <- 0.5 * sqrt(pmax(0, t - 0.7))   trend + bump + sharp }  X2 <- matrix(0, n2, length(t2)) for (i in 1:n2) {   X2[i, ] <- complex_signal(t2) + rnorm(length(t2), sd = 0.15) } fd2 <- fdata(X2, argvals = t2)  # Compare B-spline vs Fourier for this data nbasis_range <- 5:25  # B-spline criteria gcv_bspline <- sapply(nbasis_range, function(k) basis.gcv(fd2, nbasis = k, type = \"bspline\")) aic_bspline <- sapply(nbasis_range, function(k) basis.aic(fd2, nbasis = k, type = \"bspline\"))  # Fourier criteria gcv_fourier <- sapply(nbasis_range, function(k) basis.gcv(fd2, nbasis = k, type = \"fourier\")) aic_fourier <- sapply(nbasis_range, function(k) basis.aic(fd2, nbasis = k, type = \"fourier\"))  # Create comparison plot df_complex <- data.frame(   nbasis = rep(nbasis_range, 4),   score = c(gcv_bspline, gcv_fourier, aic_bspline, aic_fourier),   criterion = rep(rep(c(\"GCV\", \"AIC\"), each = length(nbasis_range)), 2),   basis = rep(c(\"B-spline\", \"Fourier\"), each = 2 * length(nbasis_range)) )  ggplot(df_complex, aes(x = nbasis, y = score, color = basis)) +   geom_line() +   geom_point() +   facet_wrap(~ criterion, scales = \"free_y\") +   labs(x = \"Number of basis functions\", y = \"Score\",        title = \"Basis Selection for Complex Non-Periodic Signal\") +   scale_color_manual(values = c(\"B-spline\" = \"steelblue\", \"Fourier\" = \"coral\"))"},{"path":"https://sipemu.github.io/fdars/articles/basis-representation.html","id":"automatic-selection-with-fdata2basis-cv","dir":"Articles","previous_headings":"Selecting the Number of Basis Functions","what":"Automatic Selection with fdata2basis.cv()","title":"Finding the Best Basis Representation","text":"convenience, use fdata2basis.cv() automatically find optimal number basis functions:  function returns optimal number basis functions fitted curves:","code":"# Automatic selection using GCV cv_result <- fdata2basis.cv(fd, nbasis.range = 5:25, type = \"fourier\", criterion = \"GCV\") print(cv_result) #> Basis Cross-Validation Results #> ============================== #> Criterion: GCV  #> Optimal nbasis: 5  #> Score at optimal: 0.09559293  #> Range tested: 5 - 25  # Visualize the selection plot(cv_result) # Plot the smoothed data plot(cv_result$fitted, alpha = 0.5, main = paste(\"Smoothed with\", cv_result$optimal.nbasis, \"Fourier basis\"))"},{"path":"https://sipemu.github.io/fdars/articles/basis-representation.html","id":"k-fold-cross-validation","dir":"Articles","previous_headings":"Selecting the Number of Basis Functions","what":"K-fold Cross-Validation","title":"Finding the Best Basis Representation","text":"robust estimate, use k-fold cross-validation:","code":"# K-fold cross-validation (slower but more robust) cv_kfold <- fdata2basis.cv(fd, nbasis.range = 5:25, type = \"fourier\",                             criterion = \"CV\", kfold = 10) print(cv_kfold$optimal.nbasis)"},{"path":"https://sipemu.github.io/fdars/articles/basis-representation.html","id":"p-spline-smoothing","dir":"Articles","previous_headings":"","what":"P-spline Smoothing","title":"Finding the Best Basis Representation","text":"P-splines (Penalized B-splines) offer alternative approach: instead selecting number basis functions, use many basis functions add roughness penalty: minimize||y‚àíBc||2+Œªc‚Ä≤D‚Ä≤Dc\\text{minimize} \\quad ||y - Bc||^2 + \\lambda c' D' D c : - BB B-spline basis matrix - cc coefficients - DD difference matrix (controls smoothness) - Œª\\lambda penalty parameter","code":"# Fit P-spline with fixed lambda result_fixed <- pspline(fd[1], nbasis = 25, lambda = 10) print(result_fixed) #> P-spline Smoothing Results #> ========================== #> Number of curves: 1  #> Number of basis functions: 25  #> Penalty order: 2  #> Lambda: 1e+01  #> Effective df: 6.68  #> GCV: 1.151e-01  # Compare different lambda values lambdas <- c(0.01, 1, 100, 10000) df_lambda <- do.call(rbind, lapply(lambdas, function(lam) {   result <- pspline(fd[1], nbasis = 25, lambda = lam)   data.frame(     t = rep(t, 2),     value = c(fd$data[1, ], result$fdata$data[1, ]),     type = rep(c(\"Original\", \"Smoothed\"), each = length(t)),     lambda = paste(\"lambda =\", lam)   ) })) df_lambda$lambda <- factor(df_lambda$lambda, levels = paste(\"lambda =\", lambdas))  ggplot(df_lambda, aes(x = t, y = value, color = type, linewidth = type)) +   geom_line() +   scale_color_manual(values = c(\"Original\" = \"gray50\", \"Smoothed\" = \"blue\")) +   scale_linewidth_manual(values = c(\"Original\" = 0.5, \"Smoothed\" = 1)) +   facet_wrap(~ lambda, ncol = 2) +   labs(x = \"t\", y = \"X(t)\", title = \"P-spline Smoothing with Different Lambda\") +   theme_minimal() +   theme(legend.position = \"bottom\", legend.title = element_blank())"},{"path":"https://sipemu.github.io/fdars/articles/basis-representation.html","id":"automatic-lambda-selection","dir":"Articles","previous_headings":"P-spline Smoothing","what":"Automatic Lambda Selection","title":"Finding the Best Basis Representation","text":"P-splines can automatically select optimal smoothing parameter:","code":"# Automatic lambda selection using GCV result_auto <- pspline(fd[1], nbasis = 25, lambda.select = TRUE, criterion = \"GCV\") cat(\"Selected lambda:\", result_auto$lambda, \"\\n\") #> Selected lambda: 1.206793 cat(\"Effective df:\", round(result_auto$edf, 2), \"\\n\") #> Effective df: 9.99  # Plot result df_auto <- data.frame(   t = rep(t, 3),   value = c(fd$data[1, ], result_auto$fdata$data[1, ], true_signal(t)),   type = factor(c(rep(\"Observed\", length(t)),                   rep(\"P-spline\", length(t)),                   rep(\"True signal\", length(t))),                 levels = c(\"Observed\", \"P-spline\", \"True signal\")) )  ggplot(df_auto, aes(x = t, y = value, color = type, linetype = type, linewidth = type)) +   geom_line() +   scale_color_manual(values = c(\"Observed\" = \"gray50\", \"P-spline\" = \"blue\",                                  \"True signal\" = \"red\")) +   scale_linetype_manual(values = c(\"Observed\" = \"solid\", \"P-spline\" = \"solid\",                                     \"True signal\" = \"dashed\")) +   scale_linewidth_manual(values = c(\"Observed\" = 0.5, \"P-spline\" = 1, \"True signal\" = 1)) +   labs(x = \"t\", y = \"X(t)\", title = \"P-spline with Auto-selected Lambda\") +   theme_minimal() +   theme(legend.position = \"bottom\", legend.title = element_blank())"},{"path":"https://sipemu.github.io/fdars/articles/basis-representation.html","id":"smoothing-multiple-curves","dir":"Articles","previous_headings":"P-spline Smoothing","what":"Smoothing Multiple Curves","title":"Finding the Best Basis Representation","text":"P-splines work curve--curve, can smooth entire datasets:","code":"# Smooth all curves with automatic lambda selection result_all <- pspline(fd, nbasis = 25, lambda.select = TRUE)  # Plot smoothed data plot(result_all$fdata, alpha = 0.5, main = \"All curves smoothed with P-splines\")"},{"path":"https://sipemu.github.io/fdars/articles/basis-representation.html","id":"comparing-approaches","dir":"Articles","previous_headings":"","what":"Comparing Approaches","title":"Finding the Best Basis Representation","text":"Let‚Äôs compare different smoothing approaches:","code":"# Original noisy data fd_single <- fd[1]  # 1. Simple basis projection (Fourier) coefs <- fdata2basis(fd_single, nbasis = 9, type = \"fourier\") fd_fourier <- basis2fdata(coefs, argvals = t, type = \"fourier\")  # 2. Optimal basis via CV cv_opt <- fdata2basis.cv(fd_single, nbasis.range = 5:20, type = \"fourier\") fd_cv <- cv_opt$fitted  # 3. P-spline with automatic lambda ps_result <- pspline(fd_single, nbasis = 25, lambda.select = TRUE) fd_pspline <- ps_result$fdata  # Plot comparison df_comp <- data.frame(   t = rep(t, 5),   value = c(fd_single$data[1, ], fd_fourier$data[1, ], fd_cv$data[1, ],             fd_pspline$data[1, ], true_signal(t)),   method = factor(c(rep(\"Observed\", length(t)),                     rep(\"Fourier (K=9)\", length(t)),                     rep(paste0(\"CV-optimal (K=\", cv_opt$optimal.nbasis, \")\"), length(t)),                     rep(\"P-spline\", length(t)),                     rep(\"True signal\", length(t))),                   levels = c(\"Observed\", \"Fourier (K=9)\",                              paste0(\"CV-optimal (K=\", cv_opt$optimal.nbasis, \")\"),                              \"P-spline\", \"True signal\")) )  ggplot(df_comp, aes(x = t, y = value, color = method, linetype = method, linewidth = method)) +   geom_line() +   scale_color_manual(values = c(\"Observed\" = \"gray50\", \"Fourier (K=9)\" = \"blue\",                                  \"CV-optimal (K=9)\" = \"green\", \"P-spline\" = \"purple\",                                  \"True signal\" = \"red\",                                  setNames(\"green\", paste0(\"CV-optimal (K=\", cv_opt$optimal.nbasis, \")\")))) +   scale_linetype_manual(values = c(\"Observed\" = \"solid\", \"Fourier (K=9)\" = \"solid\",                                     \"CV-optimal (K=9)\" = \"solid\", \"P-spline\" = \"solid\",                                     \"True signal\" = \"dashed\",                                     setNames(\"solid\", paste0(\"CV-optimal (K=\", cv_opt$optimal.nbasis, \")\")))) +   scale_linewidth_manual(values = c(\"Observed\" = 0.5, \"Fourier (K=9)\" = 1,                                      \"CV-optimal (K=9)\" = 1, \"P-spline\" = 1,                                      \"True signal\" = 1,                                      setNames(1, paste0(\"CV-optimal (K=\", cv_opt$optimal.nbasis, \")\")))) +   labs(x = \"t\", y = \"X(t)\", title = \"Comparison of Smoothing Methods\", color = NULL) +   theme_minimal() +   theme(legend.position = \"bottom\") +   guides(linetype = \"none\", linewidth = \"none\")"},{"path":[]},{"path":"https://sipemu.github.io/fdars/articles/basis-representation.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Finding the Best Basis Representation","text":"Fourier periodic patterns B-splines non-periodic data fdata2basis.cv() automatic nbasis selection basis.gcv(), basis.aic(), basis.bic() manual comparison Heavy noise scenarios want smooth derivatives Automatic smoothing parameter selection Validate comparing reconstructed curves original data","code":""},{"path":"https://sipemu.github.io/fdars/articles/basis-representation.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Finding the Best Basis Representation","text":"Ramsay, J.O. Silverman, B.W. (2005). Functional Data Analysis. Springer. Eilers, P.H.C. Marx, B.D. (1996). Flexible smoothing B-splines penalties. Statistical Science, 11(2), 89-121.","code":""},{"path":"https://sipemu.github.io/fdars/articles/clustering.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Functional Clustering","text":"Functional clustering groups curves clusters based similarity. fdars provides k-means clustering functional data : Multiple distance metrics k-means++ initialization Automatic optimal k selection","code":"library(fdars) #>  #> Attaching package: 'fdars' #> The following objects are masked from 'package:stats': #>  #>     cov, deriv, median, sd, var #> The following object is masked from 'package:base': #>  #>     norm library(ggplot2) theme_set(theme_minimal())  # Generate data with 3 distinct clusters set.seed(42) n_per_cluster <- 20 m <- 100 t_grid <- seq(0, 1, length.out = m)  # Cluster 1: Sine curves X1 <- matrix(0, n_per_cluster, m) for (i in 1:n_per_cluster) {   X1[i, ] <- sin(2 * pi * t_grid) + rnorm(m, sd = 0.15) }  # Cluster 2: Cosine curves X2 <- matrix(0, n_per_cluster, m) for (i in 1:n_per_cluster) {   X2[i, ] <- cos(2 * pi * t_grid) + rnorm(m, sd = 0.15) }  # Cluster 3: Linear curves X3 <- matrix(0, n_per_cluster, m) for (i in 1:n_per_cluster) {   X3[i, ] <- 2 * t_grid - 1 + rnorm(m, sd = 0.15) }  X <- rbind(X1, X2, X3) true_clusters <- rep(1:3, each = n_per_cluster)  fd <- fdata(X, argvals = t_grid) plot(fd)"},{"path":[]},{"path":"https://sipemu.github.io/fdars/articles/clustering.html","id":"basic-usage","dir":"Articles","previous_headings":"K-Means Clustering","what":"Basic Usage","title":"Functional Clustering","text":"","code":"# Cluster into 3 groups km <- cluster.kmeans(fd, ncl = 3, seed = 123) print(km) #> Functional K-Means Clustering #> ============================= #> Number of clusters: 3  #> Number of observations: 60  #>  #> Cluster sizes: #> [1] 20 20 20 #>  #> Within-cluster sum of squares: #> [1] 0.4394 0.4486 0.4199 #>  #> Total within-cluster SS: 1.3079"},{"path":"https://sipemu.github.io/fdars/articles/clustering.html","id":"visualizing-results","dir":"Articles","previous_headings":"K-Means Clustering","what":"Visualizing Results","title":"Functional Clustering","text":"","code":"plot(km)"},{"path":"https://sipemu.github.io/fdars/articles/clustering.html","id":"examining-cluster-assignments","dir":"Articles","previous_headings":"K-Means Clustering","what":"Examining Cluster Assignments","title":"Functional Clustering","text":"","code":"# Compare to true clusters table(Predicted = km$cluster, True = true_clusters) #>          True #> Predicted  1  2  3 #>         1  0 20  0 #>         2  0  0 20 #>         3 20  0  0  # Cluster sizes km$size #> [1] 20 20 20  # Within-cluster sum of squares km$withinss #> [1] 0.4394076 0.4485967 0.4199106"},{"path":"https://sipemu.github.io/fdars/articles/clustering.html","id":"multiple-random-starts","dir":"Articles","previous_headings":"K-Means Clustering","what":"Multiple Random Starts","title":"Functional Clustering","text":"Use nstart run k-means multiple times keep best result:","code":"# 20 random starts km_multi <- cluster.kmeans(fd, ncl = 3, nstart = 20, seed = 123) cat(\"Total within-cluster SS:\", km_multi$tot.withinss, \"\\n\") #> Total within-cluster SS: 1.307915"},{"path":[]},{"path":"https://sipemu.github.io/fdars/articles/clustering.html","id":"string-metrics-fast-rust-path","dir":"Articles","previous_headings":"Different Distance Metrics","what":"String Metrics (Fast Rust Path)","title":"Functional Clustering","text":"maximum speed, use string metrics run entirely Rust:","code":"# L2 (Euclidean) - default km_l2 <- cluster.kmeans(fd, ncl = 3, metric = \"L2\", seed = 123)  # L1 (Manhattan) km_l1 <- cluster.kmeans(fd, ncl = 3, metric = \"L1\", seed = 123)  # L-infinity km_linf <- cluster.kmeans(fd, ncl = 3, metric = \"Linf\", seed = 123)  cat(\"Total WSS - L2:\", km_l2$tot.withinss, \"\\n\") #> Total WSS - L2: 1.307915 cat(\"Total WSS - L1:\", km_l1$tot.withinss, \"\\n\") #> Total WSS - L1: 1.307915 cat(\"Total WSS - Linf:\", km_linf$tot.withinss, \"\\n\") #> Total WSS - Linf: 1.307915"},{"path":"https://sipemu.github.io/fdars/articles/clustering.html","id":"custom-metric-functions","dir":"Articles","previous_headings":"Different Distance Metrics","what":"Custom Metric Functions","title":"Functional Clustering","text":"flexibility, pass metric function:","code":"# Dynamic Time Warping km_dtw <- cluster.kmeans(fd, ncl = 3, metric = metric.DTW, seed = 123)  # Hausdorff distance km_haus <- cluster.kmeans(fd, ncl = 3, metric = metric.hausdorff, seed = 123)  # PCA-based semimetric km_pca <- cluster.kmeans(fd, ncl = 3, metric = semimetric.pca, ncomp = 5, seed = 123)"},{"path":"https://sipemu.github.io/fdars/articles/clustering.html","id":"optimal-number-of-clusters","dir":"Articles","previous_headings":"","what":"Optimal Number of Clusters","title":"Functional Clustering","text":"Choosing right number clusters crucial. cluster.optim provides three criteria selecting k.","code":""},{"path":"https://sipemu.github.io/fdars/articles/clustering.html","id":"silhouette-score","dir":"Articles","previous_headings":"Optimal Number of Clusters","what":"Silhouette Score","title":"Functional Clustering","text":"Measures similar curves cluster vs clusters. Higher better.","code":"opt_sil <- cluster.optim(fd, ncl.range = 2:6,                          criterion = \"silhouette\", seed = 123) print(opt_sil) #> Optimal K-Means Clustering #> ========================== #> Criterion: silhouette  #> K range tested: 2 - 6  #> Optimal k: 3  #>  #> Scores by k: #>  k  score #>  2 0.5867 #>  3 0.7781 #>  4 0.5493 #>  5 0.2902 #>  6 0.0283 plot(opt_sil)"},{"path":"https://sipemu.github.io/fdars/articles/clustering.html","id":"calinski-harabasz-index","dir":"Articles","previous_headings":"Optimal Number of Clusters","what":"Calinski-Harabasz Index","title":"Functional Clustering","text":"Ratio -cluster within-cluster variance. Higher better.","code":"opt_ch <- cluster.optim(fd, ncl.range = 2:6,                         criterion = \"CH\", seed = 123) print(opt_ch) #> Optimal K-Means Clustering #> ========================== #> Criterion: CH  #> K range tested: 2 - 6  #> Optimal k: 3  #>  #> Scores by k: #>  k    score #>  2  80.3382 #>  3 480.8701 #>  4 323.4328 #>  5 245.7028 #>  6 198.0615 plot(opt_ch)"},{"path":"https://sipemu.github.io/fdars/articles/clustering.html","id":"elbow-method","dir":"Articles","previous_headings":"Optimal Number of Clusters","what":"Elbow Method","title":"Functional Clustering","text":"Plots within-cluster SS vs k. Look ‚Äúelbow‚Äù adding clusters doesn‚Äôt help much.","code":"opt_elbow <- cluster.optim(fd, ncl.range = 2:6,                            criterion = \"elbow\", seed = 123) print(opt_elbow) #> Optimal K-Means Clustering #> ========================== #> Criterion: elbow  #> K range tested: 2 - 6  #> Optimal k: 3  #>  #> Scores by k: #>  k  score #>  2 9.6914 #>  3 1.3079 #>  4 1.2753 #>  5 1.2384 #>  6 1.2088 plot(opt_elbow)"},{"path":"https://sipemu.github.io/fdars/articles/clustering.html","id":"using-the-optimal-model","dir":"Articles","previous_headings":"Optimal Number of Clusters","what":"Using the Optimal Model","title":"Functional Clustering","text":"","code":"# Get the best model directly best_km <- opt_sil$best.model  # All models are stored all_models <- opt_sil$models"},{"path":"https://sipemu.github.io/fdars/articles/clustering.html","id":"k-means-initialization","dir":"Articles","previous_headings":"","what":"k-Means++ Initialization","title":"Functional Clustering","text":"k-means++ selects initial centers spread , improving convergence:","code":"# Get initial centers using k-means++ init_centers <- cluster.init(fd, ncl = 3, seed = 123) plot(init_centers)"},{"path":"https://sipemu.github.io/fdars/articles/clustering.html","id":"fuzzy-c-means-clustering","dir":"Articles","previous_headings":"","what":"Fuzzy C-Means Clustering","title":"Functional Clustering","text":"Unlike hard k-means curve belongs exactly one cluster, fuzzy c-means (FCM) assigns membership degrees cluster. useful clusters overlap want quantify uncertainty assignments.","code":""},{"path":"https://sipemu.github.io/fdars/articles/clustering.html","id":"basic-fuzzy-clustering","dir":"Articles","previous_headings":"Fuzzy C-Means Clustering","what":"Basic Fuzzy Clustering","title":"Functional Clustering","text":"","code":"# Fuzzy clustering with 3 clusters fcm <- cluster.fcm(fd, ncl = 3, seed = 123) print(fcm) #> Fuzzy C-Means Clustering #> ======================== #> Number of clusters: 3  #> Number of observations: 60  #> Fuzziness parameter m: 2  #>  #> Cluster sizes (hard assignment): #>  #>  1  2  3  #> 20 20 20  #>  #> Objective function: 1.3055  #>  #> Average membership per cluster: #>    C1    C2    C3  #> 0.333 0.333 0.333"},{"path":"https://sipemu.github.io/fdars/articles/clustering.html","id":"understanding-membership-degrees","dir":"Articles","previous_headings":"Fuzzy C-Means Clustering","what":"Understanding Membership Degrees","title":"Functional Clustering","text":"curve membership degree cluster, summing 1:","code":"# View membership matrix for first 6 curves head(round(fcm$membership, 3)) #>      [,1]  [,2]  [,3] #> [1,]    0 0.001 0.999 #> [2,]    0 0.000 0.999 #> [3,]    0 0.000 0.999 #> [4,]    0 0.000 1.000 #> [5,]    0 0.000 0.999 #> [6,]    0 0.001 0.999  # Curves with high membership in one cluster (clear assignment) max_membership <- apply(fcm$membership, 1, max) clear_assignments <- which(max_membership > 0.8) cat(\"Curves with clear cluster assignment:\", length(clear_assignments), \"/\",     nrow(fcm$membership), \"\\n\") #> Curves with clear cluster assignment: 60 / 60  # Curves with ambiguous membership (between clusters) ambiguous <- which(max_membership < 0.6) cat(\"Ambiguous curves:\", length(ambiguous), \"\\n\") #> Ambiguous curves: 0"},{"path":"https://sipemu.github.io/fdars/articles/clustering.html","id":"visualizing-fuzzy-clusters","dir":"Articles","previous_headings":"Fuzzy C-Means Clustering","what":"Visualizing Fuzzy Clusters","title":"Functional Clustering","text":"","code":"# Plot curves colored by hard assignment plot(fcm, type = \"curves\") # Plot membership degrees as stacked bars plot(fcm, type = \"membership\")"},{"path":"https://sipemu.github.io/fdars/articles/clustering.html","id":"the-fuzziness-parameter","dir":"Articles","previous_headings":"Fuzzy C-Means Clustering","what":"The Fuzziness Parameter","title":"Functional Clustering","text":"parameter m controls degree fuzziness: - m close 1: Hard clustering (like k-means) - m = 2: Standard choice (default) - m > 2: Softer clusters overlap","code":"# Compare different fuzziness levels fcm_hard <- cluster.fcm(fd, ncl = 3, m = 1.1, seed = 123) fcm_soft <- cluster.fcm(fd, ncl = 3, m = 3, seed = 123)  cat(\"Hard (m=1.1) - avg max membership:\",     round(mean(apply(fcm_hard$membership, 1, max)), 3), \"\\n\") #> Hard (m=1.1) - avg max membership: 1 cat(\"Default (m=2) - avg max membership:\",     round(mean(apply(fcm$membership, 1, max)), 3), \"\\n\") #> Default (m=2) - avg max membership: 0.999 cat(\"Soft (m=3) - avg max membership:\",     round(mean(apply(fcm_soft$membership, 1, max)), 3), \"\\n\") #> Soft (m=3) - avg max membership: 0.961"},{"path":"https://sipemu.github.io/fdars/articles/clustering.html","id":"when-to-use-fuzzy-clustering","dir":"Articles","previous_headings":"Fuzzy C-Means Clustering","what":"When to Use Fuzzy Clustering","title":"Functional Clustering","text":"Fuzzy clustering particularly useful : Clusters overlap: Curves may genuinely belong multiple groups Uncertainty quantification: need confidence cluster assignments Outlier detection: Low maximum membership may indicate outliers Transition states: Data represents continuous transitions states","code":"# Identify potential outliers (low max membership) max_mem <- apply(fcm$membership, 1, max) potential_outliers <- which(max_mem < quantile(max_mem, 0.1)) cat(\"Potential outliers (low membership):\", potential_outliers, \"\\n\") #> Potential outliers (low membership): 10 22 27 29 30 59"},{"path":[]},{"path":"https://sipemu.github.io/fdars/articles/clustering.html","id":"adjusted-rand-index","dir":"Articles","previous_headings":"Comparing Clustering Solutions","what":"Adjusted Rand Index","title":"Functional Clustering","text":"Compare two clusterings (requires external package):","code":"# If you have the mclust package library(mclust) adjustedRandIndex(km_l2$cluster, true_clusters)"},{"path":"https://sipemu.github.io/fdars/articles/clustering.html","id":"confusion-matrix","dir":"Articles","previous_headings":"Comparing Clustering Solutions","what":"Confusion Matrix","title":"Functional Clustering","text":"","code":"# Create contingency table conf_matrix <- table(Predicted = km$cluster, True = true_clusters) print(conf_matrix) #>          True #> Predicted  1  2  3 #>         1  0 20  0 #>         2  0  0 20 #>         3 20  0  0  # Accuracy (after optimal label matching) # Note: Cluster labels may be permuted max_matches <- 0 for (perm in list(c(1,2,3), c(1,3,2), c(2,1,3), c(2,3,1), c(3,1,2), c(3,2,1))) {   matched <- sum(km$cluster == perm[true_clusters])   max_matches <- max(max_matches, matched) } cat(\"Best matching accuracy:\", max_matches / length(true_clusters), \"\\n\") #> Best matching accuracy: 1"},{"path":"https://sipemu.github.io/fdars/articles/clustering.html","id":"visualizing-cluster-centers","dir":"Articles","previous_headings":"","what":"Visualizing Cluster Centers","title":"Functional Clustering","text":"","code":"# Extract centers centers <- km$centers  # Plot centers alone plot(centers)"},{"path":"https://sipemu.github.io/fdars/articles/clustering.html","id":"handling-overlapping-clusters","dir":"Articles","previous_headings":"","what":"Handling Overlapping Clusters","title":"Functional Clustering","text":"clusters overlap, different metrics may perform differently:","code":"# Create overlapping data set.seed(456) X_overlap <- matrix(0, 60, m) for (i in 1:30) {   X_overlap[i, ] <- sin(2 * pi * t_grid) + rnorm(m, sd = 0.3) } for (i in 31:60) {   X_overlap[i, ] <- sin(2 * pi * t_grid + 0.5) + rnorm(m, sd = 0.3) } fd_overlap <- fdata(X_overlap, argvals = t_grid)  # L2 may struggle with phase shifts km_overlap_l2 <- cluster.kmeans(fd_overlap, ncl = 2, metric = \"L2\", seed = 123)  # DTW handles phase shifts better km_overlap_dtw <- cluster.kmeans(fd_overlap, ncl = 2, metric = metric.DTW, seed = 123)  cat(\"L2 cluster balance:\", km_overlap_l2$size, \"\\n\") #> L2 cluster balance: 30 30 cat(\"DTW cluster balance:\", km_overlap_dtw$size, \"\\n\") #> DTW cluster balance: 30 30"},{"path":"https://sipemu.github.io/fdars/articles/clustering.html","id":"performance","dir":"Articles","previous_headings":"","what":"Performance","title":"Functional Clustering","text":"Rust backend provides fast clustering:","code":"# Benchmark with 500 curves X_large <- matrix(rnorm(500 * 200), 500, 200) fd_large <- fdata(X_large)  system.time(cluster.kmeans(fd_large, ncl = 5, metric = \"L2\", nstart = 10)) #>    user  system elapsed #>   0.234   0.000   0.078  system.time(cluster.kmeans(fd_large, ncl = 5, metric = metric.DTW, nstart = 10)) #>    user  system elapsed #>   4.567   0.000   1.234"},{"path":"https://sipemu.github.io/fdars/articles/clustering.html","id":"best-practices","dir":"Articles","previous_headings":"","what":"Best Practices","title":"Functional Clustering","text":"Standardize data curves different scales Use multiple random starts (nstart >= 10) Try different k values cluster.optim Compare metrics clusters may phase shifts Visualize results verify cluster quality","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/articles/clustering.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Functional Clustering","text":"Abraham, C., Cornillon, P.., Matzner-L√∏ber, E., Molinari, N. (2003). Unsupervised curve clustering using B-splines. Scandinavian Journal Statistics, 30(3), 581-595. Bezdek, J.C. (1981). Pattern Recognition Fuzzy Objective Function Algorithms. Plenum Press. Jacques, J. Preda, C. (2014). Functional data clustering: survey. Advances Data Analysis Classification, 8(3), 231-255.","code":""},{"path":"https://sipemu.github.io/fdars/articles/covariance-functions.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Covariance Functions and Gaussian Process Generation","text":"Covariance functions (also called kernels) fundamental building blocks Gaussian processes. define correlation structure function values different points, controlling properties like smoothness periodicity. fdars provides comprehensive set covariance functions generating synthetic functional data Gaussian processes.","code":"library(fdars) #>  #> Attaching package: 'fdars' #> The following objects are masked from 'package:stats': #>  #>     cov, deriv, median, sd, var #> The following object is masked from 'package:base': #>  #>     norm library(ggplot2) theme_set(theme_minimal())"},{"path":[]},{"path":"https://sipemu.github.io/fdars/articles/covariance-functions.html","id":"gaussian-squared-exponential","dir":"Articles","previous_headings":"Available Covariance Functions","what":"Gaussian (Squared Exponential)","title":"Covariance Functions and Gaussian Process Generation","text":"common choice, producing infinitely differentiable (smooth) sample paths: k(s,t)=œÉ2exp(‚àí(s‚àít)22‚Ñì2)k(s, t) = \\sigma^2 \\exp\\left(-\\frac{(s-t)^2}{2\\ell^2}\\right)  length_scale parameter controls correlation distance - smaller values produce rapidly varying functions:","code":"t <- seq(0, 1, length.out = 100)  # Create Gaussian covariance function cov_gauss <- kernel_gaussian(variance = 1, length_scale = 0.2) print(cov_gauss) #> Covariance Kernel: gaussian  #> Parameters: #>    variance = 1  #>    length_scale = 0.2  # Generate smooth GP samples fd_gauss <- make_gaussian_process(n = 10, t = t, cov = cov_gauss, seed = 42) plot(fd_gauss, main = \"Gaussian Covariance (smooth)\") # Generate data for different length scales ls_values <- c(0.05, 0.2, 0.5) df_ls <- do.call(rbind, lapply(ls_values, function(ls) {   fd <- make_gaussian_process(n = 5, t = t,                               cov = kernel_gaussian(length_scale = ls),                               seed = 42)   data.frame(     t = rep(t, 5),     value = as.vector(t(fd$data)),     curve = rep(1:5, each = length(t)),     length_scale = paste(\"length_scale =\", ls)   ) })) df_ls$length_scale <- factor(df_ls$length_scale,                               levels = paste(\"length_scale =\", ls_values))  ggplot(df_ls, aes(x = t, y = value, group = curve, color = factor(curve))) +   geom_line(alpha = 0.8) +   facet_wrap(~ length_scale) +   labs(x = \"t\", y = \"X(t)\", title = \"Effect of Length Scale\") +   theme_minimal() +   theme(legend.position = \"none\")"},{"path":"https://sipemu.github.io/fdars/articles/covariance-functions.html","id":"exponential","dir":"Articles","previous_headings":"Available Covariance Functions","what":"Exponential","title":"Covariance Functions and Gaussian Process Generation","text":"Produces rougher paths Gaussian (continuous differentiable): k(s,t)=œÉ2exp(‚àí|s‚àít|‚Ñì)k(s, t) = \\sigma^2 \\exp\\left(-\\frac{|s-t|}{\\ell}\\right)","code":"cov_exp <- kernel_exponential(variance = 1, length_scale = 0.2) fd_exp <- make_gaussian_process(n = 10, t = t, cov = cov_exp, seed = 42) plot(fd_exp, main = \"Exponential Covariance (rough)\")"},{"path":"https://sipemu.github.io/fdars/articles/covariance-functions.html","id":"matern-family","dir":"Articles","previous_headings":"Available Covariance Functions","what":"Matern Family","title":"Covariance Functions and Gaussian Process Generation","text":"Matern covariance parameterized smoothness parameter ŒΩ\\nu. interpolates Exponential (ŒΩ=0.5\\nu = 0.5) Gaussian (ŒΩ‚Üí‚àû\\nu \\\\infty):  Common choices : - ŒΩ=0.5\\nu = 0.5: Equivalent Exponential (rough) - ŒΩ=1.5\\nu = 1.5: differentiable - ŒΩ=2.5\\nu = 2.5: Twice differentiable - ŒΩ=‚àû\\nu = \\infty: Equivalent Gaussian (infinitely smooth)","code":"# Generate data for different nu values nu_values <- c(0.5, 1.5, 2.5, Inf) nu_labels <- c(\"0.5\", \"1.5\", \"2.5\", \"Inf\") df_matern <- do.call(rbind, lapply(seq_along(nu_values), function(i) {   fd <- make_gaussian_process(n = 5, t = t,                               cov = kernel_matern(length_scale = 0.2, nu = nu_values[i]),                               seed = 42)   data.frame(     t = rep(t, 5),     value = as.vector(t(fd$data)),     curve = rep(1:5, each = length(t)),     nu = paste(\"Matern nu =\", nu_labels[i])   ) })) df_matern$nu <- factor(df_matern$nu,                         levels = paste(\"Matern nu =\", nu_labels))  ggplot(df_matern, aes(x = t, y = value, group = curve, color = factor(curve))) +   geom_line(alpha = 0.8) +   facet_wrap(~ nu, ncol = 2) +   labs(x = \"t\", y = \"X(t)\", title = \"Matern Covariance with Different Smoothness\") +   theme_minimal() +   theme(legend.position = \"none\")"},{"path":"https://sipemu.github.io/fdars/articles/covariance-functions.html","id":"brownian-motion","dir":"Articles","previous_headings":"Available Covariance Functions","what":"Brownian Motion","title":"Covariance Functions and Gaussian Process Generation","text":"Standard Brownian motion covariance: k(s,t)=œÉ2min(s,t)k(s, t) = \\sigma^2 \\min(s, t)  Note: Brownian covariance defined 1D domains.","code":"cov_brown <- kernel_brownian(variance = 1) fd_brown <- make_gaussian_process(n = 10, t = t, cov = cov_brown, seed = 42) plot(fd_brown, main = \"Brownian Motion\")"},{"path":"https://sipemu.github.io/fdars/articles/covariance-functions.html","id":"periodic","dir":"Articles","previous_headings":"Available Covariance Functions","what":"Periodic","title":"Covariance Functions and Gaussian Process Generation","text":"data periodic structure: k(s,t)=œÉ2exp(‚àí2sin2(œÄ|s‚àít|/p)‚Ñì2)k(s, t) = \\sigma^2 \\exp\\left(-\\frac{2\\sin^2(\\pi|s-t|/p)}{\\ell^2}\\right)","code":"t_long <- seq(0, 3, length.out = 200) cov_per <- kernel_periodic(variance = 1, length_scale = 0.5, period = 1) fd_per <- make_gaussian_process(n = 5, t = t_long, cov = cov_per, seed = 42) plot(fd_per, main = \"Periodic Covariance (period = 1)\")"},{"path":"https://sipemu.github.io/fdars/articles/covariance-functions.html","id":"linear","dir":"Articles","previous_headings":"Available Covariance Functions","what":"Linear","title":"Covariance Functions and Gaussian Process Generation","text":"Linear covariance produces functions linear combinations constant linear function: k(s,t)=œÉ2(s‚ãÖt+c)k(s, t) = \\sigma^2 (s \\cdot t + c)","code":"cov_lin <- kernel_linear(variance = 1, offset = 0) fd_lin <- make_gaussian_process(n = 10, t = t, cov = cov_lin, seed = 42) plot(fd_lin, main = \"Linear Covariance\")"},{"path":"https://sipemu.github.io/fdars/articles/covariance-functions.html","id":"polynomial","dir":"Articles","previous_headings":"Available Covariance Functions","what":"Polynomial","title":"Covariance Functions and Gaussian Process Generation","text":"Generalization linear polynomial basis functions: k(s,t)=œÉ2(s‚ãÖt+c)dk(s, t) = \\sigma^2 (s \\cdot t + c)^d","code":"cov_poly <- kernel_polynomial(variance = 1, offset = 1, degree = 3) fd_poly <- make_gaussian_process(n = 10, t = t, cov = cov_poly, seed = 42) plot(fd_poly, main = \"Polynomial Covariance (degree 3)\")"},{"path":"https://sipemu.github.io/fdars/articles/covariance-functions.html","id":"white-noise","dir":"Articles","previous_headings":"Available Covariance Functions","what":"White Noise","title":"Covariance Functions and Gaussian Process Generation","text":"Diagonal covariance representing independent noise: k(s,t)=œÉ2ùüès=tk(s, t) = \\sigma^2 \\mathbf{1}_{s=t}","code":"cov_white <- kernel_whitenoise(variance = 0.5) fd_white <- make_gaussian_process(n = 5, t = t, cov = cov_white, seed = 42) plot(fd_white, main = \"White Noise\")"},{"path":[]},{"path":"https://sipemu.github.io/fdars/articles/covariance-functions.html","id":"addition-kernel_add","dir":"Articles","previous_headings":"Combining Covariance Functions","what":"Addition (kernel_add)","title":"Covariance Functions and Gaussian Process Generation","text":"Sum covariance functions models independent components:","code":"# Signal + noise model cov_signal <- kernel_gaussian(variance = 1, length_scale = 0.2) cov_noise <- kernel_whitenoise(variance = 0.1) cov_total <- kernel_add(cov_signal, cov_noise)  fd_noisy <- make_gaussian_process(n = 5, t = t, cov = cov_total, seed = 42) plot(fd_noisy, main = \"Smooth signal + noise\")"},{"path":"https://sipemu.github.io/fdars/articles/covariance-functions.html","id":"multiplication-kernel_mult","dir":"Articles","previous_headings":"Combining Covariance Functions","what":"Multiplication (kernel_mult)","title":"Covariance Functions and Gaussian Process Generation","text":"Product covariance functions:","code":"# Locally periodic: smooth envelope modulating periodic behavior cov_envelope <- kernel_gaussian(variance = 1, length_scale = 0.5) cov_periodic <- kernel_periodic(period = 0.2) cov_local_per <- kernel_mult(cov_envelope, cov_periodic)  fd_local_per <- make_gaussian_process(n = 5, t = t, cov = cov_local_per, seed = 42) plot(fd_local_per, main = \"Locally periodic\")"},{"path":"https://sipemu.github.io/fdars/articles/covariance-functions.html","id":"mean-functions","dir":"Articles","previous_headings":"","what":"Mean Functions","title":"Covariance Functions and Gaussian Process Generation","text":"Gaussian processes can non-zero mean functions:","code":"# Scalar mean fd_mean5 <- make_gaussian_process(n = 10, t = t,                                    cov = kernel_gaussian(variance = 0.1),                                    mean = 5, seed = 42) plot(fd_mean5, main = \"Constant mean = 5\") # Function mean mean_func <- function(t) sin(2 * pi * t) fd_sinmean <- make_gaussian_process(n = 10, t = t,                                      cov = kernel_gaussian(variance = 0.1),                                      mean = mean_func, seed = 42) plot(fd_sinmean, main = \"Sinusoidal mean function\")"},{"path":"https://sipemu.github.io/fdars/articles/covariance-functions.html","id":"d-functional-data-surfaces","dir":"Articles","previous_headings":"","what":"2D Functional Data (Surfaces)","title":"Covariance Functions and Gaussian Process Generation","text":"Covariance functions can generate 2D functional data (surfaces):  Note: kernel_brownian() kernel_periodic() support 1D domains.","code":"s <- seq(0, 1, length.out = 30) t2d <- seq(0, 1, length.out = 30)  # Generate 2D GP samples fd2d <- make_gaussian_process(n = 4, t = list(s, t2d),                                cov = kernel_gaussian(length_scale = 0.3),                                seed = 42) plot(fd2d)"},{"path":"https://sipemu.github.io/fdars/articles/covariance-functions.html","id":"reproducibility","dir":"Articles","previous_headings":"","what":"Reproducibility","title":"Covariance Functions and Gaussian Process Generation","text":"Use seed parameter reproducible samples:","code":"fd1 <- make_gaussian_process(n = 3, t = t, cov = kernel_gaussian(), seed = 123) fd2 <- make_gaussian_process(n = 3, t = t, cov = kernel_gaussian(), seed = 123) all.equal(fd1$data, fd2$data)  # TRUE #> [1] TRUE"},{"path":"https://sipemu.github.io/fdars/articles/covariance-functions.html","id":"comparison-of-smoothness","dir":"Articles","previous_headings":"","what":"Comparison of Smoothness","title":"Covariance Functions and Gaussian Process Generation","text":"","code":"# Generate data for comparison kernels <- list(   list(name = \"Gaussian (very smooth)\", cov = kernel_gaussian()),   list(name = \"Matern 5/2\", cov = kernel_matern(nu = 2.5)),   list(name = \"Matern 3/2\", cov = kernel_matern(nu = 1.5)),   list(name = \"Exponential (rough)\", cov = kernel_exponential()) )  df_smooth_comp <- do.call(rbind, lapply(kernels, function(k) {   fd <- make_gaussian_process(n = 3, t = t, cov = k$cov, seed = 1)   data.frame(     t = rep(t, 3),     value = as.vector(t(fd$data)),     curve = rep(1:3, each = length(t)),     kernel = k$name   ) })) df_smooth_comp$kernel <- factor(df_smooth_comp$kernel,                                  levels = sapply(kernels, function(k) k$name))  ggplot(df_smooth_comp, aes(x = t, y = value, group = curve, color = factor(curve))) +   geom_line(alpha = 0.8) +   facet_wrap(~ kernel, ncol = 2) +   labs(x = \"t\", y = \"X(t)\", title = \"Comparison of Smoothness\") +   theme_minimal() +   theme(legend.position = \"none\")"},{"path":[]},{"path":"https://sipemu.github.io/fdars/articles/covariance-functions.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Covariance Functions and Gaussian Process Generation","text":"Rasmussen, C.E. Williams, C.K.. (2006). Gaussian Processes Machine Learning. MIT Press. Ramsay, J.O. Silverman, B.W. (2005). Functional Data Analysis. Springer.","code":""},{"path":"https://sipemu.github.io/fdars/articles/custom-plotting.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Custom Plotting with ggplot2","text":"fdars package provides convenient plot() autoplot() methods functional data objects. However, publication-quality figures specialized visualizations, may need control. vignette shows create fully customizable plots using ggplot2 directly.","code":"library(fdars) library(ggplot2) library(dplyr) library(tidyr) theme_set(theme_minimal())"},{"path":"https://sipemu.github.io/fdars/articles/custom-plotting.html","id":"understanding-the-fdata-structure","dir":"Articles","previous_headings":"","what":"Understanding the fdata Structure","title":"Custom Plotting with ggplot2","text":"fdata object contains: data: Matrix size [n, m] n number curves m number evaluation points argvals: Vector length m evaluation points (time/domain values) id: Character vector curve identifiers metadata: Optional data frame covariates","code":"# Create example data set.seed(42) n <- 30 m <- 100 t_grid <- seq(0, 2*pi, length.out = m)  # Generate curves from two groups X <- matrix(0, n, m) groups <- rep(c(\"Treatment\", \"Control\"), each = n/2) for (i in 1:n) {   if (groups[i] == \"Treatment\") {     X[i, ] <- sin(t_grid) + 0.5 + rnorm(m, sd = 0.2)   } else {     X[i, ] <- sin(t_grid) + rnorm(m, sd = 0.2)   } }  # Create fdata with metadata meta <- data.frame(   group = groups,   age = runif(n, 20, 60),   response = rnorm(n) )  fd <- fdata(X, argvals = t_grid,             id = paste0(\"subject_\", 1:n),             metadata = meta,             names = list(main = \"Example Data\",                         xlab = \"Time (s)\",                         ylab = \"Signal\"))  # Inspect the structure str(fd, max.level = 1) #> List of 7 #>  $ data    : num [1:30, 1:100] 0.7742 0.7402 0.0998 0.4991 0.767 ... #>  $ argvals : num [1:100] 0 0.0635 0.1269 0.1904 0.2539 ... #>  $ rangeval: num [1:2] 0 6.28 #>  $ names   :List of 3 #>  $ fdata2d : logi FALSE #>  $ id      : chr [1:30] \"subject_1\" \"subject_2\" \"subject_3\" \"subject_4\" ... #>  $ metadata:'data.frame':    30 obs. of  3 variables: #>  - attr(*, \"class\")= chr \"fdata\""},{"path":"https://sipemu.github.io/fdars/articles/custom-plotting.html","id":"converting-fdata-to-long-format","dir":"Articles","previous_headings":"","what":"Converting fdata to Long Format","title":"Custom Plotting with ggplot2","text":"key custom plotting converting wide matrix format long (tidy) format ggplot2 expects.","code":"# Function to convert fdata to long format fdata_to_long <- function(fd, include_metadata = TRUE) {   n <- nrow(fd$data)   m <- ncol(fd$data)    # Create base long-format data frame   df <- data.frame(     curve_id = rep(fd$id, each = m),     t = rep(fd$argvals, n),     value = as.vector(t(fd$data))   )    # Add metadata if requested and available   if (include_metadata && !is.null(fd$metadata)) {     # Expand metadata to match long format     meta_expanded <- fd$metadata[rep(seq_len(n), each = m), , drop = FALSE]     df <- cbind(df, meta_expanded)     rownames(df) <- NULL   }    df }  # Convert our data df_long <- fdata_to_long(fd) head(df_long) #>    curve_id          t     value     group      age response #> 1 subject_1 0.00000000 0.7741917 Treatment 29.85853 -1.11855 #> 2 subject_1 0.06346652 0.4504843 Treatment 29.85853 -1.11855 #> 3 subject_1 0.12693304 0.6992181 Treatment 29.85853 -1.11855 #> 4 subject_1 0.19039955 0.8158238 Treatment 29.85853 -1.11855 #> 5 subject_1 0.25386607 0.8320017 Treatment 29.85853 -1.11855 #> 6 subject_1 0.31733259 0.7908085 Treatment 29.85853 -1.11855"},{"path":[]},{"path":"https://sipemu.github.io/fdars/articles/custom-plotting.html","id":"simple-spaghetti-plot","dir":"Articles","previous_headings":"Basic Custom Plots","what":"Simple Spaghetti Plot","title":"Custom Plotting with ggplot2","text":"","code":"ggplot(df_long, aes(x = t, y = value, group = curve_id)) +   geom_line(alpha = 0.5, linewidth = 0.3) +   labs(x = \"Time (s)\", y = \"Signal\", title = \"All Curves\") +   theme_minimal()"},{"path":"https://sipemu.github.io/fdars/articles/custom-plotting.html","id":"coloring-by-group","dir":"Articles","previous_headings":"Basic Custom Plots","what":"Coloring by Group","title":"Custom Plotting with ggplot2","text":"","code":"ggplot(df_long, aes(x = t, y = value, group = curve_id, color = group)) +   geom_line(alpha = 0.6, linewidth = 0.4) +   scale_color_manual(values = c(\"Treatment\" = \"#E69F00\", \"Control\" = \"#56B4E9\")) +   labs(x = \"Time (s)\", y = \"Signal\", color = \"Group\") +   theme_minimal() +   theme(legend.position = \"top\")"},{"path":"https://sipemu.github.io/fdars/articles/custom-plotting.html","id":"coloring-by-continuous-variable","dir":"Articles","previous_headings":"Basic Custom Plots","what":"Coloring by Continuous Variable","title":"Custom Plotting with ggplot2","text":"","code":"ggplot(df_long, aes(x = t, y = value, group = curve_id, color = age)) +   geom_line(alpha = 0.7, linewidth = 0.4) +   scale_color_viridis_c(option = \"plasma\") +   labs(x = \"Time (s)\", y = \"Signal\", color = \"Age\") +   theme_minimal()"},{"path":[]},{"path":"https://sipemu.github.io/fdars/articles/custom-plotting.html","id":"mean-and-confidence-intervals-by-group","dir":"Articles","previous_headings":"Adding Summary Statistics","what":"Mean and Confidence Intervals by Group","title":"Custom Plotting with ggplot2","text":"","code":"# Compute group summaries df_summary <- df_long %>%   group_by(group, t) %>%   summarise(     mean = mean(value),     sd = sd(value),     n = n(),     se = sd / sqrt(n),     ci_lower = mean - 1.96 * se,     ci_upper = mean + 1.96 * se,     .groups = \"drop\"   )  # Plot with ribbons and mean lines ggplot() +   # Individual curves (faded)   geom_line(data = df_long,             aes(x = t, y = value, group = curve_id, color = group),             alpha = 0.2, linewidth = 0.3) +   # Confidence interval ribbons   geom_ribbon(data = df_summary,               aes(x = t, ymin = ci_lower, ymax = ci_upper, fill = group),               alpha = 0.3) +   # Mean lines   geom_line(data = df_summary,             aes(x = t, y = mean, color = group),             linewidth = 1.2) +   scale_color_manual(values = c(\"Treatment\" = \"#E69F00\", \"Control\" = \"#56B4E9\")) +   scale_fill_manual(values = c(\"Treatment\" = \"#E69F00\", \"Control\" = \"#56B4E9\")) +   labs(x = \"Time (s)\", y = \"Signal\",        title = \"Group Means with 95% CI\",        color = \"Group\", fill = \"Group\") +   theme_minimal() +   theme(legend.position = \"top\")"},{"path":"https://sipemu.github.io/fdars/articles/custom-plotting.html","id":"median-and-quantile-bands","dir":"Articles","previous_headings":"Adding Summary Statistics","what":"Median and Quantile Bands","title":"Custom Plotting with ggplot2","text":"","code":"df_quantiles <- df_long %>%   group_by(group, t) %>%   summarise(     median = median(value),     q25 = quantile(value, 0.25),     q75 = quantile(value, 0.75),     q10 = quantile(value, 0.10),     q90 = quantile(value, 0.90),     .groups = \"drop\"   )  ggplot(df_quantiles, aes(x = t)) +   # 10-90% band   geom_ribbon(aes(ymin = q10, ymax = q90, fill = group), alpha = 0.2) +   # 25-75% band (IQR)   geom_ribbon(aes(ymin = q25, ymax = q75, fill = group), alpha = 0.4) +   # Median line   geom_line(aes(y = median, color = group), linewidth = 1) +   scale_color_brewer(palette = \"Set1\") +   scale_fill_brewer(palette = \"Set1\") +   facet_wrap(~ group) +   labs(x = \"Time (s)\", y = \"Signal\",        title = \"Median with IQR and 10-90% Bands\") +   theme_minimal() +   theme(legend.position = \"none\")"},{"path":[]},{"path":"https://sipemu.github.io/fdars/articles/custom-plotting.html","id":"highlighting-outliers","dir":"Articles","previous_headings":"Highlighting Specific Curves","what":"Highlighting Outliers","title":"Custom Plotting with ggplot2","text":"","code":"# Detect outliers using depth depths <- depth.MBD(fd) outlier_threshold <- quantile(depths, 0.1) outlier_ids <- fd$id[depths < outlier_threshold]  # Add outlier flag to data df_long$is_outlier <- df_long$curve_id %in% outlier_ids  ggplot(df_long, aes(x = t, y = value, group = curve_id)) +   # Non-outliers in gray   geom_line(data = filter(df_long, !is_outlier),             color = \"gray70\", alpha = 0.5, linewidth = 0.3) +   # Outliers in red   geom_line(data = filter(df_long, is_outlier),             color = \"red\", alpha = 0.8, linewidth = 0.6) +   labs(x = \"Time (s)\", y = \"Signal\",        title = \"Outlier Curves Highlighted\",        subtitle = paste(length(outlier_ids), \"outliers detected\")) +   theme_minimal()"},{"path":"https://sipemu.github.io/fdars/articles/custom-plotting.html","id":"highlighting-a-subset-with-labels","dir":"Articles","previous_headings":"Highlighting Specific Curves","what":"Highlighting a Subset with Labels","title":"Custom Plotting with ggplot2","text":"","code":"# Select specific curves to highlight highlight_ids <- c(\"subject_1\", \"subject_15\", \"subject_30\") df_long$highlight <- df_long$curve_id %in% highlight_ids  # Get endpoint positions for labels df_endpoints <- df_long %>%   filter(highlight) %>%   group_by(curve_id) %>%   filter(t == max(t))  ggplot(df_long, aes(x = t, y = value, group = curve_id)) +   geom_line(data = filter(df_long, !highlight),             color = \"gray80\", alpha = 0.5, linewidth = 0.3) +   geom_line(data = filter(df_long, highlight),             aes(color = curve_id), linewidth = 0.8) +   geom_text(data = df_endpoints,             aes(label = curve_id, color = curve_id),             hjust = -0.1, size = 3) +   scale_color_brewer(palette = \"Dark2\") +   coord_cartesian(xlim = c(0, max(t_grid) * 1.15)) +   labs(x = \"Time (s)\", y = \"Signal\") +   theme_minimal() +   theme(legend.position = \"none\")"},{"path":[]},{"path":"https://sipemu.github.io/fdars/articles/custom-plotting.html","id":"facet-by-group","dir":"Articles","previous_headings":"Faceted Plots","what":"Facet by Group","title":"Custom Plotting with ggplot2","text":"### Facet Binned Continuous Variable","code":"ggplot(df_long, aes(x = t, y = value, group = curve_id)) +   geom_line(alpha = 0.5, linewidth = 0.3) +   facet_wrap(~ group, ncol = 2) +   labs(x = \"Time (s)\", y = \"Signal\") +   theme_bw() # Create age bins df_long$age_bin <- cut(df_long$age,                        breaks = c(20, 35, 50, 65),                        labels = c(\"Young (20-35)\", \"Middle (35-50)\", \"Senior (50-65)\"))  ggplot(df_long, aes(x = t, y = value, group = curve_id, color = group)) +   geom_line(alpha = 0.6, linewidth = 0.4) +   facet_wrap(~ age_bin, nrow = 1) +   scale_color_brewer(palette = \"Set1\") +   labs(x = \"Time (s)\", y = \"Signal\", color = \"Group\") +   theme_minimal() +   theme(legend.position = \"bottom\")"},{"path":"https://sipemu.github.io/fdars/articles/custom-plotting.html","id":"small-multiples-individual-curves","dir":"Articles","previous_headings":"Faceted Plots","what":"Small Multiples (Individual Curves)","title":"Custom Plotting with ggplot2","text":"","code":"# Show first 12 curves as small multiples selected_ids <- fd$id[1:12] df_subset <- filter(df_long, curve_id %in% selected_ids)  ggplot(df_subset, aes(x = t, y = value)) +   geom_line(color = \"steelblue\") +   facet_wrap(~ curve_id, ncol = 4, scales = \"free_y\") +   labs(x = \"Time\", y = \"Signal\") +   theme_minimal() +   theme(strip.text = element_text(size = 8))"},{"path":[]},{"path":"https://sipemu.github.io/fdars/articles/custom-plotting.html","id":"rainbow-plot-curves-colored-by-index","dir":"Articles","previous_headings":"Advanced Visualizations","what":"Rainbow Plot (Curves Colored by Index)","title":"Custom Plotting with ggplot2","text":"","code":"# Add curve index curve_order <- match(df_long$curve_id, unique(df_long$curve_id)) df_long$curve_index <- curve_order  ggplot(df_long, aes(x = t, y = value, group = curve_id, color = curve_index)) +   geom_line(alpha = 0.7, linewidth = 0.4) +   scale_color_viridis_c(option = \"turbo\") +   labs(x = \"Time (s)\", y = \"Signal\", color = \"Curve #\") +   theme_minimal()"},{"path":"https://sipemu.github.io/fdars/articles/custom-plotting.html","id":"phase-plane-plot-value-vs-derivative","dir":"Articles","previous_headings":"Advanced Visualizations","what":"Phase Plane Plot (Value vs Derivative)","title":"Custom Plotting with ggplot2","text":"","code":"# Compute derivatives fd_deriv <- deriv(fd) df_deriv <- fdata_to_long(fd_deriv) names(df_deriv)[names(df_deriv) == \"value\"] <- \"velocity\"  # Merge with original values df_phase <- df_long %>%   select(curve_id, t, value, group) %>%   left_join(select(df_deriv, curve_id, t, velocity),             by = c(\"curve_id\", \"t\"))  ggplot(df_phase, aes(x = value, y = velocity, group = curve_id, color = group)) +   geom_path(alpha = 0.5, linewidth = 0.3) +   scale_color_brewer(palette = \"Set1\") +   labs(x = \"Signal Value\", y = \"Signal Velocity (derivative)\",        title = \"Phase Plane Plot\") +   theme_minimal() +   coord_equal()"},{"path":"https://sipemu.github.io/fdars/articles/custom-plotting.html","id":"functional-boxplot-components","dir":"Articles","previous_headings":"Advanced Visualizations","what":"Functional Boxplot Components","title":"Custom Plotting with ggplot2","text":"","code":"# Get functional boxplot data fbp <- boxplot(fd)  # Extract components manually for custom plotting median_curve <- fd$data[fbp$median, ] central_curves <- fd$data[fbp$central, ] outlier_curves <- if (length(fbp$outliers) > 0) fd$data[fbp$outliers, , drop = FALSE] else NULL  # Compute envelopes env_lower <- apply(central_curves, 2, min) env_upper <- apply(central_curves, 2, max)  # Create custom plot df_envelope <- data.frame(   t = fd$argvals,   lower = env_lower,   upper = env_upper,   median = median_curve )  p <- ggplot() +   # Central envelope   geom_ribbon(data = df_envelope,               aes(x = t, ymin = lower, ymax = upper),               fill = \"steelblue\", alpha = 0.4) +   # Median curve   geom_line(data = df_envelope,             aes(x = t, y = median),             color = \"navy\", linewidth = 1.2) +   labs(x = \"Time (s)\", y = \"Signal\",        title = \"Custom Functional Boxplot\") +   theme_minimal()  # Add outliers if present if (!is.null(outlier_curves)) {   df_outliers <- data.frame(     curve_id = rep(fbp$outliers, each = m),     t = rep(fd$argvals, length(fbp$outliers)),     value = as.vector(t(outlier_curves))   )   p <- p + geom_line(data = df_outliers,                      aes(x = t, y = value, group = curve_id),                      color = \"red\", alpha = 0.7, linewidth = 0.5) }  p"},{"path":"https://sipemu.github.io/fdars/articles/custom-plotting.html","id":"heatmap-representation","dir":"Articles","previous_headings":"Advanced Visualizations","what":"Heatmap Representation","title":"Custom Plotting with ggplot2","text":"","code":"# Order curves by depth for better visualization depth_order <- order(depths, decreasing = TRUE) df_long$curve_rank <- match(df_long$curve_id, fd$id[depth_order])  ggplot(df_long, aes(x = t, y = curve_rank, fill = value)) +   geom_tile() +   scale_fill_viridis_c(option = \"magma\") +   scale_y_reverse() +   labs(x = \"Time (s)\", y = \"Curve (ordered by depth)\",        fill = \"Value\",        title = \"Heatmap of Functional Data\") +   theme_minimal()"},{"path":[]},{"path":"https://sipemu.github.io/fdars/articles/custom-plotting.html","id":"adding-annotations","dir":"Articles","previous_headings":"Combining with Other ggplot2 Extensions","what":"Adding Annotations","title":"Custom Plotting with ggplot2","text":"","code":"# Find peaks for each curve df_peaks <- df_long %>%   group_by(curve_id) %>%   slice_max(value, n = 1) %>%   ungroup()  ggplot(df_long, aes(x = t, y = value, group = curve_id)) +   geom_line(alpha = 0.3, linewidth = 0.3, color = \"gray50\") +   geom_point(data = df_peaks, aes(color = group), size = 1.5, alpha = 0.7) +   scale_color_brewer(palette = \"Set1\") +   labs(x = \"Time (s)\", y = \"Signal\",        title = \"Peak Locations by Group\",        color = \"Group\") +   theme_minimal()"},{"path":"https://sipemu.github.io/fdars/articles/custom-plotting.html","id":"using-ggforce-for-hulls","dir":"Articles","previous_headings":"Combining with Other ggplot2 Extensions","what":"Using ggforce for Hulls","title":"Custom Plotting with ggplot2","text":"","code":"# If ggforce is available if (requireNamespace(\"ggforce\", quietly = TRUE)) {   # Compute FPCA scores for 2D representation   pc <- fdata2pc(fd, ncomp = 2)   df_scores <- data.frame(     PC1 = pc$x[, 1],     PC2 = pc$x[, 2],     group = fd$metadata$group   )    ggplot(df_scores, aes(x = PC1, y = PC2, color = group, fill = group)) +     ggforce::geom_mark_ellipse(alpha = 0.1) +     geom_point(size = 2) +     scale_color_brewer(palette = \"Set1\") +     scale_fill_brewer(palette = \"Set1\") +     labs(title = \"FPCA Scores with Group Ellipses\") +     theme_minimal() }"},{"path":"https://sipemu.github.io/fdars/articles/custom-plotting.html","id":"theming-for-publication","dir":"Articles","previous_headings":"","what":"Theming for Publication","title":"Custom Plotting with ggplot2","text":"","code":"# Define a publication-ready theme theme_publication <- function(base_size = 11) {   theme_minimal(base_size = base_size) %+replace%     theme(       panel.grid.minor = element_blank(),       panel.grid.major = element_line(color = \"gray90\", linewidth = 0.3),       axis.line = element_line(color = \"black\", linewidth = 0.4),       axis.ticks = element_line(color = \"black\", linewidth = 0.3),       legend.position = \"bottom\",       legend.key.size = unit(0.8, \"lines\"),       plot.title = element_text(face = \"bold\", hjust = 0),       strip.background = element_rect(fill = \"gray95\", color = NA)     ) }  # Publication-quality plot ggplot(df_summary, aes(x = t, color = group, fill = group)) +   geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper), alpha = 0.2, color = NA) +   geom_line(aes(y = mean), linewidth = 0.8) +   scale_color_manual(values = c(\"Treatment\" = \"#D55E00\", \"Control\" = \"#0072B2\"),                      labels = c(\"Treatment\", \"Control\")) +   scale_fill_manual(values = c(\"Treatment\" = \"#D55E00\", \"Control\" = \"#0072B2\"),                     labels = c(\"Treatment\", \"Control\")) +   labs(x = \"Time (s)\", y = \"Signal (a.u.)\",        color = NULL, fill = NULL) +   theme_publication() +   guides(color = guide_legend(override.aes = list(linewidth = 2)))"},{"path":"https://sipemu.github.io/fdars/articles/custom-plotting.html","id":"saving-plots","dir":"Articles","previous_headings":"","what":"Saving Plots","title":"Custom Plotting with ggplot2","text":"","code":"# Create your plot p <- ggplot(df_summary, aes(x = t, y = mean, color = group)) +   geom_line(linewidth = 1) +   theme_minimal()  # Save as PNG (for web/presentations) ggsave(\"functional_plot.png\", p, width = 7, height = 5, dpi = 300)  # Save as PDF (for publications) ggsave(\"functional_plot.pdf\", p, width = 7, height = 5)  # Save as SVG (for editing in Illustrator/Inkscape) ggsave(\"functional_plot.svg\", p, width = 7, height = 5)"},{"path":"https://sipemu.github.io/fdars/articles/custom-plotting.html","id":"summary-fdata-to-ggplot2-workflow","dir":"Articles","previous_headings":"","what":"Summary: fdata to ggplot2 Workflow","title":"Custom Plotting with ggplot2","text":"Convert long format: Use fdata_to_long() function shown Add metadata: Include covariates coloring/faceting Compute summaries: Use dplyr means, CIs, quantiles Build layers: Start individual curves, add summaries top Customize appearance: Apply themes, colors, labels Export: Use ggsave() appropriate format resolution","code":"# Complete workflow example fd %>%   fdata_to_long() %>%   ggplot(aes(x = t, y = value, group = curve_id, color = group)) +   geom_line(alpha = 0.5) +   stat_summary(aes(group = group), fun = mean, geom = \"line\", linewidth = 1.5) +   scale_color_brewer(palette = \"Set1\") +   labs(x = \"Time\", y = \"Value\") +   theme_minimal()"},{"path":"https://sipemu.github.io/fdars/articles/depth-functions.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Functional Depth Functions","text":"Functional depth measure ‚Äúcentral‚Äù ‚Äútypical‚Äù curve within sample curves. Curves high depth considered representative sample, curves low depth outliers extreme observations. Depth functions extend concept statistical depth (like data depth multivariate data) infinite-dimensional setting functional data.","code":"library(fdars) #>  #> Attaching package: 'fdars' #> The following objects are masked from 'package:stats': #>  #>     cov, deriv, median, sd, var #> The following object is masked from 'package:base': #>  #>     norm library(ggplot2) theme_set(theme_minimal())  # Create example data set.seed(42) n <- 30 m <- 100 t_grid <- seq(0, 1, length.out = m)  # Main sample: sine curves with noise X <- matrix(0, n, m) for (i in 1:n) {   X[i, ] <- sin(2 * pi * t_grid) + rnorm(m, sd = 0.15) }  # Add some outliers X[1, ] <- sin(2 * pi * t_grid) + 2  # Magnitude outlier X[2, ] <- cos(2 * pi * t_grid)       # Shape outlier  fd <- fdata(X, argvals = t_grid) plot(fd)"},{"path":"https://sipemu.github.io/fdars/articles/depth-functions.html","id":"available-depth-functions","dir":"Articles","previous_headings":"","what":"Available Depth Functions","title":"Functional Depth Functions","text":"depth functions accessed unified depth() function method parameter.","code":""},{"path":"https://sipemu.github.io/fdars/articles/depth-functions.html","id":"fraiman-muniz-depth-method-fm","dir":"Articles","previous_headings":"Available Depth Functions","what":"Fraiman-Muniz Depth (method = ‚ÄúFM‚Äù)","title":"Functional Depth Functions","text":"Fraiman-Muniz depth integrates univariate depths across domain. time point, computes proportion curves given curve, averages across time. FM depth can scaled [0, 1] using scale parameter:","code":"depths_fm <- depth(fd, method = \"FM\")  # Show depths (outliers should have lower depth) data.frame(   curve = 1:5,   depth = round(depths_fm[1:5], 4),   note = c(\"magnitude outlier\", \"shape outlier\", rep(\"normal\", 3)) ) #>   curve  depth              note #> 1     1 0.0000 magnitude outlier #> 2     2 0.1113     shape outlier #> 3     3 0.5233            normal #> 4     4 0.5707            normal #> 5     5 0.5407            normal depths_fm_scaled <- depth(fd, method = \"FM\", scale = TRUE) range(depths_fm_scaled) #> [1] 0.0000000 0.5813333"},{"path":"https://sipemu.github.io/fdars/articles/depth-functions.html","id":"modal-depth-method-mode","dir":"Articles","previous_headings":"Available Depth Functions","what":"Modal Depth (method = ‚Äúmode‚Äù)","title":"Functional Depth Functions","text":"Modal depth uses kernel density estimation function space. Curves high-density regions high depth.","code":"depths_mode <- depth(fd, method = \"mode\") head(depths_mode) #> [1] 0.03335153 0.09401245 0.83156568 0.84229565 0.83229521 0.82640249"},{"path":"https://sipemu.github.io/fdars/articles/depth-functions.html","id":"random-projection-depth-method-rp","dir":"Articles","previous_headings":"Available Depth Functions","what":"Random Projection Depth (method = ‚ÄúRP‚Äù)","title":"Functional Depth Functions","text":"Projects curves onto random directions computes univariate depths projections. robust local variations.","code":"depths_rp <- depth(fd, method = \"RP\", nproj = 50) head(depths_rp) #> [1] 0.07354839 0.08967742 0.25354839 0.31225806 0.26064516 0.25096774"},{"path":"https://sipemu.github.io/fdars/articles/depth-functions.html","id":"random-tukey-depth-method-rt","dir":"Articles","previous_headings":"Available Depth Functions","what":"Random Tukey Depth (method = ‚ÄúRT‚Äù)","title":"Functional Depth Functions","text":"Takes minimum depth across random projections, similar Tukey‚Äôs halfspace depth. robust outliers.","code":"depths_rt <- depth(fd, method = \"RT\", nproj = 50) head(depths_rt) #> [1] 0.03225806 0.03225806 0.06451613 0.06451613 0.03225806 0.06451613"},{"path":"https://sipemu.github.io/fdars/articles/depth-functions.html","id":"functional-spatial-depth-method-fsd","dir":"Articles","previous_headings":"Available Depth Functions","what":"Functional Spatial Depth (method = ‚ÄúFSD‚Äù)","title":"Functional Depth Functions","text":"Based unit vectors pointing curve others. Measures centrality geometric sense.","code":"depths_fsd <- depth(fd, method = \"FSD\") head(depths_fsd) #> [1] 0.03927198 0.06164440 0.34346531 0.39240477 0.33894657 0.32391302"},{"path":"https://sipemu.github.io/fdars/articles/depth-functions.html","id":"kernel-functional-spatial-depth-method-kfsd","dir":"Articles","previous_headings":"Available Depth Functions","what":"Kernel Functional Spatial Depth (method = ‚ÄúKFSD‚Äù)","title":"Functional Depth Functions","text":"Smoothed version FSD using Gaussian kernel. bandwidth h controls smoothing.","code":"depths_kfsd <- depth(fd, method = \"KFSD\", h = 0.15) head(depths_kfsd) #> [1] 0.2646598 0.2646598 0.3086986 0.3194105 0.3089607 0.3032314"},{"path":"https://sipemu.github.io/fdars/articles/depth-functions.html","id":"random-projection-depth-with-derivatives-method-rpd","dir":"Articles","previous_headings":"Available Depth Functions","what":"Random Projection Depth with Derivatives (method = ‚ÄúRPD‚Äù)","title":"Functional Depth Functions","text":"Incorporates derivative information, making sensitive shape changes addition magnitude.","code":"depths_rpd <- depth(fd, method = \"RPD\", nproj = 50) head(depths_rpd) #> [1] 0.11200000 0.09733333 0.21866667 0.21266667 0.19133333 0.19200000"},{"path":"https://sipemu.github.io/fdars/articles/depth-functions.html","id":"comparing-depth-functions","dir":"Articles","previous_headings":"","what":"Comparing Depth Functions","title":"Functional Depth Functions","text":"Different depth functions different properties may rank curves differently: depth functions correctly identify curves 1 2 low depth.","code":"# Compute all depths using unified depth() function all_depths <- data.frame(   FM = depth(fd, method = \"FM\"),   mode = depth(fd, method = \"mode\"),   RP = depth(fd, method = \"RP\", nproj = 50),   RT = depth(fd, method = \"RT\", nproj = 50),   FSD = depth(fd, method = \"FSD\") )  # Correlation between depth functions round(cor(all_depths), 2) #>        FM mode   RP   RT  FSD #> FM   1.00 0.98 0.94 0.22 0.98 #> mode 0.98 1.00 0.93 0.18 0.97 #> RP   0.94 0.93 1.00 0.18 0.95 #> RT   0.22 0.18 0.18 1.00 0.21 #> FSD  0.98 0.97 0.95 0.21 1.00 # Which curves are identified as outliers (lowest depth)? outlier_ranks <- apply(all_depths, 2, function(d) order(d)[1:3]) outlier_ranks #>      FM mode RP RT FSD #> [1,]  1    1  1  1   1 #> [2,]  2    2  2  2   2 #> [3,] 10   10 27  3  10"},{"path":[]},{"path":"https://sipemu.github.io/fdars/articles/depth-functions.html","id":"functional-median","dir":"Articles","previous_headings":"Depth-Based Statistics","what":"Functional Median","title":"Functional Depth Functions","text":"median curve maximum depth:","code":"# Using different depth functions via method parameter med_fm <- median(fd, method = \"FM\") med_mode <- median(fd, method = \"mode\") med_rp <- median(fd, method = \"RP\", nproj = 50)  # The median is one of the original curves which.max(depth(fd, method = \"FM\")) #> [1] 13"},{"path":"https://sipemu.github.io/fdars/articles/depth-functions.html","id":"trimmed-mean","dir":"Articles","previous_headings":"Depth-Based Statistics","what":"Trimmed Mean","title":"Functional Depth Functions","text":"Remove proportion curves lowest depth, compute mean:","code":"# 10% trimmed mean using different depth methods trim_fm <- trimmed(fd, trim = 0.1, method = \"FM\") trim_mode <- trimmed(fd, trim = 0.1, method = \"mode\")  # Compare trimmed mean to regular mean mean_curve <- mean(fd) # Visualize: trimmed mean is more robust to outliers df_compare <- data.frame(   t = rep(t_grid, 2),   value = c(mean_curve$data[1, ], trim_fm$data[1, ]),   type = rep(c(\"Mean\", \"Trimmed Mean (FM)\"), each = m) )  library(ggplot2) ggplot(df_compare, aes(x = t, y = value, color = type)) +   geom_line(linewidth = 1.2) +   labs(title = \"Mean vs Trimmed Mean\",        x = \"t\", y = \"X(t)\", color = \"\") +   theme_minimal()"},{"path":"https://sipemu.github.io/fdars/articles/depth-functions.html","id":"functional-variance-and-trimmed-variance","dir":"Articles","previous_headings":"Depth-Based Statistics","what":"Functional Variance and Trimmed Variance","title":"Functional Depth Functions","text":"","code":"# Regular variance var_fd <- var(fd)  # Trimmed variance (more robust) trimvar_fd <- trimvar(fd, trim = 0.1, method = \"FM\")"},{"path":[]},{"path":"https://sipemu.github.io/fdars/articles/depth-functions.html","id":"performance","dir":"Articles","previous_headings":"","what":"Performance","title":"Functional Depth Functions","text":"depth computations use parallel Rust backend:","code":"# Large dataset benchmark X_large <- matrix(rnorm(500 * 200), 500, 200) fd_large <- fdata(X_large)  system.time(depth(fd_large, method = \"FM\")) #>    user  system elapsed #>   0.032   0.000   0.032  system.time(depth(fd_large, method = \"RP\", nproj = 100)) #>    user  system elapsed #>   0.089   0.000   0.089"},{"path":"https://sipemu.github.io/fdars/articles/depth-functions.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Functional Depth Functions","text":"Fraiman, R. Muniz, G. (2001). Trimmed means functional data. Test, 10(2), 419-440. Cuevas, ., Febrero, M., Fraiman, R. (2007). Robust estimation classification functional data via projection-based depth notions. Computational Statistics, 22(3), 481-496. L√≥pez-Pintado, S. Romo, J. (2009). concept depth functional data. Journal American Statistical Association, 104(486), 718-734.","code":""},{"path":"https://sipemu.github.io/fdars/articles/distance-metrics.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Distance Metrics and Semimetrics","text":"Distance measures fundamental many FDA methods including clustering, k-nearest neighbors regression, outlier detection. fdars provides true metrics (satisfying triangle inequality) semimetrics (may ). metric dd space ùí≥\\mathcal{X} satisfies: d(f,g)‚â•0d(f, g) \\geq 0 (non-negativity) d(f,g)=0‚áîf=gd(f, g) = 0 \\Leftrightarrow f = g (identity indiscernibles) d(f,g)=d(g,f)d(f, g) = d(g, f) (symmetry) d(f,h)‚â§d(f,g)+d(g,h)d(f, h) \\leq d(f, g) + d(g, h) (triangle inequality) semimetric satisfies conditions 1-3.","code":"library(fdars) #>  #> Attaching package: 'fdars' #> The following objects are masked from 'package:stats': #>  #>     cov, deriv, median, sd, var #> The following object is masked from 'package:base': #>  #>     norm library(ggplot2) theme_set(theme_minimal())  # Create example data with different curve types set.seed(42) m <- 100 t_grid <- seq(0, 1, length.out = m)  # Four types of curves curve1 <- sin(2 * pi * t_grid)                    # Sine curve2 <- sin(2 * pi * t_grid + 0.5)              # Phase-shifted sine curve3 <- cos(2 * pi * t_grid)                    # Cosine curve4 <- sin(4 * pi * t_grid)                    # Higher frequency  X <- rbind(curve1, curve2, curve3, curve4) fd <- fdata(X, argvals = t_grid,             names = list(main = \"Four Curve Types\")) plot(fd)"},{"path":[]},{"path":"https://sipemu.github.io/fdars/articles/distance-metrics.html","id":"lp-distance-metric-lp","dir":"Articles","previous_headings":"True Metrics","what":"Lp Distance (metric.lp)","title":"Distance Metrics and Semimetrics","text":"LpL^p distance common choice functional data. computes integrated LpL^p norm difference two functions: dp(f,g)=(‚à´ùíØ|f(t)‚àíg(t)|pdt)1/pd_p(f, g) = \\left( \\int_{\\mathcal{T}} |f(t) - g(t)|^p \\, dt \\right)^{1/p} discrete observations, approximated using numerical integration (Simpson‚Äôs rule): dp(f,g)‚âà(‚àëj=1mwj|f(tj)‚àíg(tj)|p)1/pd_p(f, g) \\approx \\left( \\sum_{j=1}^{m} w_j |f(t_j) - g(t_j)|^p \\right)^{1/p} wjw_j quadrature weights. Special cases: p=2p = 2 (L2/Euclidean): common, corresponds standard functional norm. Sensitive vertical differences. p=1p = 1 (L1/Manhattan): robust outliers L2. p=‚àûp = \\infty (L-infinity/Chebyshev): Maximum absolute difference, d‚àû(f,g)=maxt|f(t)‚àíg(t)|d_\\infty(f, g) = \\max_t |f(t) - g(t)|.","code":"# L2 (Euclidean) distance - default dist_l2 <- metric.lp(fd) print(round(as.matrix(dist_l2), 3)) #>        curve1 curve2 curve3 curve4 #> curve1   0.00  0.350  1.000      1 #> curve2   0.35  0.000  0.722      1 #> curve3   1.00  0.722  0.000      1 #> curve4   1.00  1.000  1.000      0  # L1 (Manhattan) distance dist_l1 <- metric.lp(fd, lp = 1)  # L-infinity (maximum) distance dist_linf <- metric.lp(fd, lp = Inf)"},{"path":"https://sipemu.github.io/fdars/articles/distance-metrics.html","id":"weighted-lp-distance","dir":"Articles","previous_headings":"True Metrics","what":"Weighted Lp Distance","title":"Distance Metrics and Semimetrics","text":"Apply different weights different parts domain: dp,w(f,g)=(‚à´ùíØw(t)|f(t)‚àíg(t)|pdt)1/pd_{p,w}(f, g) = \\left( \\int_{\\mathcal{T}} w(t) |f(t) - g(t)|^p \\, dt \\right)^{1/p} useful certain parts domain important others.","code":"# Weight emphasizing the middle of the domain w <- dnorm(t_grid, mean = 0.5, sd = 0.2) w <- w / sum(w) * length(w)  # Normalize  dist_weighted <- metric.lp(fd, lp = 2, w = w)"},{"path":"https://sipemu.github.io/fdars/articles/distance-metrics.html","id":"hausdorff-distance-metric-hausdorff","dir":"Articles","previous_headings":"True Metrics","what":"Hausdorff Distance (metric.hausdorff)","title":"Distance Metrics and Semimetrics","text":"Hausdorff distance treats curves sets points (t,f(t))(t, f(t)) 2D space computes maximum minimum distances: dH(f,g)=max{supt‚ààùíØinfs‚ààùíØ‚à•Pf(t)‚àíPg(s)‚à•,sups‚ààùíØinft‚ààùíØ‚à•Pf(t)‚àíPg(s)‚à•}d_H(f, g) = \\max\\left\\{ \\sup_{t \\\\mathcal{T}} \\inf_{s \\\\mathcal{T}} \\|P_f(t) - P_g(s)\\|, \\sup_{s \\\\mathcal{T}} \\inf_{t \\\\mathcal{T}} \\|P_f(t) - P_g(s)\\| \\right\\} Pf(t)=(t,f(t))P_f(t) = (t, f(t)) point graph ff time tt. Hausdorff distance useful : Curves may cross timing features less important shape Comparing curves different supports","code":"dist_haus <- metric.hausdorff(fd) print(round(as.matrix(dist_haus), 3)) #>        curve1 curve2 curve3 curve4 #> curve1  0.000  0.479  0.678  0.328 #> curve2  0.479  0.000  0.521  0.416 #> curve3  0.678  0.521  0.000  0.352 #> curve4  0.328  0.416  0.352  0.000"},{"path":"https://sipemu.github.io/fdars/articles/distance-metrics.html","id":"dynamic-time-warping-metric-dtw","dir":"Articles","previous_headings":"True Metrics","what":"Dynamic Time Warping (metric.DTW)","title":"Distance Metrics and Semimetrics","text":"DTW allows non-linear alignment curves computing distance. finds optimal warping path œÄ\\pi minimizes: dDTW(f,g)=minœÄ‚àë(,j)‚ààœÄ|f(ti)‚àíg(tj)|2d_{DTW}(f, g) = \\min_{\\pi} \\sqrt{\\sum_{(,j) \\\\pi} |f(t_i) - g(t_j)|^2} subject boundary conditions, monotonicity, continuity constraints. Sakoe-Chiba band constraint limits warping |‚àíj|‚â§w|- j| \\leq w, preventing excessive distortion: dDTWSC(f,g)=minœÄ:|‚àíj|‚â§w‚àë(,j)‚ààœÄ|f(ti)‚àíg(tj)|2d_{DTW}^{SC}(f, g) = \\min_{\\pi: |-j| \\leq w} \\sqrt{\\sum_{(,j) \\\\pi} |f(t_i) - g(t_j)|^2} DTW particularly effective : Phase-shifted signals Time series varying speed Comparing signals local time distortions Notice DTW gives smaller distance original sine phase-shifted sine compared L2, can align : DTW band constraint:","code":"dist_dtw <- metric.DTW(fd) print(round(as.matrix(dist_dtw), 3)) #>        curve1 curve2 curve3 curve4 #> curve1  0.000  1.452 18.185 24.844 #> curve2  1.452  0.000  3.488 25.980 #> curve3 18.185  3.488  0.000 40.825 #> curve4 24.844 25.980 40.825  0.000 # Compare L2 vs DTW for phase-shifted curves cat(\"L2 distance (sine vs phase-shifted):\", round(as.matrix(dist_l2)[1, 2], 3), \"\\n\") #> L2 distance (sine vs phase-shifted): 0.35 cat(\"DTW distance (sine vs phase-shifted):\", round(as.matrix(dist_dtw)[1, 2], 3), \"\\n\") #> DTW distance (sine vs phase-shifted): 1.452 # Restrict warping to 10% of the series length dist_dtw_band <- metric.DTW(fd, w = round(m * 0.1))"},{"path":"https://sipemu.github.io/fdars/articles/distance-metrics.html","id":"kullback-leibler-divergence-metric-kl","dir":"Articles","previous_headings":"True Metrics","what":"Kullback-Leibler Divergence (metric.kl)","title":"Distance Metrics and Semimetrics","text":"symmetric Kullback-Leibler divergence treats normalized curves probability density functions: dKL(f,g)=12[‚à´f(t)logf(t)g(t)dt+‚à´g(t)logg(t)f(t)dt]d_{KL}(f, g) = \\frac{1}{2}\\left[ \\int f(t) \\log\\frac{f(t)}{g(t)} \\, dt + \\int g(t) \\log\\frac{g(t)}{f(t)} \\, dt \\right] computing, curves shifted non-negative normalized integrate 1: fÃÉ(t)=f(t)‚àíminsf(s)+œµ‚à´[f(s)‚àíminsf(s)+œµ]ds\\tilde{f}(t) = \\frac{f(t) - \\min_s f(s) + \\epsilon}{\\int [f(s) - \\min_s f(s) + \\epsilon] \\, ds} metric useful : Comparing density-like functions Distribution comparison Information-theoretic analysis","code":"# Shift curves to be positive for KL X_pos <- X - min(X) + 0.1 fd_pos <- fdata(X_pos, argvals = t_grid)  dist_kl <- metric.kl(fd_pos) print(round(as.matrix(dist_kl), 3)) #>        curve1 curve2 curve3 curve4 #> curve1  0.000  0.139  1.208  1.187 #> curve2  0.139  0.000  0.630  1.426 #> curve3  1.208  0.630  0.000  1.156 #> curve4  1.187  1.426  1.156  0.000"},{"path":"https://sipemu.github.io/fdars/articles/distance-metrics.html","id":"semimetrics","dir":"Articles","previous_headings":"","what":"Semimetrics","title":"Distance Metrics and Semimetrics","text":"Semimetrics may satisfy triangle inequality can appropriate certain applications provide computational advantages.","code":""},{"path":"https://sipemu.github.io/fdars/articles/distance-metrics.html","id":"pca-based-semimetric-semimetric-pca","dir":"Articles","previous_headings":"Semimetrics","what":"PCA-Based Semimetric (semimetric.pca)","title":"Distance Metrics and Semimetrics","text":"Projects curves onto first qq principal components computes Euclidean distance reduced space: dPCA(f,g)=‚àëk=1q(Œækf‚àíŒækg)2d_{PCA}(f, g) = \\sqrt{\\sum_{k=1}^{q} (\\xi_k^f - \\xi_k^g)^2} Œækf=‚ü®f‚àíf‚Äæ,œïk‚ü©\\xi_k^f = \\langle f - \\bar{f}, \\phi_k \\rangle kk-th principal component score ff, œïk\\phi_k eigenfunctions functional PCA. semimetric useful : Dimension reduction distance computation Noise reduction (low-rank approximation) Computational efficiency many evaluation points","code":"# Distance using first 3 PCs dist_pca <- semimetric.pca(fd, ncomp = 3) print(round(as.matrix(dist_pca), 3)) #>        [,1]  [,2]   [,3]   [,4] #> [1,]  0.000 3.514 10.000  9.950 #> [2,]  3.514 0.000  7.198  9.961 #> [3,] 10.000 7.198  0.000 10.000 #> [4,]  9.950 9.961 10.000  0.000"},{"path":"https://sipemu.github.io/fdars/articles/distance-metrics.html","id":"derivative-based-semimetric-semimetric-deriv","dir":"Articles","previous_headings":"Semimetrics","what":"Derivative-Based Semimetric (semimetric.deriv)","title":"Distance Metrics and Semimetrics","text":"Computes LpL^p distance based rr-th derivative curves: dderiv(r)(f,g)=(‚à´ùíØ|f(r)(t)‚àíg(r)(t)|pdt)1/pd_{deriv}^{(r)}(f, g) = \\left( \\int_{\\mathcal{T}} |f^{(r)}(t) - g^{(r)}(t)|^p \\, dt \\right)^{1/p} f(r)f^{(r)} denotes rr-th derivative ff. semimetric focuses shape dynamics curves rather absolute values. particularly useful : Comparing rate change (first derivative) Analyzing curvature (second derivative) Functions measured different baselines","code":"# First derivative (velocity) dist_deriv1 <- semimetric.deriv(fd, nderiv = 1)  # Second derivative (acceleration/curvature) dist_deriv2 <- semimetric.deriv(fd, nderiv = 2)  cat(\"First derivative distances:\\n\") #> First derivative distances: print(round(as.matrix(dist_deriv1), 3)) #>       [,1]  [,2]  [,3]  [,4] #> [1,] 0.000 2.197 6.279 9.912 #> [2,] 2.197 0.000 4.530 9.912 #> [3,] 6.279 4.530 0.000 9.912 #> [4,] 9.912 9.912 9.912 0.000"},{"path":"https://sipemu.github.io/fdars/articles/distance-metrics.html","id":"basis-semimetric-semimetric-basis","dir":"Articles","previous_headings":"Semimetrics","what":"Basis Semimetric (semimetric.basis)","title":"Distance Metrics and Semimetrics","text":"Projects curves onto basis (B-spline Fourier) computes Euclidean distance coefficient vectors: dbasis(f,g)=‚à•cf‚àícg‚à•2=‚àëk=1K(ckf‚àíckg)2d_{basis}(f, g) = \\|c^f - c^g\\|_2 = \\sqrt{\\sum_{k=1}^{K} (c_k^f - c_k^g)^2} cf=(c1f,‚Ä¶,cKf)c^f = (c_1^f, \\ldots, c_K^f) basis coefficients f(t)‚âà‚àëk=1KckfBk(t)f(t) \\approx \\sum_{k=1}^{K} c_k^f B_k(t). B-splines: Local support provides good approximation local features. Fourier basis: Global support captures periodic patterns efficiently.","code":"# B-spline basis (local features) dist_bspline <- semimetric.basis(fd, nbasis = 15, basis = \"bspline\")  # Fourier basis (periodic patterns) dist_fourier <- semimetric.basis(fd, nbasis = 11, basis = \"fourier\")  cat(\"B-spline basis distances:\\n\") #> B-spline basis distances: print(round(as.matrix(dist_bspline), 3)) #>       [,1]  [,2]  [,3]  [,4] #> [1,] 0.000 1.509 4.015 3.913 #> [2,] 1.509 0.000 2.771 3.999 #> [3,] 4.015 2.771 0.000 4.289 #> [4,] 3.913 3.999 4.289 0.000"},{"path":"https://sipemu.github.io/fdars/articles/distance-metrics.html","id":"fourier-semimetric-semimetric-fourier","dir":"Articles","previous_headings":"Semimetrics","what":"Fourier Semimetric (semimetric.fourier)","title":"Distance Metrics and Semimetrics","text":"Uses Fast Fourier Transform (FFT) compute Fourier coefficients measures distance based first KK frequency components: dFFT(f,g)=‚àëk=0K|fÃÇk‚àígÃÇk|2d_{FFT}(f, g) = \\sqrt{\\sum_{k=0}^{K} |\\hat{f}_k - \\hat{g}_k|^2} fÃÇk\\hat{f}_k kk-th Fourier coefficient computed via FFT. computationally efficient large datasets particularly useful periodic frequency-domain analysis.","code":"dist_fft <- semimetric.fourier(fd, nfreq = 5) cat(\"Fourier (FFT) distances:\\n\") #> Fourier (FFT) distances: print(round(as.matrix(dist_fft), 3)) #>        curve1 curve2 curve3 curve4 #> curve1  0.000  0.005  0.012  0.694 #> curve2  0.005  0.000  0.008  0.695 #> curve3  0.012  0.008  0.000  0.700 #> curve4  0.694  0.695  0.700  0.000"},{"path":"https://sipemu.github.io/fdars/articles/distance-metrics.html","id":"horizontal-shift-semimetric-semimetric-hshift","dir":"Articles","previous_headings":"Semimetrics","what":"Horizontal Shift Semimetric (semimetric.hshift)","title":"Distance Metrics and Semimetrics","text":"Finds optimal horizontal shift computing L2L^2 distance: dhshift(f,g)=min|h|‚â§hmax(‚à´ùíØ|f(t)‚àíg(t+h)|2dt)1/2d_{hshift}(f, g) = \\min_{|h| \\leq h_{max}} \\left( \\int_{\\mathcal{T}} |f(t) - g(t+h)|^2 \\, dt \\right)^{1/2} hh shift discrete time units hmaxh_{max} maximum allowed shift. semimetric simpler DTW (horizontal shifts, warping) can effective : Phase-shifted periodic signals ECG physiological signals timing variations Comparing curves horizontal alignment meaningful","code":"dist_hshift <- semimetric.hshift(fd) cat(\"Horizontal shift distances:\\n\") #> Horizontal shift distances: print(round(as.matrix(dist_hshift), 3)) #>        curve1 curve2 curve3 curve4 #> curve1  0.000  0.005  0.010  0.733 #> curve2  0.005  0.000  0.005  0.629 #> curve3  0.010  0.005  0.000  0.718 #> curve4  0.733  0.629  0.718  0.000"},{"path":"https://sipemu.github.io/fdars/articles/distance-metrics.html","id":"unified-interface","dir":"Articles","previous_headings":"","what":"Unified Interface","title":"Distance Metrics and Semimetrics","text":"Use metric() unified interface distance functions:","code":"# Different methods via single function d1 <- metric(fd, method = \"lp\", lp = 2) d2 <- metric(fd, method = \"dtw\") d3 <- metric(fd, method = \"hausdorff\") d4 <- metric(fd, method = \"pca\", ncomp = 2)"},{"path":"https://sipemu.github.io/fdars/articles/distance-metrics.html","id":"comparing-distance-measures","dir":"Articles","previous_headings":"","what":"Comparing Distance Measures","title":"Distance Metrics and Semimetrics","text":"Different distance measures capture different aspects curve similarity:","code":"# Create comparison data dists <- list(   L2 = as.vector(as.matrix(dist_l2)),   L1 = as.vector(as.matrix(dist_l1)),   DTW = as.vector(as.matrix(dist_dtw)),   Hausdorff = as.vector(as.matrix(dist_haus)) )  # Correlation between distance measures dist_mat <- do.call(cbind, dists) cat(\"Correlation between distance measures:\\n\") #> Correlation between distance measures: print(round(cor(dist_mat), 2)) #>             L2   L1  DTW Hausdorff #> L2        1.00 0.99 0.82      0.74 #> L1        0.99 1.00 0.77      0.79 #> DTW       0.82 0.77 1.00      0.32 #> Hausdorff 0.74 0.79 0.32      1.00"},{"path":"https://sipemu.github.io/fdars/articles/distance-metrics.html","id":"distance-matrices-for-larger-samples","dir":"Articles","previous_headings":"","what":"Distance Matrices for Larger Samples","title":"Distance Metrics and Semimetrics","text":"","code":"# Generate larger sample set.seed(123) n <- 50 X_large <- matrix(0, n, m) for (i in 1:n) {   phase <- runif(1, 0, 2*pi)   freq <- sample(1:3, 1)   X_large[i, ] <- sin(freq * pi * t_grid + phase) + rnorm(m, sd = 0.1) } fd_large <- fdata(X_large, argvals = t_grid)  # Compute distance matrix dist_matrix <- metric.lp(fd_large)  # Visualize as heatmap using ggplot2 dist_df <- expand.grid(Curve1 = 1:n, Curve2 = 1:n) dist_df$Distance <- as.vector(as.matrix(dist_matrix))  ggplot(dist_df, aes(x = Curve1, y = Curve2, fill = Distance)) +   geom_tile() +   scale_fill_viridis_c(option = \"magma\") +   coord_equal() +   labs(x = \"Curve\", y = \"Curve\", title = \"L2 Distance Matrix\") +   theme_minimal()"},{"path":"https://sipemu.github.io/fdars/articles/distance-metrics.html","id":"metric-properties-summary","dir":"Articles","previous_headings":"","what":"Metric Properties Summary","title":"Distance Metrics and Semimetrics","text":"* DTW satisfies triangle inequality using warping path ** satisfy triangle inequality reduced/transformed space","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/articles/distance-metrics.html","id":"performance","dir":"Articles","previous_headings":"","what":"Performance","title":"Distance Metrics and Semimetrics","text":"Distance computations parallelized Rust:","code":"# Benchmark for 500 curves X_bench <- matrix(rnorm(500 * 200), 500, 200) fd_bench <- fdata(X_bench)  system.time(metric.lp(fd_bench)) #>    user  system elapsed #>   0.089   0.000   0.045  system.time(metric.DTW(fd_bench)) #>    user  system elapsed #>   1.234   0.000   0.312"},{"path":"https://sipemu.github.io/fdars/articles/distance-metrics.html","id":"using-distances-in-other-methods","dir":"Articles","previous_headings":"","what":"Using Distances in Other Methods","title":"Distance Metrics and Semimetrics","text":"Distance functions can passed clustering regression:","code":"# K-means with L1 distance km_l1 <- cluster.kmeans(fd_large, ncl = 3, metric = \"L1\", seed = 42)  # K-means with custom metric function km_dtw <- cluster.kmeans(fd_large, ncl = 3, metric = metric.DTW, seed = 42)  # Nonparametric regression uses distances internally y <- rnorm(n) fit_np <- fregre.np(fd_large, y, metric = metric.lp)"},{"path":"https://sipemu.github.io/fdars/articles/distance-metrics.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Distance Metrics and Semimetrics","text":"Berndt, D.J. Clifford, J. (1994). Using Dynamic Time Warping Find Patterns Time Series. KDD Workshop, 359-370. Ferraty, F. Vieu, P. (2006). Nonparametric Functional Data Analysis. Springer. Ramsay, J.O. Silverman, B.W. (2005). Functional Data Analysis. Springer, 2nd edition. Sakoe, H. Chiba, S. (1978). Dynamic programming algorithm optimization spoken word recognition. IEEE Transactions Acoustics, Speech, Signal Processing, 26(1), 43-49.","code":""},{"path":"https://sipemu.github.io/fdars/articles/fpca.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Functional Principal Component Analysis (FPCA)","text":"Functional Principal Component Analysis (FPCA) cornerstone technique functional data analysis. extends classical PCA infinite-dimensional function spaces, providing powerful tool dimension reduction, visualization, feature extraction functional data.","code":"library(fdars) #>  #> Attaching package: 'fdars' #> The following objects are masked from 'package:stats': #>  #>     cov, deriv, median, sd, var #> The following object is masked from 'package:base': #>  #>     norm library(ggplot2) theme_set(theme_minimal()) set.seed(42)"},{"path":"https://sipemu.github.io/fdars/articles/fpca.html","id":"why-fpca","dir":"Articles","previous_headings":"","what":"Why FPCA?","title":"Functional Principal Component Analysis (FPCA)","text":"working functional data, face several challenges: High dimensionality: curve observed many points Infinite-dimensional nature: Curves live function spaces Correlation structure: Points curve highly correlated Noise: Observations contain measurement error FPCA addresses challenges finding principal modes variation data‚Äîorthogonal functions capture curves differ .","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/articles/fpca.html","id":"the-karhunen-lo√®ve-expansion","dir":"Articles","previous_headings":"Mathematical Background","what":"The Karhunen-Lo√®ve Expansion","title":"Functional Principal Component Analysis (FPCA)","text":"square-integrable random function X(t)X(t) can represented : X(t)=Œº(t)+‚àëk=1‚àûŒækœïk(t)X(t) = \\mu(t) + \\sum_{k=1}^{\\infty} \\xi_k \\phi_k(t) : Œº(t)\\mu(t) mean function œïk(t)\\phi_k(t) eigenfunctions (functional principal components) Œæk\\xi_k scores (random coefficients) eigenfunctions satisfy: ‚à´C(s,t)œïk(s)ds=Œªkœïk(t)\\int C(s, t) \\phi_k(s) \\, ds = \\lambda_k \\phi_k(t) C(s,t)=Cov(X(s),X(t))C(s, t) = \\text{Cov}(X(s), X(t)) covariance function Œªk\\lambda_k eigenvalues (variances explained component).","code":""},{"path":"https://sipemu.github.io/fdars/articles/fpca.html","id":"key-properties","dir":"Articles","previous_headings":"Mathematical Background","what":"Key Properties","title":"Functional Principal Component Analysis (FPCA)","text":"Orthonormality: ‚à´œïj(t)œïk(t)dt=Œ¥jk\\int \\phi_j(t) \\phi_k(t) \\, dt = \\delta_{jk} Uncorrelated scores: Cov(Œæj,Œæk)=ŒªjŒ¥jk\\text{Cov}(\\xi_j, \\xi_k) = \\lambda_j \\delta_{jk} Optimal reconstruction: FPCA minimizes integrated squared error fixed number components Variance ordering: Œª1‚â•Œª2‚â•‚ãØ‚â•0\\lambda_1 \\geq \\lambda_2 \\geq \\cdots \\geq 0","code":""},{"path":"https://sipemu.github.io/fdars/articles/fpca.html","id":"example-growth-curves","dir":"Articles","previous_headings":"","what":"Example: Growth Curves","title":"Functional Principal Component Analysis (FPCA)","text":"Let‚Äôs demonstrate FPCA simulated growth data showing different growth patterns.","code":"# Simulate growth curves with two main modes of variation n <- 50 m <- 100 t <- seq(0, 18, length.out = m)  # Age 0-18 years  # Base growth pattern (logistic-like) base_growth <- function(t) 50 + 130 / (1 + exp(-0.5 * (t - 10)))  # Generate curves with: # - Overall height variation (PC1: taller/shorter) # - Growth timing variation (PC2: earlier/later maturation) X <- matrix(0, n, m) height_effect <- rnorm(n, sd = 10)      # Individual height differences timing_effect <- rnorm(n, sd = 1.5)     # Individual timing differences  for (i in 1:n) {   shifted_t <- t - timing_effect[i]   X[i, ] <- base_growth(shifted_t) + height_effect[i] + rnorm(m, sd = 2) }  fd <- fdata(X, argvals = t) plot(fd) +   labs(x = \"Age (years)\", y = \"Height (cm)\", title = \"Simulated Growth Curves\")"},{"path":"https://sipemu.github.io/fdars/articles/fpca.html","id":"performing-fpca","dir":"Articles","previous_headings":"","what":"Performing FPCA","title":"Functional Principal Component Analysis (FPCA)","text":"fdata2pc() function computes functional principal components: output shows: Singular values: Related importance component Variance explained: Percentage total variance captured PC Cumulative variance: Running total‚Äîoften aim 90-95%","code":"# Extract first 4 principal components fpca <- fdata2pc(fd, ncomp = 4) print(fpca) #> Functional Principal Component Analysis #> ======================================== #> Number of observations: 50  #> Number of components: 4  #>  #> Variance explained: #>   PC1: 92.4% (cumulative: 92.4%) #>   PC2: 5.9% (cumulative: 98.3%) #>   PC3: 1.6% (cumulative: 99.9%) #>   PC4: 0.1% (cumulative: 100.0%)"},{"path":[]},{"path":"https://sipemu.github.io/fdars/articles/fpca.html","id":"principal-component-functions","dir":"Articles","previous_headings":"Visualizing FPCA Results","what":"Principal Component Functions","title":"Functional Principal Component Analysis (FPCA)","text":"plot() method type = \"components\" shows PC affects mean curve:  panel shows: Black line: Mean function Œº(t)\\mu(t) Blue line: Mean + perturbation PC direction Red line: Mean - perturbation PC direction Interpretation: PC1: Overall height differences (taller vs shorter individuals) PC2: Growth timing (earlier vs later maturation) PC3: subtle shape variations","code":"plot(fpca, type = \"components\", ncomp = 3, multiple = 2)"},{"path":"https://sipemu.github.io/fdars/articles/fpca.html","id":"eigenfunctions","dir":"Articles","previous_headings":"Visualizing FPCA Results","what":"Eigenfunctions","title":"Functional Principal Component Analysis (FPCA)","text":"eigenfunctions show shape mode variation:","code":"# Plot the first 3 eigenfunctions df_eigen <- data.frame(   t = rep(t, 3),   loading = c(fpca$rotation$data[1, ], fpca$rotation$data[2, ], fpca$rotation$data[3, ]),   PC = factor(rep(paste0(\"PC\", 1:3), each = m)) )  ggplot(df_eigen, aes(x = t, y = loading, color = PC)) +   geom_line(linewidth = 1) +   geom_hline(yintercept = 0, linetype = \"dashed\", alpha = 0.5) +   scale_color_brewer(palette = \"Set1\") +   labs(x = \"Age (years)\", y = \"Loading\",        title = \"Principal Component Eigenfunctions\")"},{"path":"https://sipemu.github.io/fdars/articles/fpca.html","id":"scree-plot","dir":"Articles","previous_headings":"Visualizing FPCA Results","what":"Scree Plot","title":"Functional Principal Component Analysis (FPCA)","text":"variance plot shows much component contributes:  scree plot helps decide many components retain. Common criteria: Retain components explaining 90-95% cumulative variance Look ‚Äúelbow‚Äù explained variance drops sharply Use cross-validation prediction tasks","code":"plot(fpca, type = \"variance\")"},{"path":"https://sipemu.github.io/fdars/articles/fpca.html","id":"score-plot","dir":"Articles","previous_headings":"Visualizing FPCA Results","what":"Score Plot","title":"Functional Principal Component Analysis (FPCA)","text":"scores show observation falls PC space:  Curves similar scores similar shapes. Outliers appear far center.","code":"plot(fpca, type = \"scores\")"},{"path":[]},{"path":"https://sipemu.github.io/fdars/articles/fpca.html","id":"dimension-reduction","dir":"Articles","previous_headings":"Benefits of FPCA","what":"1. Dimension Reduction","title":"Functional Principal Component Analysis (FPCA)","text":"FPCA reduces infinite-dimensional curves scores:","code":"# Original data: 50 curves x 100 points = 5000 values cat(\"Original dimensions:\", nrow(fd$data), \"x\", ncol(fd$data), \"\\n\") #> Original dimensions: 50 x 100  # After FPCA: 50 curves x 4 scores = 200 values cat(\"Reduced dimensions:\", nrow(fpca$x), \"x\", ncol(fpca$x), \"\\n\") #> Reduced dimensions: 50 x 4  # Compression ratio cat(\"Compression:\", round(100 * (1 - prod(dim(fpca$x)) / prod(dim(fd$data))), 1), \"%\\n\") #> Compression: 96 %"},{"path":"https://sipemu.github.io/fdars/articles/fpca.html","id":"denoising","dir":"Articles","previous_headings":"Benefits of FPCA","what":"2. Denoising","title":"Functional Principal Component Analysis (FPCA)","text":"Reconstructing curves PCs removes noise:","code":"# Reconstruct using only first 2 PCs scores_2pc <- fpca$x[, 1:2] loadings_2pc <- fpca$rotation$data[1:2, ]  # Reconstruction: X_reconstructed = mean + scores %*% loadings X_reconstructed <- matrix(fpca$mean, n, m, byrow = TRUE) + scores_2pc %*% loadings_2pc  # Compare original noisy curve with reconstruction i <- 1  # First curve df_denoise <- data.frame(   t = rep(t, 2),   height = c(fd$data[i, ], X_reconstructed[i, ]),   type = rep(c(\"Original (noisy)\", \"Reconstructed (2 PCs)\"), each = m) )  ggplot(df_denoise, aes(x = t, y = height, color = type)) +   geom_line(linewidth = 1) +   scale_color_manual(values = c(\"Original (noisy)\" = \"gray50\",                                  \"Reconstructed (2 PCs)\" = \"steelblue\")) +   labs(x = \"Age (years)\", y = \"Height (cm)\",        title = \"Denoising via FPCA Reconstruction\") +   theme(legend.position = \"bottom\", legend.title = element_blank())"},{"path":"https://sipemu.github.io/fdars/articles/fpca.html","id":"interpretable-features","dir":"Articles","previous_headings":"Benefits of FPCA","what":"3. Interpretable Features","title":"Functional Principal Component Analysis (FPCA)","text":"PC scores serve meaningful features analysis:","code":"# Scores as features scores_df <- data.frame(   curve_id = 1:n,   PC1 = fpca$x[, 1],   PC2 = fpca$x[, 2],   true_height = height_effect,   true_timing = timing_effect )  # PC1 correlates with height variation cat(\"Correlation(PC1, height effect):\",     round(cor(scores_df$PC1, scores_df$true_height), 3), \"\\n\") #> Correlation(PC1, height effect): 0.784  # PC2 correlates with timing variation cat(\"Correlation(PC2, timing effect):\",     round(cor(scores_df$PC2, scores_df$true_timing), 3), \"\\n\") #> Correlation(PC2, timing effect): 0.596"},{"path":"https://sipemu.github.io/fdars/articles/fpca.html","id":"outlier-detection","dir":"Articles","previous_headings":"Benefits of FPCA","what":"4. Outlier Detection","title":"Functional Principal Component Analysis (FPCA)","text":"Extreme scores indicate unusual curves:","code":"# Mahalanobis-like distance using PC scores pc_vars <- fpca$d^2 / (n - 1)  # Variance of each PC standardized_scores <- sweep(fpca$x, 2, sqrt(pc_vars[1:ncol(fpca$x)]), \"/\") distances <- rowSums(standardized_scores^2)  # Flag potential outliers (chi-squared threshold) threshold <- qchisq(0.975, df = ncol(fpca$x)) outlier_idx <- which(distances > threshold) cat(\"Potential outliers:\", length(outlier_idx), \"curves\\n\") #> Potential outliers: 1 curves"},{"path":"https://sipemu.github.io/fdars/articles/fpca.html","id":"efficient-storage-and-computation","dir":"Articles","previous_headings":"Benefits of FPCA","what":"5. Efficient Storage and Computation","title":"Functional Principal Component Analysis (FPCA)","text":"large datasets, storing scores instead full curves saves memory:","code":"# Storage comparison original_size <- object.size(fd$data) compressed_size <- object.size(fpca$x) + object.size(fpca$rotation$data) + object.size(fpca$mean)  cat(\"Original size:\", format(original_size, units = \"Kb\"), \"\\n\") #> Original size: 39.3 Kb cat(\"FPCA representation:\", format(compressed_size, units = \"Kb\"), \"\\n\") #> FPCA representation: 5.9 Kb"},{"path":"https://sipemu.github.io/fdars/articles/fpca.html","id":"fpca-for-regression","dir":"Articles","previous_headings":"","what":"FPCA for Regression","title":"Functional Principal Component Analysis (FPCA)","text":"PC scores commonly used predictors regression:","code":"# Create a response related to growth # Final height depends on both baseline and timing y <- 0.5 * height_effect + 2 * timing_effect + rnorm(n, sd = 1)  # Principal Component Regression fit <- fregre.pc(fd, y, ncomp = 3)  # Cross-validation to select optimal number of components cv_result <- fregre.pc.cv(fd, y, kfold = 5, ncomp.range = 1:6, seed = 42) cat(\"Optimal number of components:\", cv_result$optimal.ncomp, \"\\n\") #> Optimal number of components: 6  # Visualize CV results df_cv <- data.frame(   ncomp = 1:6,   MSE = cv_result$cv.errors,   se = cv_result$cv.se )  ggplot(df_cv, aes(x = ncomp, y = MSE)) +   geom_line(color = \"steelblue\", linewidth = 1) +   geom_point(color = \"steelblue\", size = 3) +   geom_errorbar(aes(ymin = MSE - se, ymax = MSE + se), width = 0.2, color = \"steelblue\") +   geom_vline(xintercept = cv_result$optimal.ncomp, linetype = \"dashed\", color = \"red\") +   labs(x = \"Number of Components\", y = \"Cross-Validation MSE\",        title = \"Selecting Number of PC Components\") +   scale_x_continuous(breaks = 1:6)"},{"path":"https://sipemu.github.io/fdars/articles/fpca.html","id":"choosing-the-number-of-components","dir":"Articles","previous_headings":"","what":"Choosing the Number of Components","title":"Functional Principal Component Analysis (FPCA)","text":"Several approaches exist selecting number components:","code":""},{"path":"https://sipemu.github.io/fdars/articles/fpca.html","id":"variance-threshold","dir":"Articles","previous_headings":"Choosing the Number of Components","what":"1. Variance Threshold","title":"Functional Principal Component Analysis (FPCA)","text":"","code":"# Calculate cumulative variance var_explained <- fpca$d^2 / sum(fpca$d^2) cum_var <- cumsum(var_explained)  # Find number of components for 95% variance ncomp_95 <- which(cum_var >= 0.95)[1] cat(\"Components for 95% variance:\", ncomp_95, \"\\n\") #> Components for 95% variance: 2"},{"path":"https://sipemu.github.io/fdars/articles/fpca.html","id":"scree-plot-elbow","dir":"Articles","previous_headings":"Choosing the Number of Components","what":"2. Scree Plot Elbow","title":"Functional Principal Component Analysis (FPCA)","text":"Visual inspection scree plot often reveals natural cutoff.","code":""},{"path":"https://sipemu.github.io/fdars/articles/fpca.html","id":"cross-validation","dir":"Articles","previous_headings":"Choosing the Number of Components","what":"3. Cross-Validation","title":"Functional Principal Component Analysis (FPCA)","text":"prediction tasks, cross-validation directly optimizes predictive performance.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/articles/fpca.html","id":"clustering-in-pc-space","dir":"Articles","previous_headings":"Advanced: Working with Scores","what":"Clustering in PC Space","title":"Functional Principal Component Analysis (FPCA)","text":"","code":"# K-means clustering on PC scores km <- kmeans(fpca$x[, 1:2], centers = 3, nstart = 10)  # Visualize clusters df_scores <- data.frame(   PC1 = fpca$x[, 1],   PC2 = fpca$x[, 2],   cluster = factor(km$cluster) )  ggplot(df_scores, aes(x = PC1, y = PC2, color = cluster)) +   geom_point(size = 3) +   labs(title = \"Clustering in PC Score Space\") +   scale_color_brewer(palette = \"Set1\")"},{"path":"https://sipemu.github.io/fdars/articles/fpca.html","id":"functional-boxplot-via-fpca","dir":"Articles","previous_headings":"Advanced: Working with Scores","what":"Functional Boxplot via FPCA","title":"Functional Principal Component Analysis (FPCA)","text":"functional boxplot uses depth measures, PC scores provide alternative view centrality:","code":"# Distance from center in PC space indicates \"outlyingness\" center <- colMeans(fpca$x) pc_distances <- sqrt(rowSums(sweep(fpca$x, 2, center)^2))  # Color curves by distance from center df_curves <- data.frame(   t = rep(t, n),   height = as.vector(t(fd$data)),   curve_id = rep(1:n, each = m),   distance = rep(pc_distances, each = m) )  ggplot(df_curves, aes(x = t, y = height, group = curve_id, color = distance)) +   geom_line(alpha = 0.7) +   scale_color_viridis_c(option = \"plasma\", name = \"PC Distance\") +   labs(x = \"Age (years)\", y = \"Height (cm)\",        title = \"Curves Colored by Distance from PC Center\")"},{"path":"https://sipemu.github.io/fdars/articles/fpca.html","id":"comparison-with-classical-pca","dir":"Articles","previous_headings":"","what":"Comparison with Classical PCA","title":"Functional Principal Component Analysis (FPCA)","text":"FPCA discretized curves mathematically equivalent classical PCA data matrix, functional interpretation adds value:","code":""},{"path":"https://sipemu.github.io/fdars/articles/fpca.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Functional Principal Component Analysis (FPCA)","text":"Ramsay, J.O. Silverman, B.W. (2005). Functional Data Analysis, 2nd Edition. Springer. Ramsay, J.O. Silverman, B.W. (2002). Applied Functional Data Analysis. Springer. Yao, F., M√ºller, H.G., Wang, J.L. (2005). Functional Data Analysis Sparse Longitudinal Data. Journal American Statistical Association, 100(470), 577-590.","code":""},{"path":"https://sipemu.github.io/fdars/articles/intro-to-smoothing.html","id":"why-smooth-functional-data","dir":"Articles","previous_headings":"","what":"Why Smooth Functional Data?","title":"Introduction to Smoothing Functional Data","text":"Real-world functional data almost always contains measurement noise. Raw observations discrete samples underlying smooth process, contaminated : Measurement error: Instrument precision limits Sampling noise: Random variation time point Digitization artifacts: Finite resolution recording devices Smoothing transforms noisy discrete observations smooth functional objects, revealing true underlying signal. essential : Computing derivatives (noise amplifies dramatically) Meaningful curve comparisons Interpretable visualizations Reliable statistical inference","code":"library(fdars) #>  #> Attaching package: 'fdars' #> The following objects are masked from 'package:stats': #>  #>     cov, deriv, median, sd, var #> The following object is masked from 'package:base': #>  #>     norm library(ggplot2) theme_set(theme_minimal()) set.seed(42)"},{"path":"https://sipemu.github.io/fdars/articles/intro-to-smoothing.html","id":"loading-real-data-the-berkeley-growth-study","dir":"Articles","previous_headings":"","what":"Loading Real Data: The Berkeley Growth Study","title":"Introduction to Smoothing Functional Data","text":"Berkeley Growth Study tracked heights 54 girls 39 boys ages 1 18. classic dataset available fda package.","code":"# Check if fda package is available if (!requireNamespace(\"fda\", quietly = TRUE)) {   message(\"Install 'fda' package for real data examples: install.packages('fda')\")   # Create synthetic growth-like data as fallback   age <- seq(1, 18, length.out = 31)   n_girls <- 20   heights <- matrix(0, n_girls, length(age))   for (i in 1:n_girls) {     # Gompertz growth curve with individual variation     A <- rnorm(1, 170, 5)  # asymptotic height     b <- rnorm(1, 2.5, 0.2)     c <- rnorm(1, 0.15, 0.02)     heights[i, ] <- A * exp(-b * exp(-c * age)) + rnorm(length(age), sd = 1.5)   } } else {   data(growth, package = \"fda\")   age <- growth$age   heights <- t(growth$hgtf)  # Girls' heights (rows = curves, cols = time)   n_girls <- nrow(heights) }  # Create fdata object fd_raw <- fdata(heights, argvals = age) cat(\"Dataset:\", n_girls, \"growth curves measured at\", length(age), \"ages\\n\") #> Dataset: 54 growth curves measured at 31 ages"},{"path":"https://sipemu.github.io/fdars/articles/intro-to-smoothing.html","id":"visualizing-the-raw-data","dir":"Articles","previous_headings":"Loading Real Data: The Berkeley Growth Study","what":"Visualizing the Raw Data","title":"Introduction to Smoothing Functional Data","text":"data appears relatively smooth height carefully measured. Let‚Äôs add realistic measurement noise demonstrate smoothing techniques:","code":"plot(fd_raw, main = \"Berkeley Growth Study: Girls' Heights\",      xlab = \"Age (years)\", ylab = \"Height (cm)\") # Add measurement noise to simulate less precise instruments noise_sd <- 2.0  # cm of measurement error heights_noisy <- heights + matrix(rnorm(length(heights), sd = noise_sd),                                    nrow = nrow(heights)) fd_noisy <- fdata(heights_noisy, argvals = age)  # Compare original and noisy using faceted ggplot df_compare <- rbind(   data.frame(     age = rep(age, 5),     height = as.vector(t(fd_raw$data[1:5, ])),     curve = rep(1:5, each = length(age)),     type = \"Original\"   ),   data.frame(     age = rep(age, 5),     height = as.vector(t(fd_noisy$data[1:5, ])),     curve = rep(1:5, each = length(age)),     type = \"With Noise\"   ) ) df_compare$curve <- factor(df_compare$curve)  ggplot(df_compare, aes(x = age, y = height, color = curve)) +   geom_line() +   facet_wrap(~ type) +   labs(x = \"Age (years)\", y = \"Height (cm)\", color = \"Curve\") +   theme_minimal() +   theme(legend.position = \"bottom\")"},{"path":"https://sipemu.github.io/fdars/articles/intro-to-smoothing.html","id":"method-1-p-spline-smoothing","dir":"Articles","previous_headings":"","what":"Method 1: P-spline Smoothing","title":"Introduction to Smoothing Functional Data","text":"Penalized splines (P-splines) powerful flexible smoothing method. balance two objectives: Fit data closely (minimize residuals) Keep curve smooth (penalize roughness) smoothing parameter Œª\\lambda controls trade-: - Small Œª\\lambda: Follows data closely, may wiggly - Large Œª\\lambda: smooth, may miss real features","code":""},{"path":"https://sipemu.github.io/fdars/articles/intro-to-smoothing.html","id":"automatic-smoothing-with-p-splines","dir":"Articles","previous_headings":"Method 1: P-spline Smoothing","what":"Automatic Smoothing with P-splines","title":"Introduction to Smoothing Functional Data","text":"","code":"# pspline() automatically selects optimal lambda via GCV fd_pspline <- pspline(fd_noisy) print(fd_pspline) #> P-spline Smoothing Results #> ========================== #> Number of curves: 54  #> Number of basis functions: 20  #> Penalty order: 2  #> Lambda: 1e+00  #> Effective df: 6.81  #> GCV: 5.701e+00"},{"path":"https://sipemu.github.io/fdars/articles/intro-to-smoothing.html","id":"visualizing-the-result","dir":"Articles","previous_headings":"Method 1: P-spline Smoothing","what":"Visualizing the Result","title":"Introduction to Smoothing Functional Data","text":"","code":"# Compare noisy vs smoothed for first curve idx <- 1 df_pspline <- data.frame(   age = rep(age, 3),   height = c(fd_noisy$data[idx, ], fd_pspline$fdata$data[idx, ], fd_raw$data[idx, ]),   type = factor(rep(c(\"Noisy data\", \"P-spline smooth\", \"Original\"), each = length(age)),                 levels = c(\"Noisy data\", \"P-spline smooth\", \"Original\")) )  ggplot(df_pspline, aes(x = age, y = height, color = type, linetype = type)) +   geom_point(data = subset(df_pspline, type == \"Noisy data\"),              color = \"gray60\", size = 1) +   geom_line(data = subset(df_pspline, type != \"Noisy data\"), linewidth = 1) +   scale_color_manual(values = c(\"Noisy data\" = \"gray60\", \"P-spline smooth\" = \"blue\",                                  \"Original\" = \"red\")) +   scale_linetype_manual(values = c(\"Noisy data\" = \"blank\", \"P-spline smooth\" = \"solid\",                                     \"Original\" = \"dashed\")) +   labs(x = \"Age (years)\", y = \"Height (cm)\", title = \"P-spline Smoothing\",        color = NULL, linetype = NULL) +   theme_minimal() +   theme(legend.position = \"bottom\")"},{"path":"https://sipemu.github.io/fdars/articles/intro-to-smoothing.html","id":"effect-of-smoothing-parameter","dir":"Articles","previous_headings":"Method 1: P-spline Smoothing","what":"Effect of Smoothing Parameter","title":"Introduction to Smoothing Functional Data","text":"","code":"# Different smoothing levels fd_less <- pspline(fd_noisy, lambda = 0.001)   # Less smoothing fd_more <- pspline(fd_noisy, lambda = 100)     # More smoothing  idx <- 1 df_lambda <- rbind(   data.frame(age = age, height = fd_noisy$data[idx, ], type = \"data\",              lambda = \"lambda = 0.001\"),   data.frame(age = age, height = fd_less$fdata$data[idx, ], type = \"smooth\",              lambda = \"lambda = 0.001\"),   data.frame(age = age, height = fd_noisy$data[idx, ], type = \"data\",              lambda = \"Optimal (GCV)\"),   data.frame(age = age, height = fd_pspline$fdata$data[idx, ], type = \"smooth\",              lambda = \"Optimal (GCV)\"),   data.frame(age = age, height = fd_noisy$data[idx, ], type = \"data\",              lambda = \"lambda = 100\"),   data.frame(age = age, height = fd_more$fdata$data[idx, ], type = \"smooth\",              lambda = \"lambda = 100\") ) df_lambda$lambda <- factor(df_lambda$lambda,                             levels = c(\"lambda = 0.001\", \"Optimal (GCV)\", \"lambda = 100\"))  ggplot(df_lambda, aes(x = age, y = height)) +   geom_point(data = subset(df_lambda, type == \"data\"), color = \"gray60\", size = 1) +   geom_line(data = subset(df_lambda, type == \"smooth\"), color = \"blue\", linewidth = 1) +   facet_wrap(~ lambda) +   labs(x = \"Age (years)\", y = \"Height (cm)\",        title = \"Effect of Smoothing Parameter\") +   theme_minimal()"},{"path":"https://sipemu.github.io/fdars/articles/intro-to-smoothing.html","id":"method-2-kernel-smoothers","dir":"Articles","previous_headings":"","what":"Method 2: Kernel Smoothers","title":"Introduction to Smoothing Functional Data","text":"Kernel smoothers estimate value point using weighted average nearby observations. bandwidth hh controls neighborhood size.","code":""},{"path":"https://sipemu.github.io/fdars/articles/intro-to-smoothing.html","id":"nadaraya-watson-smoother","dir":"Articles","previous_headings":"Method 2: Kernel Smoothers","what":"Nadaraya-Watson Smoother","title":"Introduction to Smoothing Functional Data","text":"","code":"# Compute smoother matrix with Nadaraya-Watson # S.NW takes evaluation points (tt) as first argument h <- h.default(fd_noisy)  # Default bandwidth based on data  S_nw <- S.NW(tt = age, h = h)  # Apply smoother to each curve fd_kernel <- fd_noisy for (i in 1:nrow(fd_kernel$data)) {   fd_kernel$data[i, ] <- as.vector(S_nw %*% fd_noisy$data[i, ]) }"},{"path":"https://sipemu.github.io/fdars/articles/intro-to-smoothing.html","id":"local-linear-regression","dir":"Articles","previous_headings":"Method 2: Kernel Smoothers","what":"Local Linear Regression","title":"Introduction to Smoothing Functional Data","text":"Local linear regression often performs better boundaries:","code":"S_llr <- S.LLR(tt = age, h = h) fd_llr <- fd_noisy for (i in 1:nrow(fd_llr$data)) {   fd_llr$data[i, ] <- as.vector(S_llr %*% fd_noisy$data[i, ]) }"},{"path":"https://sipemu.github.io/fdars/articles/intro-to-smoothing.html","id":"comparing-kernel-methods","dir":"Articles","previous_headings":"Method 2: Kernel Smoothers","what":"Comparing Kernel Methods","title":"Introduction to Smoothing Functional Data","text":"","code":"idx <- 1 df_kernels <- data.frame(   age = rep(age, 4),   height = c(fd_noisy$data[idx, ], fd_kernel$data[idx, ],              fd_llr$data[idx, ], fd_raw$data[idx, ]),   type = factor(rep(c(\"Data\", \"Nadaraya-Watson\", \"Local Linear\", \"Original\"),                     each = length(age)),                 levels = c(\"Data\", \"Nadaraya-Watson\", \"Local Linear\", \"Original\")) )  ggplot(df_kernels, aes(x = age, y = height, color = type, linetype = type)) +   geom_point(data = subset(df_kernels, type == \"Data\"), size = 1) +   geom_line(data = subset(df_kernels, type != \"Data\"), linewidth = 1) +   scale_color_manual(values = c(\"Data\" = \"gray60\", \"Nadaraya-Watson\" = \"blue\",                                  \"Local Linear\" = \"darkgreen\", \"Original\" = \"red\")) +   scale_linetype_manual(values = c(\"Data\" = \"blank\", \"Nadaraya-Watson\" = \"solid\",                                     \"Local Linear\" = \"solid\", \"Original\" = \"dashed\")) +   labs(x = \"Age (years)\", y = \"Height (cm)\",        title = \"Kernel Smoother Comparison\", color = NULL, linetype = NULL) +   theme_minimal() +   theme(legend.position = \"bottom\")"},{"path":"https://sipemu.github.io/fdars/articles/intro-to-smoothing.html","id":"bandwidth-selection","dir":"Articles","previous_headings":"Method 2: Kernel Smoothers","what":"Bandwidth Selection","title":"Introduction to Smoothing Functional Data","text":"default bandwidth h.default() based data:","code":"cat(\"Default bandwidth:\", h, \"\\n\") #> Default bandwidth: 1.5 cat(\"This is computed as the 15th percentile of pairwise distances.\\n\") #> This is computed as the 15th percentile of pairwise distances."},{"path":"https://sipemu.github.io/fdars/articles/intro-to-smoothing.html","id":"method-3-basis-expansion","dir":"Articles","previous_headings":"","what":"Method 3: Basis Expansion","title":"Introduction to Smoothing Functional Data","text":"Represent curves linear combinations basis functions. provides dimensionality reduction along smoothing.","code":""},{"path":"https://sipemu.github.io/fdars/articles/intro-to-smoothing.html","id":"b-spline-basis","dir":"Articles","previous_headings":"Method 3: Basis Expansion","what":"B-spline Basis","title":"Introduction to Smoothing Functional Data","text":"","code":"# Project to B-spline basis coefs <- fdata2basis(fd_noisy, nbasis = 12, type = \"bspline\") fd_basis <- basis2fdata(coefs, argvals = age, type = \"bspline\")  # Compare idx <- 1 df_bspline <- data.frame(   age = rep(age, 3),   height = c(fd_noisy$data[idx, ], fd_basis$data[idx, ], fd_raw$data[idx, ]),   type = factor(rep(c(\"Data\", \"B-spline\", \"Original\"), each = length(age)),                 levels = c(\"Data\", \"B-spline\", \"Original\")) )  ggplot(df_bspline, aes(x = age, y = height, color = type, linetype = type)) +   geom_point(data = subset(df_bspline, type == \"Data\"), size = 1) +   geom_line(data = subset(df_bspline, type != \"Data\"), linewidth = 1) +   scale_color_manual(values = c(\"Data\" = \"gray60\", \"B-spline\" = \"purple\",                                  \"Original\" = \"red\")) +   scale_linetype_manual(values = c(\"Data\" = \"blank\", \"B-spline\" = \"solid\",                                     \"Original\" = \"dashed\")) +   labs(x = \"Age (years)\", y = \"Height (cm)\", title = \"B-spline Basis (K=12)\",        color = NULL, linetype = NULL) +   theme_minimal() +   theme(legend.position = \"bottom\")"},{"path":"https://sipemu.github.io/fdars/articles/intro-to-smoothing.html","id":"automatic-basis-selection","dir":"Articles","previous_headings":"Method 3: Basis Expansion","what":"Automatic Basis Selection","title":"Introduction to Smoothing Functional Data","text":"many basis functions? Cross-validation finds optimal number:","code":"# Cross-validation for optimal number of basis functions cv_basis <- fdata2basis.cv(fd_noisy, type = \"bspline\",                            nbasis.range = 5:20) print(cv_basis) #> Basis Cross-Validation Results #> ============================== #> Criterion: GCV  #> Optimal nbasis: 11  #> Score at optimal: 5.906161  #> Range tested: 5 - 20 plot(cv_basis)"},{"path":"https://sipemu.github.io/fdars/articles/intro-to-smoothing.html","id":"information-criteria","dir":"Articles","previous_headings":"Method 3: Basis Expansion","what":"Information Criteria","title":"Introduction to Smoothing Functional Data","text":"fdata2basis.cv function supports different criteria: - GCV (default): Generalized Cross-Validation - CV: Leave-one-Cross-Validation - AIC: Akaike Information Criterion - BIC: Bayesian Information Criterion","code":"# Get optimal basis from our CV result optimal_nbasis <- cv_basis$optimal.nbasis cat(\"Optimal number of basis functions (GCV):\", optimal_nbasis, \"\\n\") #> Optimal number of basis functions (GCV): 11"},{"path":"https://sipemu.github.io/fdars/articles/intro-to-smoothing.html","id":"comparing-all-methods","dir":"Articles","previous_headings":"","what":"Comparing All Methods","title":"Introduction to Smoothing Functional Data","text":"","code":"idx <- 3  # Pick a different curve  # Get smoothed versions smooth_pspline <- fd_pspline$fdata$data[idx, ] smooth_kernel <- fd_llr$data[idx, ]  # Use optimal basis from CV coefs_opt <- fdata2basis(fd_noisy, nbasis = optimal_nbasis, type = \"bspline\") smooth_basis <- basis2fdata(coefs_opt, argvals = age, type = \"bspline\")$data[idx, ]  # Create data frame for plotting df_all <- data.frame(   age = rep(age, 5),   height = c(fd_noisy$data[idx, ], smooth_pspline, smooth_kernel,              smooth_basis, fd_raw$data[idx, ]),   method = factor(rep(c(\"Noisy data\", \"P-spline\", \"Local Linear\",                         \"B-spline basis\", \"Original\"), each = length(age)),                   levels = c(\"Noisy data\", \"P-spline\", \"Local Linear\",                              \"B-spline basis\", \"Original\")) )  ggplot(df_all, aes(x = age, y = height, color = method, linetype = method)) +   geom_point(data = subset(df_all, method == \"Noisy data\"), size = 1) +   geom_line(data = subset(df_all, method != \"Noisy data\"), linewidth = 1) +   scale_color_manual(values = c(\"Noisy data\" = \"gray60\", \"P-spline\" = \"blue\",                                  \"Local Linear\" = \"darkgreen\", \"B-spline basis\" = \"purple\",                                  \"Original\" = \"red\")) +   scale_linetype_manual(values = c(\"Noisy data\" = \"blank\", \"P-spline\" = \"solid\",                                     \"Local Linear\" = \"solid\", \"B-spline basis\" = \"solid\",                                     \"Original\" = \"dashed\")) +   labs(x = \"Age (years)\", y = \"Height (cm)\",        title = \"Smoothing Method Comparison\", color = NULL, linetype = NULL) +   theme_minimal() +   theme(legend.position = \"bottom\")"},{"path":"https://sipemu.github.io/fdars/articles/intro-to-smoothing.html","id":"mean-and-variability","dir":"Articles","previous_headings":"","what":"Mean and Variability","title":"Introduction to Smoothing Functional Data","text":"smoothing, compute summary statistics:","code":"# Use P-spline smoothed data fd_smooth <- fd_pspline$fdata  # Mean curve mean_curve <- mean(fd_smooth)  # Standard deviation at each point sd_curve <- sd(fd_smooth)  # Create data frame for plotting df_mean <- data.frame(   age = age,   mean = mean_curve$data[1, ],   lower = mean_curve$data[1, ] - 2 * sd_curve$data[1, ],   upper = mean_curve$data[1, ] + 2 * sd_curve$data[1, ] )  ggplot(df_mean, aes(x = age)) +   geom_ribbon(aes(ymin = lower, ymax = upper), fill = \"blue\", alpha = 0.2) +   geom_line(aes(y = mean), color = \"blue\", linewidth = 1.2) +   labs(x = \"Age (years)\", y = \"Height (cm)\",        title = \"Mean Growth Curve with Variability Band\",        subtitle = \"Shaded region: Mean +/- 2 SD\") +   theme_minimal()"},{"path":"https://sipemu.github.io/fdars/articles/intro-to-smoothing.html","id":"summary-when-to-use-each-method","dir":"Articles","previous_headings":"","what":"Summary: When to Use Each Method","title":"Introduction to Smoothing Functional Data","text":"Recommendations: Start P-splines - automatic Œª\\lambda selection works well cases Use basis expansion need derivatives (smoother derivatives) Use kernel smoothers highly irregular sampling adaptive smoothing","code":""},{"path":"https://sipemu.github.io/fdars/articles/intro-to-smoothing.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Introduction to Smoothing Functional Data","text":"Ramsay, J.O. Silverman, B.W. (2005). Functional Data Analysis. Springer. Eilers, P.H.C. Marx, B.D. (1996). Flexible Smoothing B-splines Penalties. Statistical Science, 11(2), 89-121. Fan, J. Gijbels, . (1996). Local Polynomial Modelling Applications. Chapman Hall.","code":""},{"path":"https://sipemu.github.io/fdars/articles/introduction.html","id":"what-is-functional-data-analysis","dir":"Articles","previous_headings":"","what":"What is Functional Data Analysis?","title":"Introduction to fdars","text":"Functional Data Analysis (FDA) branch statistics deals data observation function, curve, surface rather single number vector. Examples include: - Temperature curves recorded day - Growth curves children time - Spectrometric measurements across wavelengths - Stock prices throughout trading hours FDA, treat curve single observation develop methods analyze collections curves.","code":""},{"path":"https://sipemu.github.io/fdars/articles/introduction.html","id":"the-fdars-package","dir":"Articles","previous_headings":"","what":"The fdars Package","title":"Introduction to fdars","text":"fdars (Functional Data Analysis Rust) provides comprehensive toolkit FDA high-performance Rust backend. Key features include: Fast computation: 10-200x speedups pure R implementations Comprehensive methods: Depth functions, regression, clustering, outlier detection Flexible metrics: Multiple distance measures including DTW 2D support: Analysis surfaces addition curves","code":""},{"path":"https://sipemu.github.io/fdars/articles/introduction.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"Introduction to fdars","text":"","code":"# Install from GitHub remotes::install_github(\"sipemu/fdars\")"},{"path":"https://sipemu.github.io/fdars/articles/introduction.html","id":"getting-started","dir":"Articles","previous_headings":"","what":"Getting Started","title":"Introduction to fdars","text":"","code":"library(fdars) #>  #> Attaching package: 'fdars' #> The following objects are masked from 'package:stats': #>  #>     cov, deriv, median, sd, var #> The following object is masked from 'package:base': #>  #>     norm library(ggplot2) theme_set(theme_minimal())"},{"path":"https://sipemu.github.io/fdars/articles/introduction.html","id":"creating-functional-data","dir":"Articles","previous_headings":"Getting Started","what":"Creating Functional Data","title":"Introduction to fdars","text":"core data structure fdata class. Create functional data matrix rows observations (curves) columns evaluation points:","code":"# Generate example data: 20 curves evaluated at 100 points set.seed(42) n <- 20 m <- 100 t_grid <- seq(0, 1, length.out = m)  # Create curves: sine waves with random phase and noise X <- matrix(0, n, m) for (i in 1:n) {   phase <- runif(1, 0, pi)   X[i, ] <- sin(2 * pi * t_grid + phase) + rnorm(m, sd = 0.1) }  # Create fdata object fd <- fdata(X, argvals = t_grid) fd #> Functional data object #>   Type: 1D (curve)  #>   Number of observations: 20  #>   Number of points: 100  #>   Range: 0 - 1"},{"path":"https://sipemu.github.io/fdars/articles/introduction.html","id":"adding-identifiers-and-metadata","dir":"Articles","previous_headings":"Getting Started","what":"Adding Identifiers and Metadata","title":"Introduction to fdars","text":"can attach identifiers metadata (covariates) functional data: Metadata preserved subsetting:","code":"# Create metadata with covariates meta <- data.frame(   group = factor(rep(c(\"control\", \"treatment\"), each = 10)),   age = sample(20:60, n, replace = TRUE),   response = rnorm(n) )  # Create fdata with IDs and metadata fd_meta <- fdata(X, argvals = t_grid,                  id = paste0(\"patient_\", 1:n),                  metadata = meta) fd_meta #> Functional data object #>   Type: 1D (curve)  #>   Number of observations: 20  #>   Number of points: 100  #>   Range: 0 - 1  #>   Metadata columns: group, age, response  # Access metadata fd_meta$id[1:5] #> [1] \"patient_1\" \"patient_2\" \"patient_3\" \"patient_4\" \"patient_5\" head(fd_meta$metadata) #>     group age   response #> 1 control  54  0.3533851 #> 2 control  43 -0.2975149 #> 3 control  55  0.5553262 #> 4 control  56 -0.3193581 #> 5 control  28 -0.7752047 #> 6 control  38  0.4711363 fd_sub <- fd_meta[1:5, ] fd_sub$id #> [1] \"patient_1\" \"patient_2\" \"patient_3\" \"patient_4\" \"patient_5\" fd_sub$metadata #>     group age   response #> 1 control  54  0.3533851 #> 2 control  43 -0.2975149 #> 3 control  55  0.5553262 #> 4 control  56 -0.3193581 #> 5 control  28 -0.7752047"},{"path":"https://sipemu.github.io/fdars/articles/introduction.html","id":"visualizing-functional-data","dir":"Articles","previous_headings":"Getting Started","what":"Visualizing Functional Data","title":"Introduction to fdars","text":"","code":"plot(fd)"},{"path":"https://sipemu.github.io/fdars/articles/introduction.html","id":"basic-operations","dir":"Articles","previous_headings":"Getting Started","what":"Basic Operations","title":"Introduction to fdars","text":"","code":"# Compute mean function mean_curve <- mean(fd)  # Center the data fd_centered <- fdata.cen(fd)  # Compute functional variance variance <- var(fd)"},{"path":"https://sipemu.github.io/fdars/articles/introduction.html","id":"subsetting","dir":"Articles","previous_headings":"Getting Started","what":"Subsetting","title":"Introduction to fdars","text":"Select specific curves evaluation points:","code":"# First 5 curves fd_subset <- fd[1:5, ]  # Specific range of t values fd_range <- fd[, t_grid >= 0.25 & t_grid <= 0.75]"},{"path":[]},{"path":"https://sipemu.github.io/fdars/articles/introduction.html","id":"depth-functions","dir":"Articles","previous_headings":"Key Functionality Overview","what":"Depth Functions","title":"Introduction to fdars","text":"Depth measures ‚Äúcentral‚Äù curve within sample. Higher depth indicates typical curve:","code":"# Fraiman-Muniz depth depths <- depth(fd, method = \"FM\") head(depths) #> [1] 0.411 0.703 0.604 0.558 0.725 0.309  # Find the median curve (deepest) median_curve <- median(fd, method = \"FM\")"},{"path":"https://sipemu.github.io/fdars/articles/introduction.html","id":"distance-metrics","dir":"Articles","previous_headings":"Key Functionality Overview","what":"Distance Metrics","title":"Introduction to fdars","text":"Compute distances curves using various metrics:","code":"# L2 (Euclidean) distance dist_l2 <- metric.lp(fd)  # Dynamic Time Warping dist_dtw <- metric.DTW(fd)"},{"path":"https://sipemu.github.io/fdars/articles/introduction.html","id":"regression","dir":"Articles","previous_headings":"Key Functionality Overview","what":"Regression","title":"Introduction to fdars","text":"Predict scalar response functional predictors:","code":"# Generate response y <- rowMeans(X) + rnorm(n, sd = 0.1)  # Principal component regression fit_pc <- fregre.pc(fd, y, ncomp = 3) print(fit_pc) #> Functional regression model #>   Number of observations: 20  #>   R-squared: 0.1146712"},{"path":"https://sipemu.github.io/fdars/articles/introduction.html","id":"clustering","dir":"Articles","previous_headings":"Key Functionality Overview","what":"Clustering","title":"Introduction to fdars","text":"Group curves clusters:","code":"# K-means clustering km <- cluster.kmeans(fd, ncl = 2, seed = 123) plot(km)"},{"path":"https://sipemu.github.io/fdars/articles/introduction.html","id":"outlier-detection","dir":"Articles","previous_headings":"Key Functionality Overview","what":"Outlier Detection","title":"Introduction to fdars","text":"Identify atypical curves:","code":"# Add an outlier X_out <- rbind(X, X[1, ] + 3) fd_out <- fdata(X_out, argvals = t_grid)  # Detect outliers out <- outliers.depth.pond(fd_out) plot(out)"},{"path":"https://sipemu.github.io/fdars/articles/introduction.html","id":"next-steps","dir":"Articles","previous_headings":"","what":"Next Steps","title":"Introduction to fdars","text":"Explore vignettes detailed coverage specific topics: Covariance Functions: Generate Gaussian process samples various kernels Depth Functions: Comprehensive guide functional depth measures Distance Metrics: Distance semimetric functions Regression: Functional regression methods Clustering: Functional k-means optimal k selection Outlier Detection: Methods identifying atypical curves","code":""},{"path":"https://sipemu.github.io/fdars/articles/introduction.html","id":"performance","dir":"Articles","previous_headings":"","what":"Performance","title":"Introduction to fdars","text":"Rust backend provides significant speedups computationally intensive operations. example, computing depth 1000 curves:","code":"# Generate large dataset X_large <- matrix(rnorm(1000 * 200), 1000, 200) fd_large <- fdata(X_large)  # Depth computation is fast even for large datasets system.time(depth(fd_large, method = \"FM\")) #>    user  system elapsed #>   0.045   0.000   0.045"},{"path":"https://sipemu.github.io/fdars/articles/introduction.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Introduction to fdars","text":"Ramsay, J.O. Silverman, B.W. (2005). Functional Data Analysis. Springer. Ferraty, F. Vieu, P. (2006). Nonparametric Functional Data Analysis. Springer. Febrero-Bande, M. Oviedo de la Fuente, M. (2012). Statistical Computing Functional Data Analysis: R Package fda.usc. Journal Statistical Software, 51(4), 1-28.","code":""},{"path":"https://sipemu.github.io/fdars/articles/outlier-detection.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Outlier Detection","text":"Outlier detection functional data identifies curves atypical anomalous compared rest sample. fdars provides several methods based functional depth likelihood ratio tests.","code":"library(fdars) #>  #> Attaching package: 'fdars' #> The following objects are masked from 'package:stats': #>  #>     cov, deriv, median, sd, var #> The following object is masked from 'package:base': #>  #>     norm library(ggplot2) theme_set(theme_minimal())  # Generate normal data set.seed(42) n <- 30 m <- 100 t_grid <- seq(0, 1, length.out = m)  X <- matrix(0, n, m) for (i in 1:n) {   X[i, ] <- sin(2 * pi * t_grid) + rnorm(m, sd = 0.15) }  # Add different types of outliers X[1, ] <- sin(2 * pi * t_grid) + 2           # Magnitude outlier (shift up) X[2, ] <- -sin(2 * pi * t_grid)              # Shape outlier (inverted) X[3, ] <- sin(4 * pi * t_grid)               # Frequency outlier  fd <- fdata(X, argvals = t_grid) plot(fd)"},{"path":"https://sipemu.github.io/fdars/articles/outlier-detection.html","id":"depth-based-methods","dir":"Articles","previous_headings":"","what":"Depth-Based Methods","title":"Outlier Detection","text":"Depth-based outlier detection identifies curves unusually low depth (far center data).","code":""},{"path":"https://sipemu.github.io/fdars/articles/outlier-detection.html","id":"weighted-depth-method-outliers-depth-pond","dir":"Articles","previous_headings":"Depth-Based Methods","what":"Weighted Depth Method (outliers.depth.pond)","title":"Outlier Detection","text":"Uses bootstrap resampling estimate distribution depths identifies curves depth data-driven cutoff.","code":"out_pond <- outliers.depth.pond(fd, nb = 100, seed = 123) print(out_pond) #> Functional data outlier detection #>   Number of observations: 30  #>   Number of outliers: 14  #>   Outlier indices: 1 2 3 6 9 10 16 17 22 23 ... #>   Depth cutoff: 0.8017926"},{"path":"https://sipemu.github.io/fdars/articles/outlier-detection.html","id":"visualizing-outliers","dir":"Articles","previous_headings":"Depth-Based Methods","what":"Visualizing Outliers","title":"Outlier Detection","text":"","code":"plot(out_pond)"},{"path":"https://sipemu.github.io/fdars/articles/outlier-detection.html","id":"examining-results","dir":"Articles","previous_headings":"Depth-Based Methods","what":"Examining Results","title":"Outlier Detection","text":"","code":"# Which curves are outliers? out_pond$outliers #>  [1]  1  2  3  6  9 10 16 17 22 23 26 27 29 30  # Depth values for all curves head(out_pond$depths) #> [1] 0.03335063 0.03975641 0.09617913 0.81234036 0.80291236 0.79686410  # Cutoff used out_pond$cutoff #>       50%  #> 0.8017926"},{"path":"https://sipemu.github.io/fdars/articles/outlier-detection.html","id":"trimming-based-method-outliers-depth-trim","dir":"Articles","previous_headings":"Depth-Based Methods","what":"Trimming-Based Method (outliers.depth.trim)","title":"Outlier Detection","text":"Iteratively removes curves lowest depth:","code":"out_trim <- outliers.depth.trim(fd, trim = 0.1, seed = 123) print(out_trim) #> Functional data outlier detection #>   Number of observations: 30  #>   Number of outliers: 3  #>   Outlier indices: 1 2 3 #>   Depth cutoff: 0.7135042 plot(out_trim)"},{"path":"https://sipemu.github.io/fdars/articles/outlier-detection.html","id":"using-different-depth-functions","dir":"Articles","previous_headings":"Depth-Based Methods","what":"Using Different Depth Functions","title":"Outlier Detection","text":"methods accept depth parameter specify depth function:","code":"# Using Random Projection depth out_rp <- outliers.depth.pond(fd, nb = 100, seed = 123)  # Using modal depth (default is FM) out_mode <- outliers.depth.trim(fd, trim = 0.1, seed = 123)"},{"path":"https://sipemu.github.io/fdars/articles/outlier-detection.html","id":"likelihood-ratio-test-lrt-method","dir":"Articles","previous_headings":"","what":"Likelihood Ratio Test (LRT) Method","title":"Outlier Detection","text":"LRT method uses likelihood ratio test sequentially identify outliers. ‚Äôs particularly effective detecting magnitude outliers.","code":""},{"path":"https://sipemu.github.io/fdars/articles/outlier-detection.html","id":"computing-the-threshold","dir":"Articles","previous_headings":"Likelihood Ratio Test (LRT) Method","what":"Computing the Threshold","title":"Outlier Detection","text":"First, compute bootstrap threshold:","code":"threshold <- outliers.thres.lrt(fd, nb = 100, seed = 123) cat(\"LRT threshold:\", threshold, \"\\n\") #> LRT threshold: 15.63581"},{"path":"https://sipemu.github.io/fdars/articles/outlier-detection.html","id":"detecting-outliers","dir":"Articles","previous_headings":"Likelihood Ratio Test (LRT) Method","what":"Detecting Outliers","title":"Outlier Detection","text":"","code":"out_lrt <- outliers.lrt(fd, nb = 100, seed = 123) print(out_lrt) #> Functional data outlier detection #>   Number of observations: 0  #>   Number of outliers: 0  #>   Depth cutoff: plot(out_lrt)"},{"path":"https://sipemu.github.io/fdars/articles/outlier-detection.html","id":"lrt-results","dir":"Articles","previous_headings":"Likelihood Ratio Test (LRT) Method","what":"LRT Results","title":"Outlier Detection","text":"","code":"# Outlier indices out_lrt$outliers #> integer(0)  # Distance from center for each curve head(out_lrt$distances) #> [1] 13.9142441  9.6757588  6.8092255  0.8885643  0.9423256  1.0432319  # Threshold used out_lrt$threshold #> [1] 15.63581"},{"path":"https://sipemu.github.io/fdars/articles/outlier-detection.html","id":"comparing-methods","dir":"Articles","previous_headings":"","what":"Comparing Methods","title":"Outlier Detection","text":"Different methods may detect different types outliers:","code":"# Run all methods out1 <- outliers.depth.pond(fd, nb = 100, seed = 123) out2 <- outliers.depth.trim(fd, trim = 0.1, seed = 123) out3 <- outliers.lrt(fd, nb = 100, seed = 123)  # Compare detected outliers cat(\"Depth-pond outliers:\", out1$outliers, \"\\n\") #> Depth-pond outliers: 1 2 3 6 10 23 26 27 29 30 cat(\"Depth-trim outliers:\", out2$outliers, \"\\n\") #> Depth-trim outliers: 1 2 3 cat(\"LRT outliers:\", out3$outliers, \"\\n\") #> LRT outliers:  # True outliers are curves 1, 2, 3 cat(\"True outliers: 1, 2, 3\\n\") #> True outliers: 1, 2, 3"},{"path":[]},{"path":"https://sipemu.github.io/fdars/articles/outlier-detection.html","id":"magnitude-outliers","dir":"Articles","previous_headings":"Types of Outliers","what":"Magnitude Outliers","title":"Outlier Detection","text":"Curves shifted main group:","code":"# Create data with magnitude outlier X_mag <- X X_mag[1, ] <- sin(2 * pi * t_grid) + 3  # Large shift  fd_mag <- fdata(X_mag, argvals = t_grid) out_mag <- outliers.depth.pond(fd_mag, nb = 100, seed = 123)  cat(\"Detected magnitude outlier:\", out_mag$outliers, \"\\n\") #> Detected magnitude outlier: 1 2 3 10 29 30 plot(out_mag)"},{"path":"https://sipemu.github.io/fdars/articles/outlier-detection.html","id":"shape-outliers","dir":"Articles","previous_headings":"Types of Outliers","what":"Shape Outliers","title":"Outlier Detection","text":"Curves different patterns:","code":"# Create data with shape outlier X_shape <- X X_shape[1, ] <- cos(2 * pi * t_grid)  # Different shape  fd_shape <- fdata(X_shape, argvals = t_grid) out_shape <- outliers.depth.pond(fd_shape, nb = 100, seed = 123)  cat(\"Detected shape outlier:\", out_shape$outliers, \"\\n\") #> Detected shape outlier: 1 2 3 10 23 29 30"},{"path":"https://sipemu.github.io/fdars/articles/outlier-detection.html","id":"amplitude-outliers","dir":"Articles","previous_headings":"Types of Outliers","what":"Amplitude Outliers","title":"Outlier Detection","text":"Curves unusual amplitude (scale):","code":"# Create data with amplitude outlier X_amp <- X X_amp[1, ] <- 3 * sin(2 * pi * t_grid)  # Larger amplitude  fd_amp <- fdata(X_amp, argvals = t_grid) out_amp <- outliers.depth.pond(fd_amp, nb = 100, seed = 123)  cat(\"Detected amplitude outlier:\", out_amp$outliers, \"\\n\") #> Detected amplitude outlier: 1 2 3 6 9 10 11 16 17 22 23 26 27 29 30"},{"path":[]},{"path":"https://sipemu.github.io/fdars/articles/outlier-detection.html","id":"number-of-bootstrap-samples","dir":"Articles","previous_headings":"Tuning Parameters","what":"Number of Bootstrap Samples","title":"Outlier Detection","text":"bootstrap samples give stable results take longer:","code":"# Compare with different nb values out_nb50 <- outliers.depth.pond(fd, nb = 50, seed = 123) out_nb200 <- outliers.depth.pond(fd, nb = 200, seed = 123)  cat(\"nb=50 outliers:\", out_nb50$outliers, \"\\n\") #> nb=50 outliers: 1 2 3 6 10 17 23 26 27 29 30 cat(\"nb=200 outliers:\", out_nb200$outliers, \"\\n\") #> nb=200 outliers: 1 2 3 6 9 10 11 16 17 18 21 22 23 26 27 29 30"},{"path":"https://sipemu.github.io/fdars/articles/outlier-detection.html","id":"trim-proportion","dir":"Articles","previous_headings":"Tuning Parameters","what":"Trim Proportion","title":"Outlier Detection","text":"outliers.depth.trim, trim proportion controls sensitivity:","code":"# More aggressive trimming out_trim05 <- outliers.depth.trim(fd, trim = 0.05, seed = 123) out_trim20 <- outliers.depth.trim(fd, trim = 0.2, seed = 123)  cat(\"trim=0.05 outliers:\", out_trim05$outliers, \"\\n\") #> trim=0.05 outliers: 1 2 cat(\"trim=0.20 outliers:\", out_trim20$outliers, \"\\n\") #> trim=0.20 outliers: 1 2 3 10 29 30"},{"path":"https://sipemu.github.io/fdars/articles/outlier-detection.html","id":"handling-high-contamination","dir":"Articles","previous_headings":"","what":"Handling High Contamination","title":"Outlier Detection","text":"outlier contamination high, use robust methods:","code":"# Create data with 20% outliers X_contam <- X n_outliers <- 6 for (i in 1:n_outliers) {   X_contam[i, ] <- sin(2 * pi * t_grid) + rnorm(1, 0, 2) }  fd_contam <- fdata(X_contam, argvals = t_grid)  # Depth-trim with higher trim proportion out_contam <- outliers.depth.trim(fd_contam, trim = 0.2, seed = 123) cat(\"Detected outliers:\", out_contam$outliers, \"\\n\") #> Detected outliers: 1 2 3 4 5 6 cat(\"True outliers: 1-6\\n\") #> True outliers: 1-6"},{"path":"https://sipemu.github.io/fdars/articles/outlier-detection.html","id":"visualizing-depth-distribution","dir":"Articles","previous_headings":"","what":"Visualizing Depth Distribution","title":"Outlier Detection","text":"","code":"# Compute depths depths <- depth.FM(fd)  # Create histogram library(ggplot2) df_depths <- data.frame(   curve = 1:n,   depth = depths,   type = ifelse(1:n %in% c(1, 2, 3), \"Outlier\", \"Normal\") )  ggplot(df_depths, aes(x = depth, fill = type)) +   geom_histogram(bins = 10, alpha = 0.7, position = \"identity\") +   labs(title = \"Distribution of Functional Depths\",        x = \"Depth\", y = \"Count\", fill = \"\") +   theme_minimal()"},{"path":"https://sipemu.github.io/fdars/articles/outlier-detection.html","id":"performance","dir":"Articles","previous_headings":"","what":"Performance","title":"Outlier Detection","text":"LRT method uses parallel Rust backend speed:","code":"# Benchmark with larger dataset X_large <- matrix(rnorm(200 * 100), 200, 100) fd_large <- fdata(X_large)  system.time(outliers.lrt(fd_large, nb = 200, seed = 123)) #>    user  system elapsed #>   0.456   0.000   0.123"},{"path":"https://sipemu.github.io/fdars/articles/outlier-detection.html","id":"outliergram-and-ms-plot","dir":"Articles","previous_headings":"","what":"Outliergram and MS-Plot","title":"Outlier Detection","text":"visual outlier detection, use outliergram (MEI vs MBD) MS-plot (Magnitude vs Shape outlyingness):","code":"# Outliergram og <- outliergram(fd) plot(og) # Magnitude-Shape outlier detection ms <- magnitudeshape(fd) plot(ms)"},{"path":"https://sipemu.github.io/fdars/articles/outlier-detection.html","id":"labeling-outliers-by-id-or-metadata","dir":"Articles","previous_headings":"Outliergram and MS-Plot","what":"Labeling Outliers by ID or Metadata","title":"Outlier Detection","text":"fdata IDs metadata, can label outliers plots:","code":"# Create fdata with IDs and metadata meta <- data.frame(   subject = paste0(\"S\", sprintf(\"%02d\", 1:n)),   group = rep(c(\"A\", \"B\"), length.out = n) ) fd_labeled <- fdata(X, argvals = t_grid,                     id = paste0(\"patient_\", 1:n),                     metadata = meta)  # Outliergram with patient IDs og_labeled <- outliergram(fd_labeled) plot(og_labeled, label = \"id\") # Or with metadata column plot(og_labeled, label = \"subject\") # Label ALL points, not just outliers plot(og_labeled, label = \"id\", label_all = TRUE) # magnitudeshape with custom labels magnitudeshape(fd_labeled, label = \"subject\")"},{"path":[]},{"path":"https://sipemu.github.io/fdars/articles/outlier-detection.html","id":"best-practices","dir":"Articles","previous_headings":"","what":"Best Practices","title":"Outlier Detection","text":"Start visualization: Plot data understand outlier types Try multiple methods: Different methods catch different outliers Use sufficient bootstrap samples: least 100 stable results Consider domain knowledge: ‚Äúoutliers‚Äù may valid observations Validate findings: Check detected outliers make sense contextually","code":""},{"path":"https://sipemu.github.io/fdars/articles/outlier-detection.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Outlier Detection","text":"Febrero, M., Galeano, P., Gonz√°lez-Manteiga, W. (2008). Outlier detection functional data depth measures, application identify abnormal NOx levels. Environmetrics, 19(4), 331-345. Hyndman, R.J. Shang, H.L. (2010). Rainbow plots, bagplots, boxplots functional data. Journal Computational Graphical Statistics, 19(1), 29-45.","code":""},{"path":"https://sipemu.github.io/fdars/articles/regression.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Functional Regression","text":"Functional regression extends classical regression handle functional predictors responses. common setting scalar--function regression, scalar response YY predicted functional predictor X(t)X(t).","code":""},{"path":"https://sipemu.github.io/fdars/articles/regression.html","id":"the-functional-linear-model","dir":"Articles","previous_headings":"Introduction","what":"The Functional Linear Model","title":"Functional Regression","text":"foundational model functional regression functional linear model: Yi=Œ±+‚à´ùíØŒ≤(t)Xi(t)dt+œµiY_i = \\alpha + \\int_{\\mathcal{T}} \\beta(t) X_i(t) \\, dt + \\epsilon_i : YiY_i scalar response observation ii Xi(t)X_i(t) functional predictor observed domain ùíØ\\mathcal{T} Œ±\\alpha intercept Œ≤(t)\\beta(t) coefficient function (unknown, estimated) œµi‚àºN(0,œÉ2)\\epsilon_i \\sim N(0, \\sigma^2) ..d. errors integral ‚à´Œ≤(t)Xi(t)dt\\int \\beta(t) X_i(t) \\, dt can interpreted weighted average functional predictor, Œ≤(t)\\beta(t) determines importance time point tt predicting YY.","code":""},{"path":"https://sipemu.github.io/fdars/articles/regression.html","id":"the-estimation-challenge","dir":"Articles","previous_headings":"Introduction","what":"The Estimation Challenge","title":"Functional Regression","text":"Unlike classical regression estimate finite number parameters, must estimate entire function Œ≤(t)\\beta(t). ill-posed inverse problem: infinitely many solutions may exist, small changes data can lead large changes estimate. fdars provides three main approaches regularize problem: Principal Component Regression (fregre.pc) ‚Äî dimension reduction via FPCA Basis Expansion Regression (fregre.basis) ‚Äî represent Œ≤(t)\\beta(t) finite basis Nonparametric Regression (fregre.np) ‚Äî make parametric assumptions","code":"library(fdars) #>  #> Attaching package: 'fdars' #> The following objects are masked from 'package:stats': #>  #>     cov, deriv, median, sd, var #> The following object is masked from 'package:base': #>  #>     norm library(ggplot2) theme_set(theme_minimal())  # Generate example data set.seed(42) n <- 100 m <- 50 t_grid <- seq(0, 1, length.out = m)  # Functional predictors X <- matrix(0, n, m) for (i in 1:n) {   X[i, ] <- sin(2 * pi * t_grid) * rnorm(1, 1, 0.3) +             cos(4 * pi * t_grid) * rnorm(1, 0, 0.2) +             rnorm(m, sd = 0.1) }  fd <- fdata(X, argvals = t_grid)  # True coefficient function beta_true <- sin(2 * pi * t_grid)  # Generate response: Y = integral(beta * X) + noise y <- numeric(n) for (i in 1:n) {   y[i] <- sum(beta_true * X[i, ]) / m + rnorm(1, sd = 0.5) }  plot(fd)"},{"path":"https://sipemu.github.io/fdars/articles/regression.html","id":"principal-component-regression","dir":"Articles","previous_headings":"","what":"Principal Component Regression","title":"Functional Regression","text":"Principal component regression (PCR) reduces infinite-dimensional problem finite-dimensional one projecting functional data onto principal components.","code":""},{"path":"https://sipemu.github.io/fdars/articles/regression.html","id":"mathematical-formulation","dir":"Articles","previous_headings":"Principal Component Regression","what":"Mathematical Formulation","title":"Functional Regression","text":"Using functional principal component analysis (FPCA), curve can represented : Xi(t)=X‚Äæ(t)+‚àëk=1‚àûŒæikœïk(t)X_i(t) = \\bar{X}(t) + \\sum_{k=1}^{\\infty} \\xi_{ik} \\phi_k(t) œïk(t)\\phi_k(t) eigenfunctions (principal components) Œæik=‚à´(Xi(t)‚àíX‚Äæ(t))œïk(t)dt\\xi_{ik} = \\int (X_i(t) - \\bar{X}(t)) \\phi_k(t) \\, dt PC scores. Truncating KK components substituting functional linear model gives: Yi=Œ±+‚àëk=1KŒ≥kŒæik+œµiY_i = \\alpha + \\sum_{k=1}^{K} \\gamma_k \\xi_{ik} + \\epsilon_i Œ≥k=‚à´Œ≤(t)œïk(t)dt\\gamma_k = \\int \\beta(t) \\phi_k(t) \\, dt. now standard multiple linear regression predictors Œæi1,‚Ä¶,ŒæiK\\xi_{i1}, \\ldots, \\xi_{iK}. coefficient function reconstructed : Œ≤ÃÇ(t)=‚àëk=1KŒ≥ÃÇkœïk(t)\\hat{\\beta}(t) = \\sum_{k=1}^{K} \\hat{\\gamma}_k \\phi_k(t)","code":""},{"path":"https://sipemu.github.io/fdars/articles/regression.html","id":"choosing-the-number-of-components","dir":"Articles","previous_headings":"Principal Component Regression","what":"Choosing the Number of Components","title":"Functional Regression","text":"key tuning parameter KK, number principal components: : underfitting, missing important variation X(t)X(t) many: overfitting, including noise components Cross-validation information criteria (AIC, BIC) can guide choice.","code":""},{"path":"https://sipemu.github.io/fdars/articles/regression.html","id":"basic-usage","dir":"Articles","previous_headings":"Principal Component Regression","what":"Basic Usage","title":"Functional Regression","text":"","code":"# Fit PC regression with 3 components fit_pc <- fregre.pc(fd, y, ncomp = 3) print(fit_pc) #> Functional regression model #>   Number of observations: 100  #>   R-squared: 0.1682634"},{"path":"https://sipemu.github.io/fdars/articles/regression.html","id":"examining-the-fit","dir":"Articles","previous_headings":"Principal Component Regression","what":"Examining the Fit","title":"Functional Regression","text":"","code":"# Fitted values fitted_pc <- fit_pc$fitted.values  # Residuals residuals_pc <- y - fitted_pc  # R-squared r2_pc <- 1 - sum(residuals_pc^2) / sum((y - mean(y))^2) cat(\"R-squared:\", round(r2_pc, 3), \"\\n\") #> R-squared: 0.168"},{"path":"https://sipemu.github.io/fdars/articles/regression.html","id":"cross-validation-for-component-selection","dir":"Articles","previous_headings":"Principal Component Regression","what":"Cross-Validation for Component Selection","title":"Functional Regression","text":"","code":"# Find optimal number of components cv_pc <- fregre.pc.cv(fd, y, kmax = 10)  cat(\"Optimal number of components:\", cv_pc$ncomp.opt, \"\\n\") #> Optimal number of components: cat(\"CV error by component:\\n\") #> CV error by component: print(round(cv_pc$cv.error, 4)) #>      1      2      3      4      5      6      7      8      9     10     11  #> 0.2674 0.2700 0.2720 0.2735 0.2785 0.2735 0.2691 0.2718 0.2728 0.2744 0.2735  #>     12     13     14     15  #> 0.2746 0.2714 0.2703 0.2746"},{"path":"https://sipemu.github.io/fdars/articles/regression.html","id":"prediction","dir":"Articles","previous_headings":"Principal Component Regression","what":"Prediction","title":"Functional Regression","text":"","code":"# Split data train_idx <- 1:80 test_idx <- 81:100  fd_train <- fd[train_idx, ] fd_test <- fd[test_idx, ] y_train <- y[train_idx] y_test <- y[test_idx]  # Fit on training data fit_train <- fregre.pc(fd_train, y_train, ncomp = 3)  # Predict on test data y_pred <- predict(fit_train, fd_test)  # Evaluate cat(\"Test RMSE:\", round(pred.RMSE(y_test, y_pred), 3), \"\\n\") #> Test RMSE: 0.457 cat(\"Test R2:\", round(pred.R2(y_test, y_pred), 3), \"\\n\") #> Test R2: 0.219"},{"path":"https://sipemu.github.io/fdars/articles/regression.html","id":"basis-expansion-regression","dir":"Articles","previous_headings":"","what":"Basis Expansion Regression","title":"Functional Regression","text":"Basis expansion regression represents functional predictor X(t)X(t) coefficient function Œ≤(t)\\beta(t) using finite set basis functions, reducing infinite-dimensional problem finite-dimensional one.","code":""},{"path":"https://sipemu.github.io/fdars/articles/regression.html","id":"mathematical-formulation-1","dir":"Articles","previous_headings":"Basis Expansion Regression","what":"Mathematical Formulation","title":"Functional Regression","text":"Let {Bj(t)}j=1J\\{B_j(t)\\}_{j=1}^{J} set basis functions (e.g., B-splines Fourier). expand: Xi(t)=‚àëj=1JcijBj(t)andŒ≤(t)=‚àëj=1JbjBj(t)X_i(t) = \\sum_{j=1}^{J} c_{ij} B_j(t) \\quad \\text{} \\quad \\beta(t) = \\sum_{j=1}^{J} b_j B_j(t) Substituting functional linear model: Yi=Œ±+‚à´(‚àëj=1JbjBj(t))(‚àëk=1JcikBk(t))dt+œµiY_i = \\alpha + \\int \\left(\\sum_{j=1}^{J} b_j B_j(t)\\right) \\left(\\sum_{k=1}^{J} c_{ik} B_k(t)\\right) dt + \\epsilon_i simplifies : Yi=Œ±+ùêúi‚ä§ùêñùêõ+œµiY_i = \\alpha + \\mathbf{c}_i^\\top \\mathbf{W} \\mathbf{b} + \\epsilon_i ùêúi=(ci1,‚Ä¶,ciJ)‚ä§\\mathbf{c}_i = (c_{i1}, \\ldots, c_{iJ})^\\top basis coefficients Xi(t)X_i(t), ùêõ=(b1,‚Ä¶,bJ)‚ä§\\mathbf{b} = (b_1, \\ldots, b_J)^\\top unknown coefficients Œ≤(t)\\beta(t), ùêñ\\mathbf{W} inner product matrix entries Wjk=‚à´Bj(t)Bk(t)dtW_{jk} = \\int B_j(t) B_k(t) \\, dt.","code":""},{"path":"https://sipemu.github.io/fdars/articles/regression.html","id":"ridge-regularization","dir":"Articles","previous_headings":"Basis Expansion Regression","what":"Ridge Regularization","title":"Functional Regression","text":"prevent overfitting (especially many basis functions), add roughness penalty. penalized least squares objective : minŒ±,ùêõ‚àë=1n(Yi‚àíŒ±‚àíùêúi‚ä§ùêñùêõ)2+Œª‚à´[Œ≤‚Ä≥(t)]2dt\\min_{\\alpha, \\mathbf{b}} \\sum_{=1}^{n} \\left(Y_i - \\alpha - \\mathbf{c}_i^\\top \\mathbf{W} \\mathbf{b}\\right)^2 + \\lambda \\int \\left[\\beta''(t)\\right]^2 dt penalty ‚à´[Œ≤‚Ä≥(t)]2dt\\int [\\beta''(t)]^2 dt discourages rapid oscillations. matrix form: minŒ±,ùêõ‚à•ùêò‚àíŒ±ùüè‚àíùêÇùêñùêõ‚à•2+Œªùêõ‚ä§ùêëùêõ\\min_{\\alpha, \\mathbf{b}} \\|\\mathbf{Y} - \\alpha \\mathbf{1} - \\mathbf{C}\\mathbf{W}\\mathbf{b}\\|^2 + \\lambda \\mathbf{b}^\\top \\mathbf{R} \\mathbf{b} ùêë\\mathbf{R} roughness penalty matrix Rjk=‚à´Bj‚Ä≥(t)Bk‚Ä≥(t)dtR_{jk} = \\int B_j''(t) B_k''(t) \\, dt. solution : ùêõÃÇ=(ùêñ‚ä§ùêÇ‚ä§ùêÇùêñ+Œªùêë)‚àí1ùêñ‚ä§ùêÇ‚ä§(ùêò‚àíY‚Äæ)\\hat{\\mathbf{b}} = \\left(\\mathbf{W}^\\top \\mathbf{C}^\\top \\mathbf{C} \\mathbf{W} + \\lambda \\mathbf{R}\\right)^{-1} \\mathbf{W}^\\top \\mathbf{C}^\\top (\\mathbf{Y} - \\bar{Y})","code":""},{"path":"https://sipemu.github.io/fdars/articles/regression.html","id":"basis-choice","dir":"Articles","previous_headings":"Basis Expansion Regression","what":"Basis Choice","title":"Functional Regression","text":"B-splines: Flexible, local support, good non-periodic data Fourier: Natural periodic data, global support","code":""},{"path":"https://sipemu.github.io/fdars/articles/regression.html","id":"basic-usage-1","dir":"Articles","previous_headings":"Basis Expansion Regression","what":"Basic Usage","title":"Functional Regression","text":"","code":"# Fit basis regression with 15 B-spline basis functions fit_basis <- fregre.basis(fd, y, nbasis = 15, type = \"bspline\") print(fit_basis) #> Functional regression model #>   Number of observations: 100  #>   R-squared: -4.470287"},{"path":"https://sipemu.github.io/fdars/articles/regression.html","id":"regularization","dir":"Articles","previous_headings":"Basis Expansion Regression","what":"Regularization","title":"Functional Regression","text":"lambda parameter controls regularization:","code":"# Higher lambda = more regularization fit_basis_reg <- fregre.basis(fd, y, nbasis = 15, type = \"bspline\", lambda = 1)"},{"path":"https://sipemu.github.io/fdars/articles/regression.html","id":"cross-validation-for-lambda","dir":"Articles","previous_headings":"Basis Expansion Regression","what":"Cross-Validation for Lambda","title":"Functional Regression","text":"","code":"# Find optimal lambda cv_basis <- fregre.basis.cv(fd, y, nbasis = 15, type = \"bspline\",                             lambda = c(0, 0.001, 0.01, 0.1, 1, 10))  cat(\"Optimal lambda:\", cv_basis$lambda.opt, \"\\n\") #> Optimal lambda: cat(\"CV error by lambda:\\n\") #> CV error by lambda: print(round(cv_basis$cv.error, 4)) #>       0   0.001    0.01     0.1       1      10  #> 30.0456  0.5926  0.5605  0.4299  0.3209  0.2977"},{"path":"https://sipemu.github.io/fdars/articles/regression.html","id":"fourier-basis","dir":"Articles","previous_headings":"Basis Expansion Regression","what":"Fourier Basis","title":"Functional Regression","text":"periodic data, use Fourier basis:","code":"fit_fourier <- fregre.basis(fd, y, nbasis = 11, type = \"fourier\")"},{"path":"https://sipemu.github.io/fdars/articles/regression.html","id":"nonparametric-regression","dir":"Articles","previous_headings":"","what":"Nonparametric Regression","title":"Functional Regression","text":"Nonparametric functional regression makes parametric assumptions relationship X(t)X(t) YY. Instead, estimates ùîº[Y|X=x]\\mathbb{E}[Y | X = x] directly using local averaging techniques.","code":""},{"path":"https://sipemu.github.io/fdars/articles/regression.html","id":"the-general-framework","dir":"Articles","previous_headings":"Nonparametric Regression","what":"The General Framework","title":"Functional Regression","text":"Given new functional observation X*X^*, predicted response : YÃÇ*=mÃÇ(X*)=‚àë=1nwi(X*)Yi\\hat{Y}^* = \\hat{m}(X^*) = \\sum_{=1}^{n} w_i(X^*) Y_i wi(X*)w_i(X^*) weights depend ‚Äúdistance‚Äù X*X^* training curves XiX_i. Different methods define weights differently.","code":""},{"path":"https://sipemu.github.io/fdars/articles/regression.html","id":"functional-distance","dir":"Articles","previous_headings":"Nonparametric Regression","what":"Functional Distance","title":"Functional Regression","text":"key component semimetric d(Xi,Xj)d(X_i, X_j) measuring similarity curves. Common choices: L2L^2 metric: d(Xi,Xj)=‚à´[Xi(t)‚àíXj(t)]2dtd(X_i, X_j) = \\sqrt{\\int [X_i(t) - X_j(t)]^2 \\, dt} LpL^p metric: d(Xi,Xj)=(‚à´|Xi(t)‚àíXj(t)|pdt)1/pd(X_i, X_j) = \\left(\\int |X_i(t) - X_j(t)|^p \\, dt\\right)^{1/p} PCA-based semimetric: d(Xi,Xj)=‚àëk=1K(Œæik‚àíŒæjk)2d(X_i, X_j) = \\sqrt{\\sum_{k=1}^{K} (\\xi_{ik} - \\xi_{jk})^2} using PC scores","code":""},{"path":"https://sipemu.github.io/fdars/articles/regression.html","id":"nadaraya-watson-estimator","dir":"Articles","previous_headings":"Nonparametric Regression","what":"Nadaraya-Watson Estimator","title":"Functional Regression","text":"Nadaraya-Watson (kernel regression) estimator uses: mÃÇ(X*)=‚àë=1nK(d(X*,Xi)h)Yi‚àë=1nK(d(X*,Xi)h)\\hat{m}(X^*) = \\frac{\\sum_{=1}^{n} K\\left(\\frac{d(X^*, X_i)}{h}\\right) Y_i}{\\sum_{=1}^{n} K\\left(\\frac{d(X^*, X_i)}{h}\\right)} K(‚ãÖ)K(\\cdot) kernel function h>0h > 0 bandwidth controlling smoothness: Small hh: weights concentrated nearest neighbors (low bias, high variance) Large hh: weights spread across many observations (high bias, low variance) Common kernels include:","code":""},{"path":"https://sipemu.github.io/fdars/articles/regression.html","id":"k-nearest-neighbors","dir":"Articles","previous_headings":"Nonparametric Regression","what":"k-Nearest Neighbors","title":"Functional Regression","text":"k-NN estimator averages responses kk closest curves: mÃÇ(X*)=1k‚àë‚ààùí©k(X*)Yi\\hat{m}(X^*) = \\frac{1}{k} \\sum_{\\\\mathcal{N}_k(X^*)} Y_i ùí©k(X*)\\mathcal{N}_k(X^*) set indices kk nearest neighbors X*X^*. Two variants available: Global k-NN (kNN.gCV): single kk selected leave-one-cross-validation Local k-NN (kNN.lCV): adaptive kk may vary per prediction point","code":""},{"path":"https://sipemu.github.io/fdars/articles/regression.html","id":"nadaraya-watson-example","dir":"Articles","previous_headings":"Nonparametric Regression","what":"Nadaraya-Watson Example","title":"Functional Regression","text":"","code":"# Fit nonparametric regression with Nadaraya-Watson fit_np <- fregre.np(fd, y, type.S = \"S.NW\") print(fit_np) #> Nonparametric functional regression model #>   Number of observations: 100  #>   Smoother type: S.NW  #>   Bandwidth: 0.3302789  #>   R-squared: 0.0552"},{"path":"https://sipemu.github.io/fdars/articles/regression.html","id":"k-nearest-neighbors-1","dir":"Articles","previous_headings":"Nonparametric Regression","what":"k-Nearest Neighbors","title":"Functional Regression","text":"Two flavors k-NN available:","code":"# Global k-NN (single k for all observations) fit_knn_global <- fregre.np(fd, y, type.S = \"kNN.gCV\")  # Local k-NN (adaptive k per observation) fit_knn_local <- fregre.np(fd, y, type.S = \"kNN.lCV\")  cat(\"Global k-NN optimal k:\", fit_knn_global$knn, \"\\n\") #> Global k-NN optimal k: 20"},{"path":"https://sipemu.github.io/fdars/articles/regression.html","id":"bandwidth-selection","dir":"Articles","previous_headings":"Nonparametric Regression","what":"Bandwidth Selection","title":"Functional Regression","text":"","code":"# Cross-validation for bandwidth cv_np <- fregre.np.cv(fd, y, h.seq = seq(0.1, 1, by = 0.1))  cat(\"Optimal bandwidth:\", cv_np$h.opt, \"\\n\") #> Optimal bandwidth:"},{"path":"https://sipemu.github.io/fdars/articles/regression.html","id":"different-kernels","dir":"Articles","previous_headings":"Nonparametric Regression","what":"Different Kernels","title":"Functional Regression","text":"","code":"# Epanechnikov kernel fit_epa <- fregre.np(fd, y, Ker = \"epa\")  # Available kernels: \"norm\", \"epa\", \"tri\", \"quar\", \"cos\", \"unif\""},{"path":"https://sipemu.github.io/fdars/articles/regression.html","id":"different-metrics","dir":"Articles","previous_headings":"Nonparametric Regression","what":"Different Metrics","title":"Functional Regression","text":"","code":"# Use L1 metric instead of default L2 fit_np_l1 <- fregre.np(fd, y, metric = metric.lp, p = 1)  # Use semimetric based on PCA fit_np_pca <- fregre.np(fd, y, metric = semimetric.pca, ncomp = 5)"},{"path":"https://sipemu.github.io/fdars/articles/regression.html","id":"comparing-methods","dir":"Articles","previous_headings":"","what":"Comparing Methods","title":"Functional Regression","text":"","code":"# Fit all methods on training data fit1 <- fregre.pc(fd_train, y_train, ncomp = 3) fit2 <- fregre.basis(fd_train, y_train, nbasis = 15) fit3 <- fregre.np(fd_train, y_train, type.S = \"kNN.gCV\")  # Predict on test data pred1 <- predict(fit1, fd_test) pred2 <- predict(fit2, fd_test) pred3 <- predict(fit3, fd_test)  # Compare performance results <- data.frame(   Method = c(\"PC Regression\", \"Basis Regression\", \"k-NN\"),   RMSE = c(pred.RMSE(y_test, pred1),            pred.RMSE(y_test, pred2),            pred.RMSE(y_test, pred3)),   R2 = c(pred.R2(y_test, pred1),          pred.R2(y_test, pred2),          pred.R2(y_test, pred3)) ) print(results) #>             Method      RMSE          R2 #> 1    PC Regression 0.4570245  0.21884391 #> 2 Basis Regression 1.6993189 -9.79962564 #> 3             k-NN 0.4935318  0.08906132"},{"path":"https://sipemu.github.io/fdars/articles/regression.html","id":"visualizing-predictions","dir":"Articles","previous_headings":"","what":"Visualizing Predictions","title":"Functional Regression","text":"","code":"# Create comparison data frame df_pred <- data.frame(   Observed = y_test,   PC = pred1,   Basis = pred2,   kNN = pred3 )  # Observed vs predicted ggplot(df_pred, aes(x = Observed, y = PC)) +   geom_point() +   geom_abline(intercept = 0, slope = 1, linetype = \"dashed\", color = \"red\") +   labs(title = \"PC Regression: Observed vs Predicted\",        x = \"Observed\", y = \"Predicted\") +   theme_minimal()"},{"path":[]},{"path":"https://sipemu.github.io/fdars/articles/regression.html","id":"when-to-use-each-method","dir":"Articles","previous_headings":"Method Selection Guide","what":"When to Use Each Method","title":"Functional Regression","text":"Principal Component Regression (fregre.pc): Best functional predictor clear dominant modes variation Computationally efficient large datasets Interpretable: PC represents pattern data Use nn small relative complexity X(t)X(t) Basis Expansion Regression (fregre.basis): Best believe Œ≤(t)\\beta(t) smooth Use B-splines local features, Fourier periodic patterns penalty parameter Œª\\lambda provides automatic regularization Good want visualize interpret Œ≤ÃÇ(t)\\hat{\\beta}(t) Nonparametric Regression (fregre.np): Best relationship XX YY may nonlinear Makes minimal assumptions data-generating process Computationally expensive (requires distance calculations) May require larger sample sizes stable estimation","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/articles/regression.html","id":"prediction-metrics","dir":"Articles","previous_headings":"","what":"Prediction Metrics","title":"Functional Regression","text":"Model performance evaluated using standard regression metrics. Given observed values y1,‚Ä¶,yny_1, \\ldots, y_n predictions yÃÇ1,‚Ä¶,yÃÇn\\hat{y}_1, \\ldots, \\hat{y}_n:","code":"# Available metrics for model evaluation cat(\"MAE:\", pred.MAE(y_test, pred1), \"\\n\") #> MAE: 0.3819577 cat(\"MSE:\", pred.MSE(y_test, pred1), \"\\n\") #> MSE: 0.2088714 cat(\"RMSE:\", pred.RMSE(y_test, pred1), \"\\n\") #> RMSE: 0.4570245 cat(\"R2:\", pred.R2(y_test, pred1), \"\\n\") #> R2: 0.2188439"},{"path":"https://sipemu.github.io/fdars/articles/regression.html","id":"cross-validation","dir":"Articles","previous_headings":"Prediction Metrics","what":"Cross-Validation","title":"Functional Regression","text":"methods support leave-one-cross-validation (LOOCV) parameter selection: CV=1n‚àë=1n(Yi‚àíYÃÇ‚àí)2\\text{CV} = \\frac{1}{n} \\sum_{=1}^{n} (Y_i - \\hat{Y}_{-})^2 YÃÇ‚àí\\hat{Y}_{-} prediction observation ii left training set. implemented efficiently using ‚Äúhat matrix trick‚Äù linear methods.","code":""},{"path":"https://sipemu.github.io/fdars/articles/regression.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Functional Regression","text":"Foundational texts: Ramsay, J.O. Silverman, B.W. (2005). Functional Data Analysis, 2nd ed.¬†Springer. Ferraty, F. Vieu, P. (2006). Nonparametric Functional Data Analysis: Theory Practice. Springer. Horv√°th, L. Kokoszka, P. (2012). Inference Functional Data Applications. Springer. Key methodological papers: Cardot, H., Ferraty, F., Sarda, P. (1999). Functional Linear Model. Statistics & Probability Letters, 45(1), 11-22. Reiss, P.T. Ogden, R.T. (2007). Functional Principal Component Regression Functional Partial Least Squares. Journal American Statistical Association, 102(479), 984-996. Goldsmith, J., Bobb, J., Crainiceanu, C., Caffo, B., Reich, D. (2011). Penalized Functional Regression. Journal Computational Graphical Statistics, 20(4), 830-851. nonparametric functional regression: Ferraty, F., Laksaci, ., Vieu, P. (2006). Estimating Characteristics Conditional Distribution Nonparametric Functional Models. Statistical Inference Stochastic Processes, 9, 47-76.","code":""},{"path":"https://sipemu.github.io/fdars/articles/seasonal-analysis.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Seasonal Analysis of Functional Data","text":"Seasonal patterns ubiquitous functional data: temperature cycles, biological rhythms, economic fluctuations, many . vignette demonstrates seasonal analysis capabilities fdars, organized basic period estimation advanced techniques complex signals. ‚Äôll learn: estimate period seasonal signals detect multiple concurrent seasonalities tune peak detection parameters noisy data use instantaneous period estimation () analyze short series 3-5 cycles","code":"library(fdars) #>  #> Attaching package: 'fdars' #> The following objects are masked from 'package:stats': #>  #>     cov, deriv, median, sd, var #> The following object is masked from 'package:base': #>  #>     norm library(ggplot2) theme_set(theme_minimal()) set.seed(42)"},{"path":"https://sipemu.github.io/fdars/articles/seasonal-analysis.html","id":"estimating-seasonal-period","dir":"Articles","previous_headings":"","what":"Estimating Seasonal Period","title":"Seasonal Analysis of Functional Data","text":"first step seasonal analysis often determining period. fdars provides two methods: FFT (frequency domain) ACF (autocorrelation).","code":""},{"path":"https://sipemu.github.io/fdars/articles/seasonal-analysis.html","id":"simple-periodic-signals","dir":"Articles","previous_headings":"Estimating Seasonal Period","what":"Simple Periodic Signals","title":"Seasonal Analysis of Functional Data","text":"Let‚Äôs start clean sinusoidal signal.  confidence value indicates pronounced dominant frequency relative frequencies. High confidence (close 1) means clear, dominant period.","code":"# Time grid: 10 complete cycles of period 2 t <- seq(0, 20, length.out = 400) period_true <- 2  # Pure sine wave X_pure <- sin(2 * pi * t / period_true) fd_pure <- fdata(matrix(X_pure, nrow = 1), argvals = t)  # Plot df <- data.frame(t = t, y = X_pure) ggplot(df, aes(x = t, y = y)) +   geom_line(color = \"steelblue\") +   labs(title = \"Pure Seasonal Signal (Period = 2)\", x = \"Time\", y = \"Value\") # FFT method est_fft <- estimate_period(fd_pure, method = \"fft\") cat(\"FFT estimate:\", est_fft$period, \"(true:\", period_true, \")\\n\") #> FFT estimate: 2.005013 (true: 2 ) cat(\"Confidence:\", round(est_fft$confidence, 3), \"\\n\") #> Confidence: 199.585"},{"path":"https://sipemu.github.io/fdars/articles/seasonal-analysis.html","id":"noisy-signals","dir":"Articles","previous_headings":"Estimating Seasonal Period","what":"Noisy Signals","title":"Seasonal Analysis of Functional Data","text":"Real data always contains noise. Let‚Äôs see methods handle .  methods typically agree clean periodic signals. ACF method can robust certain types noise, FFT faster handles multiple harmonics well.","code":"# Add noise X_noisy <- sin(2 * pi * t / period_true) + rnorm(length(t), sd = 0.3) fd_noisy <- fdata(matrix(X_noisy, nrow = 1), argvals = t)  df <- data.frame(t = t, y = X_noisy) ggplot(df, aes(x = t, y = y)) +   geom_line(color = \"steelblue\", alpha = 0.7) +   labs(title = \"Noisy Seasonal Signal (SD = 0.3)\", x = \"Time\", y = \"Value\") # Compare methods est_fft_noisy <- estimate_period(fd_noisy, method = \"fft\") est_acf <- estimate_period(fd_noisy, method = \"acf\")  cat(\"True period:\", period_true, \"\\n\") #> True period: 2 cat(\"FFT estimate:\", est_fft_noisy$period, \"(confidence:\", round(est_fft_noisy$confidence, 3), \")\\n\") #> FFT estimate: 2.005013 (confidence: 171.93 ) cat(\"ACF estimate:\", est_acf$period, \"(confidence:\", round(est_acf$confidence, 3), \")\\n\") #> ACF estimate: 2.005013 (confidence: 0.783 )"},{"path":"https://sipemu.github.io/fdars/articles/seasonal-analysis.html","id":"signals-with-multiple-harmonics","dir":"Articles","previous_headings":"Estimating Seasonal Period","what":"Signals with Multiple Harmonics","title":"Seasonal Analysis of Functional Data","text":"Real seasonal patterns often harmonics (e.g., yearly + half-yearly components share fundamental period).  FFT method correctly identifies fundamental period, even harmonics present. harmonics share fundamental frequency, reinforce estimate.","code":"# Signal with 2nd and 3rd harmonics X_multi <- sin(2 * pi * t / period_true) +            0.3 * sin(4 * pi * t / period_true) +  # 2nd harmonic            0.1 * sin(6 * pi * t / period_true) +  # 3rd harmonic            rnorm(length(t), sd = 0.1) fd_multi <- fdata(matrix(X_multi, nrow = 1), argvals = t)  df <- data.frame(t = t, y = X_multi) ggplot(df, aes(x = t, y = y)) +   geom_line(color = \"steelblue\") +   labs(title = \"Signal with Multiple Harmonics\", x = \"Time\", y = \"Value\") est_multi <- estimate_period(fd_multi, method = \"fft\") cat(\"Estimated period:\", est_multi$period, \"(true:\", period_true, \")\\n\") #> Estimated period: 2.005013 (true: 2 )"},{"path":"https://sipemu.github.io/fdars/articles/seasonal-analysis.html","id":"detecting-multiple-concurrent-seasonalities","dir":"Articles","previous_headings":"","what":"Detecting Multiple Concurrent Seasonalities","title":"Seasonal Analysis of Functional Data","text":"Sometimes signal contains multiple independent periodicities (e.g., daily yearly cycles). estimate_period() function returns dominant period. ‚Äôs detect multiple periods.","code":""},{"path":"https://sipemu.github.io/fdars/articles/seasonal-analysis.html","id":"why-estimate_period-returns-only-one-period","dir":"Articles","previous_headings":"Detecting Multiple Concurrent Seasonalities","what":"Why estimate_period() Returns Only One Period","title":"Seasonal Analysis of Functional Data","text":"","code":"# Signal with two independent periods period1 <- 2   # Fast cycle period2 <- 7   # Slow cycle  X_dual <- sin(2 * pi * t / period1) + 0.6 * sin(2 * pi * t / period2) fd_dual <- fdata(matrix(X_dual, nrow = 1), argvals = t)  df <- data.frame(t = t, y = X_dual) ggplot(df, aes(x = t, y = y)) +   geom_line(color = \"steelblue\") +   labs(title = \"Signal with Two Periods (2 and 7)\",        x = \"Time\", y = \"Value\") est_single <- estimate_period(fd_dual, method = \"fft\") cat(\"Single estimate:\", est_single$period, \"\\n\") #> Single estimate: 2.005013 cat(\"(Only detects the dominant period)\\n\") #> (Only detects the dominant period)"},{"path":"https://sipemu.github.io/fdars/articles/seasonal-analysis.html","id":"iterative-residual-approach","dir":"Articles","previous_headings":"Detecting Multiple Concurrent Seasonalities","what":"Iterative Residual Approach","title":"Seasonal Analysis of Functional Data","text":"find multiple periods, can iteratively: 1. Estimate dominant period 2. Subtract fitted sinusoid period 3. Repeat residual","code":"# Helper function to detect multiple periods # Uses both FFT confidence AND seasonal strength as stopping criteria detect_multiple_periods <- function(fd, max_periods = 3, min_confidence = 0.4,                                      min_strength = 0.15) {   periods <- list()   residual <- fd   original_var <- var(fd$data[1, ])    for (i in 1:max_periods) {     est <- estimate_period(residual, method = \"fft\")     if (est$confidence < min_confidence) break      # Additional check: seasonal strength at detected period     ss <- seasonal_strength(residual, period = est$period)     if (ss < min_strength) break      # Subtract fitted sinusoid from residual     tt <- fd$argvals     omega <- 2 * pi / est$period     cos_comp <- cos(omega * tt)     sin_comp <- sin(omega * tt)     y <- residual$data[1, ]     a <- 2 * mean(y * cos_comp)  # Cosine coefficient     b <- 2 * mean(y * sin_comp)  # Sine coefficient     amplitude <- sqrt(a^2 + b^2)     phase <- atan2(b, a)      periods[[i]] <- list(       period = est$period,       confidence = est$confidence,       strength = ss,       amplitude = amplitude,       phase = phase,       iteration = i     )      fitted <- a * cos_comp + b * sin_comp     residual$data <- residual$data - matrix(fitted, nrow = 1)   }   return(periods) }  # Detect multiple periods detected <- detect_multiple_periods(fd_dual, max_periods = 3) cat(\"Detected periods:\\n\") #> Detected periods: for (p in detected) {   cat(sprintf(\"  Period = %.2f (confidence = %.3f, strength = %.3f, amplitude = %.3f)\\n\",               p$period, p$confidence, p$strength, p$amplitude)) } #>   Period = 2.01 (confidence = 146.769, strength = 0.734, amplitude = 1.013) #>   Period = 6.68 (confidence = 188.230, strength = 0.949, amplitude = 0.592) #>   Period = 10.03 (confidence = 60.453, strength = 0.650, amplitude = 0.081)"},{"path":"https://sipemu.github.io/fdars/articles/seasonal-analysis.html","id":"visualizing-the-decomposition","dir":"Articles","previous_headings":"Detecting Multiple Concurrent Seasonalities","what":"Visualizing the Decomposition","title":"Seasonal Analysis of Functional Data","text":"Practical guidance: harmonics fundamental: estimate_period() correctly finds fundamental period. iterative approach needed. truly different periods (e.g., daily + yearly): use iterative approach . confidence drops threshold: stop - remaining signal likely noise. Note detection order: Periods detected order amplitude, period length. component highest FFT power (roughly proportional amplitude squared) found first. example, signal weak yearly cycle strong weekly cycle, weekly cycle detected first regardless period longer. weak periodicities (< 20% dominant amplitude) may require lower thresholds risk false positives.","code":"# Reconstruct each component components <- data.frame(t = t) residual <- X_dual for (i in seq_along(detected)) {   omega <- 2 * pi / detected[[i]]$period   cos_comp <- cos(omega * t)   sin_comp <- sin(omega * t)   a <- 2 * mean(residual * cos_comp)   b <- 2 * mean(residual * sin_comp)   component <- a * cos_comp + b * sin_comp   components[[paste0(\"Period_\", round(detected[[i]]$period, 1))]] <- component   residual <- residual - component } components$Residual <- residual components$Original <- X_dual  # Plot decomposition library(tidyr) df_long <- pivot_longer(components, -t, names_to = \"Component\", values_to = \"Value\") # Get period column names (exclude t, Residual, Original) period_cols <- setdiff(names(components), c(\"t\", \"Residual\", \"Original\")) df_long$Component <- factor(df_long$Component,                             levels = c(\"Original\", period_cols, \"Residual\"))  ggplot(df_long, aes(x = t, y = Value)) +   geom_line(color = \"steelblue\") +   facet_wrap(~Component, ncol = 1, scales = \"free_y\") +   labs(title = \"Decomposition into Periodic Components\",        x = \"Time\", y = \"Value\")"},{"path":"https://sipemu.github.io/fdars/articles/seasonal-analysis.html","id":"peak-detection","dir":"Articles","previous_headings":"","what":"Peak Detection","title":"Seasonal Analysis of Functional Data","text":"Peak detection identifies local maxima seasonal signals. useful characterizing seasonal patterns estimating period peak--peak distances.","code":""},{"path":"https://sipemu.github.io/fdars/articles/seasonal-analysis.html","id":"parameter-tuning-guide","dir":"Articles","previous_headings":"Peak Detection","what":"Parameter Tuning Guide","title":"Seasonal Analysis of Functional Data","text":"Peak detection quality depends heavily parameters. ‚Äôs reference:","code":""},{"path":"https://sipemu.github.io/fdars/articles/seasonal-analysis.html","id":"effect-of-parameters","dir":"Articles","previous_headings":"Peak Detection","what":"Effect of Parameters","title":"Seasonal Analysis of Functional Data","text":"Let‚Äôs demonstrate parameters affect detection quality.","code":"# Moderately noisy signal X_demo <- sin(2 * pi * t / period_true) + rnorm(length(t), sd = 0.4) fd_demo <- fdata(matrix(X_demo, nrow = 1), argvals = t)  df <- data.frame(t = t, y = X_demo) # Default parameters - often too many peaks peaks_default <- detect_peaks(fd_demo) cat(\"Default parameters:\", nrow(peaks_default$peaks[[1]]), \"peaks found\\n\") #> Default parameters: 91 peaks found cat(\"(Expected:\", floor(max(t) / period_true), \"peaks)\\n\") #> (Expected: 10 peaks) # Add minimum distance constraint peaks_distance <- detect_peaks(fd_demo, min_distance = period_true * 0.8) cat(\"With min_distance:\", nrow(peaks_distance$peaks[[1]]), \"peaks found\\n\") #> With min_distance: 12 peaks found # Add smoothing for best results peaks_smooth <- detect_peaks(fd_demo, min_distance = period_true * 0.8,                              smooth_first = TRUE, smooth_lambda = NULL) cat(\"With smoothing:\", nrow(peaks_smooth$peaks[[1]]), \"peaks found\\n\") #> With smoothing: 6 peaks found cat(\"Estimated period from peaks:\", round(peaks_smooth$mean_period, 3), \"\\n\") #> Estimated period from peaks: 3.649"},{"path":"https://sipemu.github.io/fdars/articles/seasonal-analysis.html","id":"visualizing-the-difference","dir":"Articles","previous_headings":"Peak Detection","what":"Visualizing the Difference","title":"Seasonal Analysis of Functional Data","text":"Key insight: real data, always use smooth_first = TRUE smooth_lambda = NULL let GCV automatically select smoothing parameter.","code":"# Prepare data for plotting df_default <- peaks_default$peaks[[1]] df_distance <- peaks_distance$peaks[[1]] df_smooth <- peaks_smooth$peaks[[1]]  # Create combined plot p1 <- ggplot(df, aes(x = t, y = y)) +   geom_line(color = \"gray50\", alpha = 0.7) +   geom_point(data = df_default, aes(x = time, y = value),              color = \"red\", size = 2) +   labs(title = paste(\"Default:\", nrow(df_default), \"peaks\"),        x = \"\", y = \"Value\")  p2 <- ggplot(df, aes(x = t, y = y)) +   geom_line(color = \"gray50\", alpha = 0.7) +   geom_point(data = df_distance, aes(x = time, y = value),              color = \"red\", size = 2) +   labs(title = paste(\"With min_distance:\", nrow(df_distance), \"peaks\"),        x = \"\", y = \"Value\")  p3 <- ggplot(df, aes(x = t, y = y)) +   geom_line(color = \"gray50\", alpha = 0.7) +   geom_point(data = df_smooth, aes(x = time, y = value),              color = \"red\", size = 2) +   labs(title = paste(\"With smoothing:\", nrow(df_smooth), \"peaks\"),        x = \"Time\", y = \"Value\")  library(gridExtra) grid.arrange(p1, p2, p3, ncol = 1)"},{"path":"https://sipemu.github.io/fdars/articles/seasonal-analysis.html","id":"prominence-filtering","dir":"Articles","previous_headings":"Peak Detection","what":"Prominence Filtering","title":"Seasonal Analysis of Functional Data","text":"Prominence measures much peak stands surrounding values. Use filter minor peaks.","code":"# Compare prominence thresholds peaks_low_prom <- detect_peaks(fd_demo, min_distance = 1.5, min_prominence = 0.1) peaks_high_prom <- detect_peaks(fd_demo, min_distance = 1.5, min_prominence = 0.5)  cat(\"Low prominence (0.1):\", nrow(peaks_low_prom$peaks[[1]]), \"peaks\\n\") #> Low prominence (0.1): 4 peaks cat(\"High prominence (0.5):\", nrow(peaks_high_prom$peaks[[1]]), \"peaks\\n\") #> High prominence (0.5): 1 peaks"},{"path":"https://sipemu.github.io/fdars/articles/seasonal-analysis.html","id":"measuring-seasonal-strength","dir":"Articles","previous_headings":"","what":"Measuring Seasonal Strength","title":"Seasonal Analysis of Functional Data","text":"Seasonal strength quantifies much signal‚Äôs variance explained seasonal component. Values range 0 (seasonality) 1 (pure seasonal signal).","code":""},{"path":"https://sipemu.github.io/fdars/articles/seasonal-analysis.html","id":"variance-vs-spectral-methods","dir":"Articles","previous_headings":"Measuring Seasonal Strength","what":"Variance vs Spectral Methods","title":"Seasonal Analysis of Functional Data","text":"","code":"ss_variance <- seasonal_strength(fd_noisy, period = period_true, method = \"variance\") ss_spectral <- seasonal_strength(fd_noisy, period = period_true, method = \"spectral\")  cat(\"Variance method:\", round(ss_variance, 3), \"\\n\") #> Variance method: 0.863 cat(\"Spectral method:\", round(ss_spectral, 3), \"\\n\") #> Spectral method: 0.893"},{"path":"https://sipemu.github.io/fdars/articles/seasonal-analysis.html","id":"comparing-different-signal-types","dir":"Articles","previous_headings":"Measuring Seasonal Strength","what":"Comparing Different Signal Types","title":"Seasonal Analysis of Functional Data","text":"","code":"# Create signals with different seasonality levels X_noise <- rnorm(length(t))  # Pure noise fd_noise <- fdata(matrix(X_noise, nrow = 1), argvals = t)  X_mixed <- 0.5 * sin(2 * pi * t / period_true) + 0.5 * rnorm(length(t)) fd_mixed <- fdata(matrix(X_mixed, nrow = 1), argvals = t)  # Calculate strengths strengths <- c(   \"Pure seasonal\" = seasonal_strength(fd_pure, period = period_true),   \"Noisy seasonal (0.3 SD)\" = seasonal_strength(fd_noisy, period = period_true),   \"Mixed (50/50)\" = seasonal_strength(fd_mixed, period = period_true),   \"Pure noise\" = seasonal_strength(fd_noise, period = period_true) )  df_strength <- data.frame(   Signal = factor(names(strengths), levels = names(strengths)),   Strength = strengths )  ggplot(df_strength, aes(x = Signal, y = Strength, fill = Signal)) +   geom_col() +   labs(title = \"Seasonal Strength Comparison\",        x = \"\", y = \"Seasonal Strength\") +   ylim(0, 1) +   theme(legend.position = \"none\",         axis.text.x = element_text(angle = 15, hjust = 1))"},{"path":"https://sipemu.github.io/fdars/articles/seasonal-analysis.html","id":"time-varying-seasonal-strength","dir":"Articles","previous_headings":"Measuring Seasonal Strength","what":"Time-Varying Seasonal Strength","title":"Seasonal Analysis of Functional Data","text":"Seasonal strength can change time. Use sliding window track .","code":"# Signal that loses seasonality t_long <- seq(0, 40, length.out = 800) X_changing <- ifelse(t_long < 20,                      sin(2 * pi * t_long / period_true) + rnorm(sum(t_long < 20), sd = 0.2),                      rnorm(sum(t_long >= 20), sd = 0.5)) fd_changing <- fdata(matrix(X_changing, nrow = 1), argvals = t_long)  # Compute time-varying strength ss_curve <- seasonal_strength_curve(fd_changing, period = period_true,                                      window_size = 4 * period_true)  # Plot both signal and strength df1 <- data.frame(t = t_long, y = X_changing, panel = \"Signal\") df2 <- data.frame(t = t_long, y = ss_curve$data[1,], panel = \"Seasonal Strength\") df_combined <- rbind(df1, df2)  ggplot(df_combined, aes(x = t, y = y)) +   geom_line(color = \"steelblue\") +   facet_wrap(~panel, ncol = 1, scales = \"free_y\") +   geom_vline(xintercept = 20, linetype = \"dashed\", color = \"red\") +   labs(title = \"Time-Varying Seasonal Strength\",        subtitle = \"Seasonality stops at t = 20 (red line)\",        x = \"Time\", y = \"\")"},{"path":"https://sipemu.github.io/fdars/articles/seasonal-analysis.html","id":"change-detection","dir":"Articles","previous_headings":"","what":"Change Detection","title":"Seasonal Analysis of Functional Data","text":"Automatically detect seasonality starts stops.","code":""},{"path":"https://sipemu.github.io/fdars/articles/seasonal-analysis.html","id":"manual-threshold","dir":"Articles","previous_headings":"Change Detection","what":"Manual Threshold","title":"Seasonal Analysis of Functional Data","text":"","code":"changes <- detect_seasonality_changes(fd_changing, period = period_true,                                        threshold = 0.3,                                        window_size = 4 * period_true,                                        min_duration = 2 * period_true) print(changes) #> Seasonality Change Detection #> ---------------------------- #> Number of changes: 1 #>  #>       time      type strength_before strength_after #> 1 20.32541 cessation       0.3027155      0.2990393"},{"path":"https://sipemu.github.io/fdars/articles/seasonal-analysis.html","id":"automatic-threshold-otsus-method","dir":"Articles","previous_headings":"Change Detection","what":"Automatic Threshold (Otsu‚Äôs Method)","title":"Seasonal Analysis of Functional Data","text":"don‚Äôt know appropriate threshold, use Otsu‚Äôs method determine automatically data.","code":"changes_auto <- detect_seasonality_changes_auto(fd_changing, period = period_true,                                                  threshold_method = \"otsu\") print(changes_auto) #> Seasonality Change Detection (Auto Threshold) #> ---------------------------------------------- #> Computed threshold: 0.4878 #> Number of changes: 1 #>  #>       time      type strength_before strength_after #> 1 19.52441 cessation       0.5462295      0.4869599"},{"path":"https://sipemu.github.io/fdars/articles/seasonal-analysis.html","id":"visualizing-change-points","dir":"Articles","previous_headings":"Change Detection","what":"Visualizing Change Points","title":"Seasonal Analysis of Functional Data","text":"","code":"df <- data.frame(t = t_long, y = X_changing)  p <- ggplot(df, aes(x = t, y = y)) +   geom_line(color = \"steelblue\", alpha = 0.7) +   labs(title = \"Seasonality Change Detection\",        x = \"Time\", y = \"Value\")  # Add change points if (nrow(changes_auto$change_points) > 0) {   for (i in 1:nrow(changes_auto$change_points)) {     cp <- changes_auto$change_points[i, ]     p <- p + geom_vline(xintercept = cp$time,                         linetype = \"dashed\",                         color = ifelse(cp$type == \"onset\", \"green4\", \"red\"),                         linewidth = 1)   }   p <- p + labs(subtitle = \"Green = onset, Red = cessation\") } print(p)"},{"path":"https://sipemu.github.io/fdars/articles/seasonal-analysis.html","id":"signals-with-varying-period","dir":"Articles","previous_headings":"","what":"Signals with Varying Period","title":"Seasonal Analysis of Functional Data","text":"signals periods drift change time. instantaneous_period() function uses Hilbert transform estimate period time point.","code":""},{"path":"https://sipemu.github.io/fdars/articles/seasonal-analysis.html","id":"when-to-use-instantaneous-period","dir":"Articles","previous_headings":"Signals with Varying Period","what":"When to Use Instantaneous Period","title":"Seasonal Analysis of Functional Data","text":"Good use cases: Slowly drifting systems (circadian rhythms shifting seasons) Frequency-modulated (FM) signals engineering Climate oscillations variable period (e.g., ENSO) Poor use cases: Random frequency jumps (use change detection instead) Multiple concurrent periodicities (use iterative approach instead) noisy short series (use peak--peak methods instead)","code":""},{"path":"https://sipemu.github.io/fdars/articles/seasonal-analysis.html","id":"chirp-signal-smoothly-increasing-frequency","dir":"Articles","previous_headings":"Signals with Varying Period","what":"Chirp Signal (Smoothly Increasing Frequency)","title":"Seasonal Analysis of Functional Data","text":"","code":"# Chirp: frequency increases linearly t_chirp <- seq(0, 10, length.out = 500) freq <- 0.5 + 0.15 * t_chirp  # Frequency increases from 0.5 to 2 phase <- 2 * pi * cumsum(freq) * diff(c(0, t_chirp)) X_chirp <- sin(phase) fd_chirp <- fdata(matrix(X_chirp, nrow = 1), argvals = t_chirp)  df <- data.frame(t = t_chirp, y = X_chirp) ggplot(df, aes(x = t, y = y)) +   geom_line(color = \"steelblue\") +   labs(title = \"Chirp Signal (Smoothly Increasing Frequency)\",        x = \"Time\", y = \"Value\") inst <- instantaneous_period(fd_chirp)  # True period (1/frequency) true_period <- 1 / freq  # Compare df <- data.frame(   t = t_chirp,   Estimated = inst$period$data[1,],   True = true_period )  # Remove extreme values at boundaries df$Estimated[df$Estimated > 5 | df$Estimated < 0] <- NA  ggplot(df, aes(x = t)) +   geom_line(aes(y = True, color = \"True\"), linewidth = 1) +   geom_line(aes(y = Estimated, color = \"Estimated\"), alpha = 0.7) +   scale_color_manual(values = c(\"True\" = \"steelblue\", \"Estimated\" = \"coral\")) +   labs(title = \"Instantaneous Period Estimation\",        x = \"Time\", y = \"Period\", color = \"\") +   ylim(0, 3)"},{"path":"https://sipemu.github.io/fdars/articles/seasonal-analysis.html","id":"amplitude-envelope-extraction","dir":"Articles","previous_headings":"Signals with Varying Period","what":"Amplitude Envelope Extraction","title":"Seasonal Analysis of Functional Data","text":"Hilbert transform also provides instantaneous amplitude (envelope), useful amplitude-modulated signals.","code":"# Amplitude-modulated signal envelope_true <- 1 + 0.5 * sin(2 * pi * t / 10)  # Slow modulation X_am <- envelope_true * sin(2 * pi * t / period_true) fd_am <- fdata(matrix(X_am, nrow = 1), argvals = t)  inst_am <- instantaneous_period(fd_am)  df <- data.frame(   t = t,   Signal = X_am,   Envelope = inst_am$amplitude$data[1,] )  ggplot(df, aes(x = t)) +   geom_line(aes(y = Signal), color = \"steelblue\", alpha = 0.7) +   geom_line(aes(y = Envelope), color = \"red\", linewidth = 1) +   geom_line(aes(y = -Envelope), color = \"red\", linewidth = 1) +   labs(title = \"Amplitude Envelope Extraction\",        subtitle = \"Red lines show the extracted envelope\",        x = \"Time\", y = \"Value\")"},{"path":"https://sipemu.github.io/fdars/articles/seasonal-analysis.html","id":"limitations-and-alternatives","dir":"Articles","previous_headings":"Signals with Varying Period","what":"Limitations and Alternatives","title":"Seasonal Analysis of Functional Data","text":"Boundary effects: Hilbert transform produces unreliable estimates near beginning end series. Noise sensitivity: High-frequency noise can corrupt period estimates. Consider smoothing first. Random frequency changes: frequency changes abruptly randomly, instantaneous period estimate becomes unreliable.  Alternative abrupt changes: Use detect_seasonality_changes() find regime boundaries, analyze segment separately.","code":"# Demonstrate limitation: signal with random frequency regime changes set.seed(123) t_rand <- seq(0, 20, length.out = 400) freq_regime <- rep(c(1, 2, 0.5, 1.5), each = 100)  # Abrupt changes X_rand <- sin(2 * pi * cumsum(freq_regime) * diff(c(0, t_rand))) fd_rand <- fdata(matrix(X_rand, nrow = 1), argvals = t_rand)  inst_rand <- instantaneous_period(fd_rand) est_period <- inst_rand$period$data[1,] est_period[est_period > 5 | est_period < 0.1] <- NA  df <- data.frame(   t = t_rand,   True = 1/freq_regime,   Estimated = est_period )  ggplot(df, aes(x = t)) +   geom_step(aes(y = True, color = \"True\"), linewidth = 1) +   geom_line(aes(y = Estimated, color = \"Estimated\"), alpha = 0.7) +   scale_color_manual(values = c(\"True\" = \"steelblue\", \"Estimated\" = \"coral\")) +   labs(title = \"Limitation: Abrupt Frequency Changes\",        subtitle = \"Hilbert transform struggles with discontinuities\",        x = \"Time\", y = \"Period\", color = \"\")"},{"path":"https://sipemu.github.io/fdars/articles/seasonal-analysis.html","id":"working-with-short-series","dir":"Articles","previous_headings":"","what":"Working with Short Series","title":"Seasonal Analysis of Functional Data","text":"short series 3-5 complete cycles, fdars provides specialized functions analyzing peak timing variability classifying seasonality.","code":""},{"path":"https://sipemu.github.io/fdars/articles/seasonal-analysis.html","id":"challenges-with-few-cycles","dir":"Articles","previous_headings":"Working with Short Series","what":"Challenges with Few Cycles","title":"Seasonal Analysis of Functional Data","text":"Period estimation limited frequency resolution Statistical measures high uncertainty Peak--peak analysis becomes important","code":""},{"path":"https://sipemu.github.io/fdars/articles/seasonal-analysis.html","id":"peak-timing-variability","dir":"Articles","previous_headings":"Working with Short Series","what":"Peak Timing Variability","title":"Seasonal Analysis of Functional Data","text":"Detect shifts peak timing cycles (e.g., phenological event shifting March April May several years).","code":"# Simulate 5 years where peak timing shifts t_short <- seq(0, 5, length.out = 500) period_short <- 1  # Peaks shift gradually later each year phase_shifts <- c(0, 0.05, 0.10, 0.08, 0.04) X_short <- rep(0, length(t_short)) for (i in 1:length(t_short)) {   year <- floor(t_short[i]) + 1   year <- min(year, 5)   X_short[i] <- sin(2 * pi * (t_short[i] + phase_shifts[year]) / period_short) } X_short <- X_short + rnorm(length(t_short), sd = 0.1)  fd_short <- fdata(matrix(X_short, nrow = 1), argvals = t_short) # Plot the short series df_short <- data.frame(t = t_short, y = X_short) ggplot(df_short, aes(x = t, y = y)) +   geom_line(color = \"steelblue\") +   geom_vline(xintercept = 0:5, linetype = \"dotted\", alpha = 0.5) +   labs(title = \"5-Year Series with Variable Peak Timing\",        x = \"Year\", y = \"Value\") # Analyze peak timing timing <- analyze_peak_timing(fd_short, period = period_short) print(timing) #> Peak Timing Variability Analysis #> --------------------------------- #> Number of peaks: 5 #> Mean timing:     0.2004 #> Std timing:      0.0442 #> Range timing:    0.1142 #> Variability:     0.4418 (moderate) #> Timing trend:    -0.0190"},{"path":"https://sipemu.github.io/fdars/articles/seasonal-analysis.html","id":"visualizing-peak-timing","dir":"Articles","previous_headings":"Working with Short Series","what":"Visualizing Peak Timing","title":"Seasonal Analysis of Functional Data","text":"","code":"# Get detected peaks peaks_short <- detect_peaks(fd_short, min_distance = 0.7,                             smooth_first = TRUE, smooth_lambda = NULL) peak_df <- peaks_short$peaks[[1]]  # Plot with peaks marked ggplot(df_short, aes(x = t, y = y)) +   geom_line(color = \"steelblue\") +   geom_point(data = peak_df, aes(x = time, y = value),              color = \"red\", size = 3) +   geom_vline(xintercept = 0:5, linetype = \"dotted\", alpha = 0.5) +   labs(title = \"5-Year Series with Detected Peaks\",        x = \"Year\", y = \"Value\") # Plot peak timing within each year if (nrow(peak_df) >= 3) {   peak_years <- floor(peak_df$time)   peak_phase <- peak_df$time - peak_years    df_timing <- data.frame(     year = peak_years + 1,     phase = peak_phase   )    ggplot(df_timing, aes(x = year, y = phase)) +     geom_point(size = 4, color = \"steelblue\") +     geom_line(linetype = \"dashed\", color = \"gray50\") +     labs(title = \"Peak Timing Variability Across Years\",          x = \"Year\", y = \"Phase within Year\") +     ylim(0, 1) }"},{"path":"https://sipemu.github.io/fdars/articles/seasonal-analysis.html","id":"seasonality-classification","dir":"Articles","previous_headings":"Working with Short Series","what":"Seasonality Classification","title":"Seasonal Analysis of Functional Data","text":"Automatically classify type seasonality pattern.","code":"class_result <- classify_seasonality(fd_short, period = period_short) print(class_result) #> Seasonality Classification #> -------------------------- #> Classification:   StableSeasonal #> Is seasonal:      TRUE #> Stable timing:    TRUE #> Timing variability: 0.4418 #> Seasonal strength:  0.9351 # Visualize classification metrics # Normalize timing variability to 0-1 scale (lower is better/more stable) stability_score <- 1 - min(1, class_result$timing_variability / 0.2)  class_df <- data.frame(   Metric = c(\"Seasonal Strength\", \"Timing Stability\"),   Value = c(class_result$seasonal_strength, stability_score) )  ggplot(class_df, aes(x = Metric, y = Value, fill = Metric)) +   geom_col() +   ylim(0, 1) +   labs(title = paste(\"Classification:\", class_result$classification),        x = \"\", y = \"Score\") +   scale_fill_brewer(palette = \"Set2\") +   theme(legend.position = \"none\")"},{"path":"https://sipemu.github.io/fdars/articles/seasonal-analysis.html","id":"classification-types","dir":"Articles","previous_headings":"Working with Short Series","what":"Classification Types","title":"Seasonal Analysis of Functional Data","text":"classify_seasonality() function returns one four classifications based seasonal strength timing variability:","code":"# Example: Stable seasonality - clean signal with consistent timing X_stable <- sin(2 * pi * t_short / period_short) + rnorm(length(t_short), sd = 0.05) fd_stable <- fdata(matrix(X_stable, nrow = 1), argvals = t_short) class_stable <- classify_seasonality(fd_stable, period = period_short)  # Example: Variable seasonality - amplitude and timing drift phase_var <- seq(0, 0.2, length.out = length(t_short)) amp_var <- 1 + 0.3 * sin(2 * pi * t_short / 3) X_variable <- amp_var * sin(2 * pi * (t_short + phase_var) / period_short) +               rnorm(length(t_short), sd = 0.2) fd_variable <- fdata(matrix(X_variable, nrow = 1), argvals = t_short) class_variable <- classify_seasonality(fd_variable, period = period_short)  # Example: Intermittent seasonality - pattern appears and disappears X_intermittent <- ifelse(t_short < 2 | t_short > 4,                          sin(2 * pi * t_short / period_short),                          rnorm(sum(t_short >= 2 & t_short <= 4), sd = 0.5)) X_intermittent <- X_intermittent + rnorm(length(t_short), sd = 0.15) fd_intermittent <- fdata(matrix(X_intermittent, nrow = 1), argvals = t_short) class_intermittent <- classify_seasonality(fd_intermittent, period = period_short)  # Example: No seasonality - pure noise X_none <- rnorm(length(t_short), sd = 1) fd_none <- fdata(matrix(X_none, nrow = 1), argvals = t_short) class_none <- classify_seasonality(fd_none, period = period_short)  # Summary cat(\"Classification results:\\n\") #> Classification results: cat(\"  Stable signal:      \", class_stable$classification,     \"(strength:\", round(class_stable$seasonal_strength, 2), \")\\n\") #>   Stable signal:       StableSeasonal (strength: 0.99 ) cat(\"  Variable signal:    \", class_variable$classification,     \"(strength:\", round(class_variable$seasonal_strength, 2), \")\\n\") #>   Variable signal:     VariableTiming (strength: 0.78 ) cat(\"  Intermittent signal:\", class_intermittent$classification,     \"(strength:\", round(class_intermittent$seasonal_strength, 2), \")\\n\") #>   Intermittent signal: IntermittentSeasonal (strength: 0.49 ) cat(\"  No seasonality:     \", class_none$classification,     \"(strength:\", round(class_none$seasonal_strength, 2), \")\\n\") #>   No seasonality:      NonSeasonal (strength: 0.01 ) # Visualize all four classification types df_examples <- data.frame(   t = rep(t_short, 4),   y = c(X_stable, X_variable, X_intermittent, X_none),   Type = factor(rep(c(\"Stable\", \"Variable\", \"Intermittent\", \"None\"),                     each = length(t_short)),                 levels = c(\"Stable\", \"Variable\", \"Intermittent\", \"None\")) )  ggplot(df_examples, aes(x = t, y = y)) +   geom_line(color = \"steelblue\") +   facet_wrap(~Type, ncol = 1, scales = \"free_y\") +   labs(title = \"Seasonality Classification Examples\",        x = \"Time\", y = \"Value\")"},{"path":"https://sipemu.github.io/fdars/articles/seasonal-analysis.html","id":"automatic-gcv-smoothing-for-short-series","dir":"Articles","previous_headings":"Working with Short Series","what":"Automatic GCV Smoothing for Short Series","title":"Seasonal Analysis of Functional Data","text":"Peak detection automatic smoothing especially important noisy short series.","code":"# More noisy short series X_noisy_short <- sin(2 * pi * t_short / period_short) + rnorm(length(t_short), sd = 0.5) fd_noisy_short <- fdata(matrix(X_noisy_short, nrow = 1), argvals = t_short)  # Auto-select smoothing parameter with GCV peaks_auto <- detect_peaks(fd_noisy_short, min_distance = 0.7,                            smooth_first = TRUE, smooth_lambda = NULL) cat(\"Peaks found with auto GCV smoothing:\", nrow(peaks_auto$peaks[[1]]), \"\\n\") #> Peaks found with auto GCV smoothing: 5 cat(\"Expected peaks:\", 5, \"\\n\") #> Expected peaks: 5 cat(\"Estimated period:\", round(peaks_auto$mean_period, 3), \"\\n\") #> Estimated period: 0.999"},{"path":"https://sipemu.github.io/fdars/articles/seasonal-analysis.html","id":"multiple-curves","dir":"Articles","previous_headings":"","what":"Multiple Curves","title":"Seasonal Analysis of Functional Data","text":"functions work multiple curves simultaneously.","code":"n_curves <- 5 t <- seq(0, 10, length.out = 200) periods <- seq(1.8, 2.2, length.out = n_curves)  # Slightly varying periods  X <- matrix(0, n_curves, length(t)) for (i in 1:n_curves) {   X[i, ] <- sin(2 * pi * t / periods[i]) + rnorm(length(t), sd = 0.2) }  fd_curves <- fdata(X, argvals = t)  # Plot all curves plot(fd_curves) +   labs(title = \"Multiple Seasonal Curves\",        x = \"Time\", y = \"Value\") # Period estimation uses the mean curve est_mean <- estimate_period(fd_curves, method = \"fft\") cat(\"Estimated period (from mean):\", est_mean$period, \"\\n\") #> Estimated period (from mean): 2.01005 cat(\"True mean period:\", mean(periods), \"\\n\") #> True mean period: 2  # Peak detection for each curve peaks_curves <- detect_peaks(fd_curves, min_distance = 1.5) cat(\"\\nMean period from peaks:\", peaks_curves$mean_period, \"\\n\") #>  #> Mean period from peaks: 1.730653  # Seasonal strength (aggregated) ss_curves <- seasonal_strength(fd_curves, period = 2) cat(\"Seasonal strength:\", round(ss_curves, 3), \"\\n\") #> Seasonal strength: 0.557"},{"path":[]},{"path":[]},{"path":"https://sipemu.github.io/fdars/articles/seasonal-analysis.html","id":"decision-guide","dir":"Articles","previous_headings":"Summary","what":"Decision Guide","title":"Seasonal Analysis of Functional Data","text":"Period estimation: Period unknown, signal stable: estimate_period(method = \"fft\") Period unknown, multiple independent periods: Use iterative residual approach Period varies smoothly time: instantaneous_period() Peak detection: Clean data: detect_peaks() default parameters Noisy data: Add smooth_first = TRUE, smooth_lambda = NULL Still many peaks: Increase min_prominence Seasonal strength: Single measurement: seasonal_strength() Track changes time: seasonal_strength_curve() Detect seasonality stops: detect_seasonality_changes_auto() Short series (3-5 cycles): Characterize timing shifts: analyze_peak_timing() Classify pattern type: classify_seasonality()","code":""},{"path":"https://sipemu.github.io/fdars/articles/seasonal-analysis.html","id":"processing-large-numbers-of-series","dir":"Articles","previous_headings":"Summary","what":"Processing Large Numbers of Series","title":"Seasonal Analysis of Functional Data","text":"analyzing many series (e.g., 500k time series), use tiered approach balance speed depth analysis: Tier 1 - Fast screening (series): filters ~80% series clear seasonality typical mixed datasets. Tier 2 - Validation (remaining ~20%): Tier 3 - Full analysis (top candidates ): Parallelization: fdars Rust functions thread-safe. Use parallel::mclapply() future.apply::future_lapply() parallel processing: Memory management: Process batches 1000-5000 series Store summary results (period, confidence, classification) Stream data disk rather loading ","code":"# Quick FFT period estimation - very fast est <- estimate_period(fd, method = \"fft\") if (est$confidence < 0.3) return(\"no_seasonality\") # Add seasonal strength check ss <- seasonal_strength(fd, period = est$period) if (ss < 0.2) return(\"weak_seasonality\") # Expensive operations - classification, multiple periods class <- classify_seasonality(fd, period = est$period) periods <- detect_multiple_periods(fd)  # if multiple periods suspected # Example batch processing workflow library(parallel) results <- mclapply(series_list, function(fd) {   est <- estimate_period(fd, method = \"fft\")   if (est$confidence < 0.3) return(list(classification = \"none\"))   ss <- seasonal_strength(fd, period = est$period)   list(period = est$period, confidence = est$confidence, strength = ss) }, mc.cores = detectCores() - 1)"},{"path":"https://sipemu.github.io/fdars/articles/working-with-derivatives.html","id":"why-derivatives-matter-in-fda","dir":"Articles","previous_headings":"","what":"Why Derivatives Matter in FDA","title":"Working with Derivatives","text":"functional data analysis, derivatives reveal critical information original curves may hide: Velocity: First derivative shows rate change Acceleration: Second derivative shows rate changes Curvature: Related second derivative, shows bending curves Phase variation: Timing events (peaks, valleys) across subjects Many real-world questions fast things change, just values observed.","code":"library(fdars) #>  #> Attaching package: 'fdars' #> The following objects are masked from 'package:stats': #>  #>     cov, deriv, median, sd, var #> The following object is masked from 'package:base': #>  #>     norm library(ggplot2) theme_set(theme_minimal()) set.seed(42)"},{"path":"https://sipemu.github.io/fdars/articles/working-with-derivatives.html","id":"loading-growth-data","dir":"Articles","previous_headings":"","what":"Loading Growth Data","title":"Working with Derivatives","text":"Berkeley Growth Study ideal demonstrating derivatives: - Height curves show overall growth pattern - Velocity (1st derivative) reveals growth spurts - Acceleration (2nd derivative) shows onset end spurts","code":"# Load or simulate growth data if (requireNamespace(\"fda\", quietly = TRUE)) {   data(growth, package = \"fda\")   age <- growth$age   heights <- t(growth$hgtf)  # Girls' heights   n <- nrow(heights) } else {   message(\"Install 'fda' package for real data: install.packages('fda')\")   # Simulate growth-like data   age <- seq(1, 18, length.out = 31)   n <- 20   heights <- matrix(0, n, length(age))   for (i in 1:n) {     A <- rnorm(1, 170, 5)     b <- rnorm(1, 2.5, 0.2)     c <- rnorm(1, 0.15, 0.02)     heights[i, ] <- A * exp(-b * exp(-c * age)) + rnorm(length(age), sd = 0.5)   } }  fd <- fdata(heights, argvals = age) cat(\"Loaded\", n, \"growth curves from ages\", min(age), \"to\", max(age), \"\\n\") #> Loaded 54 growth curves from ages 1 to 18"},{"path":"https://sipemu.github.io/fdars/articles/working-with-derivatives.html","id":"the-problem-noise-amplifies-with-differentiation","dir":"Articles","previous_headings":"","what":"The Problem: Noise Amplifies with Differentiation","title":"Working with Derivatives","text":"Let‚Äôs see happens naively differentiate noisy data: noise measurements becomes dramatically amplified derivatives!","code":"# Add some measurement noise heights_noisy <- heights + matrix(rnorm(length(heights), sd = 1), nrow = n) fd_noisy <- fdata(heights_noisy, argvals = age)  # Compute derivative of noisy data fd_deriv_noisy <- deriv(fd_noisy, nderiv = 1)  # Compare to original derivative fd_deriv <- deriv(fd, nderiv = 1)  # Plot using ggplot2 df_deriv <- data.frame(   age = rep(fd_deriv$argvals, 2),   velocity = c(fd_deriv$data[1, ], fd_deriv_noisy$data[1, ]),   type = rep(c(\"Original Data\", \"Noisy Data\"), each = length(fd_deriv$argvals)) )  ggplot(df_deriv, aes(x = age, y = velocity)) +   geom_line() +   facet_wrap(~ type) +   coord_cartesian(ylim = c(-2, 15)) +   labs(x = \"Age (years)\", y = \"Velocity (cm/year)\",        title = \"Effect of Noise on Derivative Estimation\") +   theme_minimal()"},{"path":"https://sipemu.github.io/fdars/articles/working-with-derivatives.html","id":"solution-smooth-before-differentiating","dir":"Articles","previous_headings":"","what":"Solution: Smooth Before Differentiating","title":"Working with Derivatives","text":"key insight: Always smooth data computing derivatives. P-splines excellent provide smooth derivatives:","code":"# Smooth the noisy data with P-splines fd_smooth <- pspline(fd_noisy)  # Now compute derivatives from smoothed data fd_velocity <- deriv(fd_smooth$fdata, nderiv = 1) fd_acceleration <- deriv(fd_smooth$fdata, nderiv = 2)"},{"path":[]},{"path":"https://sipemu.github.io/fdars/articles/working-with-derivatives.html","id":"height-curves-original","dir":"Articles","previous_headings":"Understanding Growth Derivatives","what":"Height Curves (Original)","title":"Working with Derivatives","text":"","code":"plot(fd_smooth$fdata, main = \"Smoothed Height Curves\",      xlab = \"Age (years)\", ylab = \"Height (cm)\")"},{"path":"https://sipemu.github.io/fdars/articles/working-with-derivatives.html","id":"velocity-curves-first-derivative","dir":"Articles","previous_headings":"Understanding Growth Derivatives","what":"Velocity Curves (First Derivative)","title":"Working with Derivatives","text":"Velocity shows growth rate cm/year. pubertal growth spurt clearly visible peak around age 11-13:  Key observations: - Infancy: high velocity (children grow fast) - Childhood: Gradual decline ~5 cm/year - Puberty: Sharp peak (growth spurt) - Adulthood: Velocity approaches zero (growth stops)","code":"library(ggplot2) plot(fd_velocity) +   geom_hline(yintercept = 0, linetype = 2, color = \"gray\") +   labs(title = \"Growth Velocity (First Derivative)\",        x = \"Age (years)\", y = \"Velocity (cm/year)\")"},{"path":"https://sipemu.github.io/fdars/articles/working-with-derivatives.html","id":"acceleration-curves-second-derivative","dir":"Articles","previous_headings":"Understanding Growth Derivatives","what":"Acceleration Curves (Second Derivative)","title":"Working with Derivatives","text":"Acceleration shows growth speeds (positive) slows (negative):  Key observations: - Zero crossing (positive negative): Peak growth spurt (PHV - Peak Height Velocity) - Minimum acceleration: rapid deceleration growth","code":"plot(fd_acceleration) +   geom_hline(yintercept = 0, linetype = 2, color = \"gray\") +   labs(title = \"Growth Acceleration (Second Derivative)\",        x = \"Age (years)\", y = \"Acceleration (cm/year^2)\")"},{"path":[]},{"path":"https://sipemu.github.io/fdars/articles/working-with-derivatives.html","id":"peak-height-velocity-phv","dir":"Articles","previous_headings":"Finding Important Events","what":"Peak Height Velocity (PHV)","title":"Working with Derivatives","text":"age peak height velocity important biological marker:","code":"# Find age of maximum velocity for each individual phv_ages <- apply(fd_velocity$data, 1, function(v) {   age[which.max(v)] })  # Summary statistics cat(\"Peak Height Velocity Ages:\\n\") #> Peak Height Velocity Ages: cat(\"  Mean:\", round(mean(phv_ages), 1), \"years\\n\") #>   Mean: 1 years cat(\"  SD:\", round(sd(phv_ages), 1), \"years\\n\") #>   SD: 0.1 years cat(\"  Range:\", round(min(phv_ages), 1), \"-\", round(max(phv_ages), 1), \"years\\n\") #>   Range: 1 - 1.8 years  # Histogram using ggplot2 df_phv <- data.frame(phv_age = phv_ages)  ggplot(df_phv, aes(x = phv_age)) +   geom_histogram(bins = 10, fill = \"lightblue\", color = \"white\") +   geom_vline(xintercept = mean(phv_ages), color = \"red\", linewidth = 1) +   labs(x = \"Age at PHV (years)\", y = \"Count\",        title = \"Distribution of PHV Ages\") +   theme_minimal()"},{"path":"https://sipemu.github.io/fdars/articles/working-with-derivatives.html","id":"visualizing-individual-variation","dir":"Articles","previous_headings":"Finding Important Events","what":"Visualizing Individual Variation","title":"Working with Derivatives","text":"","code":"# Select early and late developers early_idx <- which.min(phv_ages) late_idx <- which.max(phv_ages) median_idx <- which.min(abs(phv_ages - median(phv_ages)))  # Create data frame for height curves df_height_var <- data.frame(   age = rep(age, 3),   height = c(fd_smooth$fdata$data[early_idx, ],              fd_smooth$fdata$data[median_idx, ],              fd_smooth$fdata$data[late_idx, ]),   developer = factor(rep(c(\"Early\", \"Median\", \"Late\"), each = length(age)),                      levels = c(\"Early\", \"Median\", \"Late\")) )  # Create data frame for velocity curves df_vel_var <- data.frame(   age = rep(age, 3),   velocity = c(fd_velocity$data[early_idx, ],                fd_velocity$data[median_idx, ],                fd_velocity$data[late_idx, ]),   developer = factor(rep(c(\"Early\", \"Median\", \"Late\"), each = length(age)),                      levels = c(\"Early\", \"Median\", \"Late\")) )  # Height plot p1 <- ggplot(df_height_var, aes(x = age, y = height, color = developer, group = developer)) +   geom_line(linewidth = 1) +   scale_color_manual(values = c(\"Early\" = \"blue\", \"Median\" = \"gray50\", \"Late\" = \"red\")) +   labs(x = \"Age (years)\", y = \"Height (cm)\",        title = \"Height: Early vs Late Developers\", color = NULL) +   theme_minimal() +   theme(legend.position = \"bottom\")  # Velocity plot p2 <- ggplot(df_vel_var, aes(x = age, y = velocity, color = developer, group = developer)) +   geom_line(linewidth = 1) +   geom_hline(yintercept = 0, linetype = \"dashed\", color = \"gray\") +   scale_color_manual(values = c(\"Early\" = \"blue\", \"Median\" = \"gray50\", \"Late\" = \"red\")) +   labs(x = \"Age (years)\", y = \"Velocity (cm/year)\",        title = \"Velocity: Early vs Late Developers\", color = NULL) +   theme_minimal() +   theme(legend.position = \"bottom\")  # Display both plots (using patchwork if available, otherwise gridExtra) if (requireNamespace(\"patchwork\", quietly = TRUE)) {   library(patchwork)   p1 + p2 } else {   print(p1)   print(p2) }"},{"path":"https://sipemu.github.io/fdars/articles/working-with-derivatives.html","id":"derivative-based-distances","dir":"Articles","previous_headings":"","what":"Derivative-Based Distances","title":"Working with Derivatives","text":"shape velocity acceleration curves may meaningful comparing individuals height curves .","code":""},{"path":"https://sipemu.github.io/fdars/articles/working-with-derivatives.html","id":"using-semimetric-deriv","dir":"Articles","previous_headings":"Derivative-Based Distances","what":"Using semimetric.deriv()","title":"Working with Derivatives","text":"","code":"# Distance based on first derivative (velocity) dist_height <- metric.lp(fd_smooth$fdata) dist_velocity <- semimetric.deriv(fd_smooth$fdata, nderiv = 1) dist_acceleration <- semimetric.deriv(fd_smooth$fdata, nderiv = 2)  # Compare distance matrices (first 10 individuals) cat(\"Correlation between distance types:\\n\") #> Correlation between distance types: cat(\"  Height vs Velocity:\", round(cor(as.vector(dist_height[1:10, 1:10]),                                         as.vector(dist_velocity[1:10, 1:10])), 3), \"\\n\") #>   Height vs Velocity: 0.673 cat(\"  Height vs Acceleration:\", round(cor(as.vector(dist_height[1:10, 1:10]),                                             as.vector(dist_acceleration[1:10, 1:10])), 3), \"\\n\") #>   Height vs Acceleration: 0.452"},{"path":"https://sipemu.github.io/fdars/articles/working-with-derivatives.html","id":"clustering-by-growth-pattern","dir":"Articles","previous_headings":"Derivative-Based Distances","what":"Clustering by Growth Pattern","title":"Working with Derivatives","text":"Different distance measures can reveal different groupings:","code":"# Cluster using velocity-based distance (semimetric.deriv as the metric function) km_velocity <- cluster.kmeans(fd_smooth$fdata, ncl = 2,                                metric = semimetric.deriv, nderiv = 1, seed = 123)  # Create data frames for plotting df_height_clust <- data.frame(   age = rep(age, n),   height = as.vector(t(fd_smooth$fdata$data)),   curve = rep(1:n, each = length(age)),   cluster = factor(rep(km_velocity$cluster, each = length(age))) )  df_vel_clust <- data.frame(   age = rep(age, n),   velocity = as.vector(t(fd_velocity$data)),   curve = rep(1:n, each = length(age)),   cluster = factor(rep(km_velocity$cluster, each = length(age))) )  # Height by cluster plot p1 <- ggplot(df_height_clust, aes(x = age, y = height, group = curve, color = cluster)) +   geom_line(alpha = 0.5, linewidth = 0.5) +   scale_color_manual(values = c(\"1\" = \"blue\", \"2\" = \"red\")) +   labs(x = \"Age (years)\", y = \"Height (cm)\",        title = \"Clusters (Velocity-based)\", color = \"Cluster\") +   theme_minimal() +   theme(legend.position = \"bottom\")  # Velocity by cluster plot p2 <- ggplot(df_vel_clust, aes(x = age, y = velocity, group = curve, color = cluster)) +   geom_line(alpha = 0.5, linewidth = 0.5) +   geom_hline(yintercept = 0, linetype = \"dashed\", color = \"gray\") +   scale_color_manual(values = c(\"1\" = \"blue\", \"2\" = \"red\")) +   labs(x = \"Age (years)\", y = \"Velocity (cm/year)\",        title = \"Velocity Curves by Cluster\", color = \"Cluster\") +   theme_minimal() +   theme(legend.position = \"bottom\")  # Display both plots if (requireNamespace(\"patchwork\", quietly = TRUE)) {   p1 + p2 } else {   print(p1)   print(p2) }"},{"path":"https://sipemu.github.io/fdars/articles/working-with-derivatives.html","id":"d-functional-data-partial-derivatives","dir":"Articles","previous_headings":"","what":"2D Functional Data: Partial Derivatives","title":"Working with Derivatives","text":"surfaces (2D functional data), compute partial derivatives:","code":"# Create a simple 2D example: temperature surface (space x time) s <- seq(0, 1, length.out = 20)  # spatial coordinate t <- seq(0, 1, length.out = 25)  # time coordinate  # Generate surface: wave pattern Z <- outer(s, t, function(x, y) sin(2*pi*x) * cos(2*pi*y) + 0.1*rnorm(length(x)))  # Create 2D fdata fd2d <- fdata(Z, argvals = list(s = s, t = t), fdata2d = TRUE)  # Partial derivatives # Note: For 2D data, use nderiv parameter to specify derivative type # nderiv = 1 for ds, nderiv = 2 for dt, etc."},{"path":"https://sipemu.github.io/fdars/articles/working-with-derivatives.html","id":"optimal-smoothing-for-derivatives","dir":"Articles","previous_headings":"","what":"Optimal Smoothing for Derivatives","title":"Working with Derivatives","text":"goal estimate derivatives, may need different smoothing curves . Higher penalty (smoothing) often gives better derivative estimates:","code":"# Compare different smoothing levels lambdas <- c(0.01, 0.1, 1, 10) idx <- 1  # Create data frame for all lambda values df_smooth <- do.call(rbind, lapply(lambdas, function(lam) {   fd_s <- pspline(fd_noisy, lambda = lam)   fd_v <- deriv(fd_s$fdata, nderiv = 1)   data.frame(     age = rep(fd_v$argvals, 2),     velocity = c(fd_v$data[idx, ], fd_deriv$data[idx, ]),     type = rep(c(\"Smoothed\", \"Reference\"), each = length(fd_v$argvals)),     lambda = paste(\"lambda =\", lam)   ) })) df_smooth$lambda <- factor(df_smooth$lambda, levels = paste(\"lambda =\", lambdas))  ggplot(df_smooth, aes(x = age, y = velocity, color = type, linetype = type)) +   geom_line(linewidth = 0.8) +   geom_hline(yintercept = 0, linetype = \"dotted\", color = \"gray\") +   scale_color_manual(values = c(\"Smoothed\" = \"blue\", \"Reference\" = \"red\")) +   scale_linetype_manual(values = c(\"Smoothed\" = \"solid\", \"Reference\" = \"dashed\")) +   facet_wrap(~ lambda, ncol = 2) +   labs(x = \"Age (years)\", y = \"Velocity (cm/year)\",        title = \"Derivative Estimation with Different Smoothing Levels\",        color = NULL, linetype = NULL) +   theme_minimal() +   theme(legend.position = \"bottom\")"},{"path":"https://sipemu.github.io/fdars/articles/working-with-derivatives.html","id":"practical-workflow","dir":"Articles","previous_headings":"","what":"Practical Workflow","title":"Working with Derivatives","text":"‚Äôs recommended workflow derivative analysis:","code":"# 1. Load and inspect raw data cat(\"Step 1: Inspect raw data\\n\") #> Step 1: Inspect raw data summary(fd) #> Functional data summary #> ======================= #> Type: 1D (curve)  #> Number of observations: 54  #> Number of evaluation points: 31  #>  #> Data range: #>   Min: 67.3  #>   Max: 183.2  #>   Mean: 135.1664  #>   SD: 31.28565  # 2. Smooth with appropriate method cat(\"\\nStep 2: Smooth data (P-splines)\\n\") #>  #> Step 2: Smooth data (P-splines) fd_smooth <- pspline(fd, lambda = NULL)  # NULL = automatic selection  # 3. Compute derivatives cat(\"\\nStep 3: Compute derivatives\\n\") #>  #> Step 3: Compute derivatives fd_d1 <- deriv(fd_smooth$fdata, nderiv = 1) fd_d2 <- deriv(fd_smooth$fdata, nderiv = 2)  # 4. Extract features from derivatives cat(\"\\nStep 4: Extract features\\n\") #>  #> Step 4: Extract features features <- data.frame(   id = 1:n,   max_velocity = apply(fd_d1$data, 1, max),   age_at_max_vel = apply(fd_d1$data, 1, function(v) age[which.max(v)]),   min_acceleration = apply(fd_d2$data, 1, min) ) head(features) #>   id max_velocity age_at_max_vel min_acceleration #> 1  1     15.61790            1.0        -9.683712 #> 2  2     16.59168            1.5       -19.500398 #> 3  3     15.98360            1.0       -10.561677 #> 4  4     13.05737            1.5        -7.280834 #> 5  5     14.80809            1.0        -9.408322 #> 6  6     16.82903            1.0       -10.610381  # 5. Use for further analysis cat(\"\\nStep 5: Use features for analysis\\n\") #>  #> Step 5: Use features for analysis cat(\"Correlation between age at PHV and max velocity:\",     round(cor(features$age_at_max_vel, features$max_velocity), 3), \"\\n\") #> Correlation between age at PHV and max velocity: -0.301"},{"path":"https://sipemu.github.io/fdars/articles/working-with-derivatives.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"Working with Derivatives","text":"Key Takeaways: Always smooth computing derivatives - noise amplifies dramatically smoothing derivatives - may need higher Œª\\lambda curves Derivatives reveal dynamics - growth spurts, timing, phase variation Derivative-based distances - useful shape-based clustering comparison","code":""},{"path":"https://sipemu.github.io/fdars/articles/working-with-derivatives.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Working with Derivatives","text":"Ramsay, J.O. Silverman, B.W. (2005). Functional Data Analysis. Springer. (Chapter 5: Smoothing Functional Data; Chapter 9: Principal Differential Analysis) Tuddenham, R.D. Snyder, M.M. (1954). Physical growth California boys girls birth eighteen years. University California Publications Child Development, 1, 183-364.","code":""},{"path":"https://sipemu.github.io/fdars/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Simon M√ºller. Author, maintainer.","code":""},{"path":"https://sipemu.github.io/fdars/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"M√ºller S (2025). fdars: Functional Data Analysis Rust. R package version 0.5.1, https://sipemu.github.io/fdars.","code":"@Manual{,   title = {fdars: Functional Data Analysis in Rust},   author = {Simon M√ºller},   year = {2025},   note = {R package version 0.5.1},   url = {https://sipemu.github.io/fdars}, }"},{"path":"https://sipemu.github.io/fdars/index.html","id":"fdars","dir":"","previous_headings":"","what":"fdars - Functional Data Analysis in Rust","title":"fdars - Functional Data Analysis in Rust","text":"Functional Data Analysis Rust - high-performance R package functional data analysis Rust backend.","code":""},{"path":"https://sipemu.github.io/fdars/index.html","id":"what-is-functional-data-analysis","dir":"","previous_headings":"","what":"What is Functional Data Analysis?","title":"fdars - Functional Data Analysis in Rust","text":"Functional Data Analysis (FDA) branch statistics deals data observation function, curve, surface rather single number vector. Examples include: Temperature curves: Daily temperature recordings year multiple weather stations Growth curves: Height measurements children tracked time Spectroscopy data: Absorbance spectra measured across wavelengths Financial trajectories: Stock price movements trading days Medical signals: ECG, EEG, fMRI time series Traditional statistical methods treat time point separate variable, losing inherent smoothness continuity data. FDA treats entire curve single observation, enabling powerful interpretable analyses.","code":""},{"path":"https://sipemu.github.io/fdars/index.html","id":"features","dir":"","previous_headings":"","what":"Features","title":"fdars - Functional Data Analysis in Rust","text":"fdars comprehensive toolkit functional data analysis high-performance Rust backend providing 10-200x speedups pure R implementations.","code":""},{"path":"https://sipemu.github.io/fdars/index.html","id":"data-representation","dir":"","previous_headings":"Features","what":"Data Representation","title":"fdars - Functional Data Analysis in Rust","text":"1D functional data - Curves, time series, spectra 2D functional data - Surfaces, images, spatial fields Metadata support - Attach IDs covariates observations Flexible /O - Create matrices, arrays, data frames","code":""},{"path":"https://sipemu.github.io/fdars/index.html","id":"depth--centrality","dir":"","previous_headings":"Features","what":"Depth & Centrality","title":"fdars - Functional Data Analysis in Rust","text":"Measure ‚Äúcentral‚Äù ‚Äútypical‚Äù curve : - Fraiman-Muniz (FM), Band depth (BD), Modified band depth (MBD) - Modal depth, Random projection (RP, RT, RPD) - Functional spatial depth (FSD, KFSD) - Depth-based median, trimmed mean, trimmed variance","code":""},{"path":"https://sipemu.github.io/fdars/index.html","id":"outlier-detection","dir":"","previous_headings":"Features","what":"Outlier Detection","title":"fdars - Functional Data Analysis in Rust","text":"Multiple approaches identify anomalous curves: - Depth-based trimming weighting - Likelihood ratio test (LRT) - Functional boxplot - Magnitude-Shape plot (magnitude vs shape outliers) - Outliergram (MEI vs MBD)","code":""},{"path":"https://sipemu.github.io/fdars/index.html","id":"distance--similarity","dir":"","previous_headings":"Features","what":"Distance & Similarity","title":"fdars - Functional Data Analysis in Rust","text":"Quantify differences curves: - Lp distances (L1, L2, L‚àû) - Hausdorff distance - Dynamic time warping (DTW) - PCA-based derivative-based semimetrics","code":""},{"path":"https://sipemu.github.io/fdars/index.html","id":"regression","dir":"","previous_headings":"Features","what":"Regression","title":"fdars - Functional Data Analysis in Rust","text":"Predict scalar outcomes functional predictors: - Principal component regression (fregre.pc) - Basis expansion regression (fregre.basis) - Nonparametric kernel regression (fregre.np) - Cross-validation model selection","code":""},{"path":"https://sipemu.github.io/fdars/index.html","id":"clustering","dir":"","previous_headings":"Features","what":"Clustering","title":"fdars - Functional Data Analysis in Rust","text":"Group similar curves together: - K-means clustering K-means++ initialization - Fuzzy C-means soft membership - Automatic selection optimal k (silhouette, CH, elbow)","code":""},{"path":"https://sipemu.github.io/fdars/index.html","id":"smoothing--basis-expansion","dir":"","previous_headings":"Features","what":"Smoothing & Basis Expansion","title":"fdars - Functional Data Analysis in Rust","text":"Nadaraya-Watson, local linear/polynomial regression B-spline Fourier basis expansions P-splines automatic smoothing parameter selection Cross-validation (GCV, AIC, BIC) basis selection","code":""},{"path":"https://sipemu.github.io/fdars/index.html","id":"functional-statistics","dir":"","previous_headings":"Features","what":"Functional Statistics","title":"fdars - Functional Data Analysis in Rust","text":"Mean, variance, standard deviation, covariance Geometric median (L1 median) Bootstrap confidence intervals Hypothesis testing functional means","code":""},{"path":"https://sipemu.github.io/fdars/index.html","id":"gaussian-process-simulation","dir":"","previous_headings":"Features","what":"Gaussian Process Simulation","title":"fdars - Functional Data Analysis in Rust","text":"Generate synthetic functional data: - Multiple covariance kernels (Gaussian, Mat√©rn, Exponential, Periodic) - Kernel composition (addition, multiplication) - Brownian motion Ornstein-Uhlenbeck processes","code":""},{"path":"https://sipemu.github.io/fdars/index.html","id":"group-comparison","dir":"","previous_headings":"Features","what":"Group Comparison","title":"fdars - Functional Data Analysis in Rust","text":"-group distance matrices (centroid, Hausdorff, depth-based) Permutation tests significant group differences Visualization (heatmaps, dendrograms)","code":""},{"path":"https://sipemu.github.io/fdars/index.html","id":"visualization","dir":"","previous_headings":"Features","what":"Visualization","title":"fdars - Functional Data Analysis in Rust","text":"Curve plots categorical/continuous coloring Group means confidence intervals Functional boxplots FPCA component visualization Outlier diagnostic plots","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/index.html","id":"prerequisites","dir":"","previous_headings":"Installation","what":"Prerequisites","title":"fdars - Functional Data Analysis in Rust","text":"R (>= 4.0) Rust toolchain (install rustup.rs) C compiler (gcc, clang)","code":""},{"path":"https://sipemu.github.io/fdars/index.html","id":"from-github","dir":"","previous_headings":"Installation","what":"From GitHub","title":"fdars - Functional Data Analysis in Rust","text":"Note: Windows, may need Rtools installed.","code":"# Install remotes if needed install.packages(\"remotes\")  # Install fdars (with documentation) remotes::install_github(\"sipemu/fdars\", subdir = \"fdars\", build_vignettes = TRUE)"},{"path":"https://sipemu.github.io/fdars/index.html","id":"from-binary-release-no-rust-required","dir":"","previous_headings":"Installation","what":"From Binary Release (No Rust Required)","title":"fdars - Functional Data Analysis in Rust","text":"Download pre-built binary GitHub Releases:","code":"# macOS install.packages(\"path/to/fdars_x.y.z.tgz\", repos = NULL, type = \"mac.binary\")  # Windows install.packages(\"path/to/fdars_x.y.z.zip\", repos = NULL, type = \"win.binary\")"},{"path":"https://sipemu.github.io/fdars/index.html","id":"from-source","dir":"","previous_headings":"Installation","what":"From Source","title":"fdars - Functional Data Analysis in Rust","text":"","code":"# Clone the repository git clone https://github.com/sipemu/fdars.git cd fdars/fdars  # Build and install R CMD build . R CMD INSTALL fdars_*.tar.gz"},{"path":"https://sipemu.github.io/fdars/index.html","id":"quick-start","dir":"","previous_headings":"","what":"Quick Start","title":"fdars - Functional Data Analysis in Rust","text":"","code":"library(fdars)  # Create functional data from a matrix (rows = observations, cols = time points) t <- seq(0, 1, length.out = 100) X <- matrix(0, 20, 100) for (i in 1:20) {   X[i, ] <- sin(2 * pi * t) + rnorm(100, sd = 0.1) } fd <- fdata(X, argvals = t)  # Compute depth - measures how \"central\" each curve is depths <- depth(fd)  # default: FM method depths <- depth(fd, method = \"mode\")  # or specify method  # Find the functional median (most central curve) median_curve <- median(fd)  # default: FM method  # Detect outliers outliers <- outliers.depth.trim(fd, trim = 0.1)  # Functional regression: predict scalar y from functional X y <- rowMeans(X) + rnorm(20, sd = 0.1) model <- fregre.pc(fd, y, ncomp = 3) predictions <- predict(model, fd)  # Cluster curves into groups clusters <- cluster.kmeans(fd, ncl = 2)  # Smooth noisy curves S <- S.NW(t, h = 0.1)  # Nadaraya-Watson smoother smoothed <- S %*% X[1, ]"},{"path":[]},{"path":"https://sipemu.github.io/fdars/index.html","id":"functional-data-objects-fdata","dir":"","previous_headings":"Key Concepts","what":"Functional Data Objects (fdata)","title":"fdars - Functional Data Analysis in Rust","text":"fdata class stores functional data matrix rows observations columns evaluation points:","code":"fd <- fdata(data_matrix, argvals = time_points, rangeval = c(0, 1))"},{"path":"https://sipemu.github.io/fdars/index.html","id":"identifiers-and-metadata","dir":"","previous_headings":"Key Concepts > Functional Data Objects (fdata)","what":"Identifiers and Metadata","title":"fdars - Functional Data Analysis in Rust","text":"can attach identifiers metadata (covariates) functional data objects: Note: metadata contains id column non-default row names, must match fdata identifiers. error thrown mismatch.","code":"# Create fdata with IDs and metadata meta <- data.frame(   group = factor(c(\"control\", \"treatment\", ...)),   age = c(25, 32, ...),   response = c(0.5, 0.8, ...) ) fd <- fdata(X, id = paste0(\"patient_\", 1:n), metadata = meta)  # Access fields fd$id              # Character vector of identifiers fd$metadata$group  # Access metadata columns  # Subsetting preserves metadata fd_sub <- fd[1:10, ]  # id and metadata are also subsetted  # View metadata info print(fd)    # Shows metadata columns summary(fd)  # Shows metadata types and ranges"},{"path":"https://sipemu.github.io/fdars/index.html","id":"depth-functions","dir":"","previous_headings":"Key Concepts","what":"Depth Functions","title":"fdars - Functional Data Analysis in Rust","text":"Depth measures ‚Äúcentral‚Äù ‚Äútypical‚Äù curve relative sample. Higher depth = central. Use unified depth() function method parameter:","code":"depth(fd, method = \"FM\")     # Fraiman-Muniz depth (default) depth(fd, method = \"BD\")     # Band depth depth(fd, method = \"MBD\")    # Modified band depth depth(fd, method = \"mode\")   # Modal depth (kernel density) depth(fd, method = \"RP\")     # Random projection depth depth(fd, method = \"RT\")     # Random Tukey depth depth(fd, method = \"FSD\")    # Functional spatial depth depth(fd, method = \"KFSD\")   # Kernel functional spatial depth depth(fd, method = \"RPD\")    # Random projection with derivatives"},{"path":"https://sipemu.github.io/fdars/index.html","id":"functional-regression","dir":"","previous_headings":"Key Concepts","what":"Functional Regression","title":"fdars - Functional Data Analysis in Rust","text":"Predict scalar response functional predictors: fregre.pc - Principal component regression fregre.basis - Basis expansion regression fregre.np - Nonparametric kernel regression models support predict() new data.","code":""},{"path":"https://sipemu.github.io/fdars/index.html","id":"distance-metrics","dir":"","previous_headings":"Key Concepts","what":"Distance Metrics","title":"fdars - Functional Data Analysis in Rust","text":"Measure similarity curves using metric() method parameter: Individual functions also available: metric.lp, metric.hausdorff, metric.DTW, semimetric.pca, semimetric.deriv.","code":"metric(fd, method = \"lp\")        # Lp distance (default, L2 = Euclidean) metric(fd, method = \"hausdorff\") # Hausdorff distance metric(fd, method = \"dtw\")       # Dynamic time warping metric(fd, method = \"pca\")       # PCA-based semimetric metric(fd, method = \"deriv\")     # Derivative-based semimetric"},{"path":"https://sipemu.github.io/fdars/index.html","id":"outlier-detection-1","dir":"","previous_headings":"Key Concepts","what":"Outlier Detection","title":"fdars - Functional Data Analysis in Rust","text":"Identify unusual curves: outliers.depth.trim - Trimmed depth-based detection outliers.depth.pond - Weighted depth-based detection outliers.lrt - Likelihood ratio test outliers.boxplot - Functional boxplot-based detection magnitudeshape - Magnitude-Shape outlier detection outliergram - Outliergram (MEI vs MBD plot)","code":""},{"path":"https://sipemu.github.io/fdars/index.html","id":"labeling-outliers-by-id-or-metadata","dir":"","previous_headings":"Key Concepts > Outlier Detection","what":"Labeling Outliers by ID or Metadata","title":"fdars - Functional Data Analysis in Rust","text":"magnitudeshape outliergram support labeling points ID metadata columns:","code":"# Create fdata with IDs and metadata fd <- fdata(X, id = paste0(\"patient_\", 1:n),             metadata = data.frame(subject_id = paste0(\"S\", 1:n)))  # Outliergram with custom labels og <- outliergram(fd) plot(og, label = \"id\")           # Label outliers with patient IDs plot(og, label = \"subject_id\")   # Label with metadata column plot(og, label_all = TRUE)       # Label ALL points, not just outliers  # magnitudeshape with custom labels magnitudeshape(fd, label = \"id\")        # Label outliers with patient IDs magnitudeshape(fd, label = NULL)        # No labels"},{"path":"https://sipemu.github.io/fdars/index.html","id":"functional-statistics-1","dir":"","previous_headings":"Key Concepts","what":"Functional Statistics","title":"fdars - Functional Data Analysis in Rust","text":"mean(fd) - Functional mean var(fd) - Functional variance sd(fd) - Functional standard deviation cov(fd) - Functional covariance gmed(fd) - Geometric median (L1 median via Weiszfeld algorithm)","code":""},{"path":"https://sipemu.github.io/fdars/index.html","id":"covariance-functions-and-gaussian-process-generation","dir":"","previous_headings":"Key Concepts","what":"Covariance Functions and Gaussian Process Generation","title":"fdars - Functional Data Analysis in Rust","text":"Generate synthetic functional data Gaussian processes various covariance kernels: Available covariance functions: - kernel_gaussian - Squared exponential (RBF) kernel, infinitely smooth - kernel_exponential - Exponential kernel (Matern ŒΩ=0.5), rough - kernel_matern - Matern family smoothness parameter ŒΩ - kernel_brownian - Brownian motion covariance (1D ) - kernel_linear - Linear kernel - kernel_polynomial - Polynomial kernel - kernel_whitenoise - Independent noise point - kernel_periodic - Periodic kernel (1D ) - kernel_add - Combine kernels addition - kernel_mult - Combine kernels multiplication","code":"# Smooth samples with Gaussian (squared exponential) kernel fd_smooth <- make_gaussian_process(n = 20, t = seq(0, 1, length.out = 100),                                    cov = kernel_gaussian(length_scale = 0.2))  # Rough samples with Matern kernel fd_rough <- make_gaussian_process(n = 20, t = seq(0, 1, length.out = 100),                                   cov = kernel_matern(nu = 1.5))  # Periodic samples fd_periodic <- make_gaussian_process(n = 10, t = seq(0, 2, length.out = 200),                                      cov = kernel_periodic(period = 0.5))  # Combine kernels: signal + noise cov_total <- kernel_add(kernel_gaussian(variance = 1), kernel_whitenoise(variance = 0.1)) fd_noisy <- make_gaussian_process(n = 10, t = seq(0, 1, length.out = 100), cov = cov_total)"},{"path":"https://sipemu.github.io/fdars/index.html","id":"depth-based-medians-and-trimmed-means","dir":"","previous_headings":"Key Concepts","what":"Depth-Based Medians and Trimmed Means","title":"fdars - Functional Data Analysis in Rust","text":"Use unified functions method parameter:","code":"# Median (curve with maximum depth) median(fd)                          # default: FM method median(fd, method = \"mode\")         # modal depth-based median  # Trimmed mean (mean of deepest curves) trimmed(fd, trim = 0.1)             # default: FM method trimmed(fd, trim = 0.1, method = \"RP\")  # RP depth-based trimmed mean  # Trimmed variance trimvar(fd, trim = 0.1)             # default: FM method trimvar(fd, trim = 0.1, method = \"mode\")"},{"path":"https://sipemu.github.io/fdars/index.html","id":"visualization-1","dir":"","previous_headings":"Key Concepts","what":"Visualization","title":"fdars - Functional Data Analysis in Rust","text":"show.mean = TRUE - Overlay group mean curves show.ci = TRUE - Show confidence interval ribbons per group boxplot.fdata - Functional boxplot depth-based envelopes magnitudeshape - Magnitude-Shape outlier detection visualization outliergram - Outliergram shape outlier detection (MEI vs MBD plot) plot.fdata2pc - FPCA visualization (components, variance, scores)","code":""},{"path":"https://sipemu.github.io/fdars/index.html","id":"group-comparison-1","dir":"","previous_headings":"Key Concepts","what":"Group Comparison","title":"fdars - Functional Data Analysis in Rust","text":"group.distance - Compute distances groups (centroid, Hausdorff, depth-based) group.test - Permutation test significant group differences plot.group.distance - Visualize group distances (heatmap, dendrogram)","code":""},{"path":"https://sipemu.github.io/fdars/index.html","id":"clustering-1","dir":"","previous_headings":"Key Concepts","what":"Clustering","title":"fdars - Functional Data Analysis in Rust","text":"cluster.kmeans - K-means clustering functional data cluster.optim - Optimal k selection using silhouette, CH, elbow cluster.fcm - Fuzzy C-means clustering soft membership cluster.init - K-means++ center initialization","code":""},{"path":"https://sipemu.github.io/fdars/index.html","id":"curve-registration","dir":"","previous_headings":"Key Concepts","what":"Curve Registration","title":"fdars - Functional Data Analysis in Rust","text":"register.fd - Shift registration using cross-correlation","code":""},{"path":"https://sipemu.github.io/fdars/index.html","id":"feature-extraction","dir":"","previous_headings":"Key Concepts","what":"Feature Extraction","title":"fdars - Functional Data Analysis in Rust","text":"localavg.fdata - Extract local average features curves","code":""},{"path":"https://sipemu.github.io/fdars/index.html","id":"id_2d-functional-data-surfaces","dir":"","previous_headings":"Key Concepts","what":"2D Functional Data (Surfaces)","title":"fdars - Functional Data Analysis in Rust","text":"fdars supports 2D functional data (surfaces/images). following functions full 2D support: Note: Band depths (BD, MBD), RPD, DTW support 2D data.","code":"# Create 2D functional data (e.g., 10 surfaces on a 20x30 grid) n <- 10 m1 <- 20 m2 <- 30 s <- seq(0, 1, length.out = m1) t <- seq(0, 1, length.out = m2)  # Generate surfaces: f(s,t) = sin(2*pi*s) * cos(2*pi*t) + noise X <- array(0, dim = c(n, m1, m2)) for (i in 1:n) {   for (si in 1:m1) {     for (ti in 1:m2) {       X[i, si, ti] <- sin(2*pi*s[si]) * cos(2*pi*t[ti]) + rnorm(1, sd = 0.1)     }   } }  fd2d <- fdata(X, argvals = list(s, t), fdata2d = TRUE)  # All these work with 2D data: mean_surface <- mean(fd2d)           # Mean surface var_surface <- var(fd2d)             # Pointwise variance depths <- depth(fd2d)                # Depth values median_surface <- median(fd2d)       # Depth-based median gmed_surface <- gmed(fd2d)           # Geometric median  # Plot 2D data (heatmap + contours) plot(fd2d)"},{"path":"https://sipemu.github.io/fdars/index.html","id":"converting-dataframes-to-2d-fdata","dir":"","previous_headings":"Key Concepts > 2D Functional Data (Surfaces)","what":"Converting DataFrames to 2D fdata","title":"fdars - Functional Data Analysis in Rust","text":"Use df_to_fdata2d() convert long-format DataFrames 2D functional data:","code":"# DataFrame structure: id column, s-index column, t-value columns df <- data.frame(   id = rep(c(\"surf1\", \"surf2\"), each = 5),   s = rep(1:5, 2),   t1 = rnorm(10), t2 = rnorm(10), t3 = rnorm(10) )  # Convert to 2D fdata fd2d <- df_to_fdata2d(df, id_col = 1, s_col = 2)  # With metadata (must have one row per surface) meta <- data.frame(group = c(\"A\", \"B\"), value = c(1.5, 2.3)) fd2d <- df_to_fdata2d(df, id_col = 1, s_col = 2, metadata = meta)"},{"path":"https://sipemu.github.io/fdars/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"fdars - Functional Data Analysis in Rust","text":"MIT","code":""},{"path":"https://sipemu.github.io/fdars/index.html","id":"author","dir":"","previous_headings":"","what":"Author","title":"fdars - Functional Data Analysis in Rust","text":"Simon Mueller","code":""},{"path":"https://sipemu.github.io/fdars/index.html","id":"acknowledgments","dir":"","previous_headings":"","what":"Acknowledgments","title":"fdars - Functional Data Analysis in Rust","text":"Built extendr R-Rust integration Uses rayon parallelization","code":""},{"path":"https://sipemu.github.io/fdars/reference/AKer.cos.html","id":null,"dir":"Reference","previous_headings":"","what":"Asymmetric Cosine Kernel ‚Äî AKer.cos","title":"Asymmetric Cosine Kernel ‚Äî AKer.cos","text":"Asymmetric Cosine Kernel","code":""},{"path":"https://sipemu.github.io/fdars/reference/AKer.cos.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Asymmetric Cosine Kernel ‚Äî AKer.cos","text":"","code":"AKer.cos(u)"},{"path":"https://sipemu.github.io/fdars/reference/AKer.cos.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Asymmetric Cosine Kernel ‚Äî AKer.cos","text":"u Numeric vector evaluation points.","code":""},{"path":"https://sipemu.github.io/fdars/reference/AKer.cos.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Asymmetric Cosine Kernel ‚Äî AKer.cos","text":"Kernel values u (0 u < 0).","code":""},{"path":"https://sipemu.github.io/fdars/reference/AKer.cos.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Asymmetric Cosine Kernel ‚Äî AKer.cos","text":"","code":"u <- seq(-0.5, 1.5, length.out = 100) plot(u, AKer.cos(u), type = \"l\", main = \"Asymmetric Cosine Kernel\")"},{"path":"https://sipemu.github.io/fdars/reference/AKer.epa.html","id":null,"dir":"Reference","previous_headings":"","what":"Asymmetric Epanechnikov Kernel ‚Äî AKer.epa","title":"Asymmetric Epanechnikov Kernel ‚Äî AKer.epa","text":"Asymmetric Epanechnikov Kernel","code":""},{"path":"https://sipemu.github.io/fdars/reference/AKer.epa.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Asymmetric Epanechnikov Kernel ‚Äî AKer.epa","text":"","code":"AKer.epa(u)"},{"path":"https://sipemu.github.io/fdars/reference/AKer.epa.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Asymmetric Epanechnikov Kernel ‚Äî AKer.epa","text":"u Numeric vector evaluation points.","code":""},{"path":"https://sipemu.github.io/fdars/reference/AKer.epa.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Asymmetric Epanechnikov Kernel ‚Äî AKer.epa","text":"Kernel values u (0 outside [0, 1]).","code":""},{"path":"https://sipemu.github.io/fdars/reference/AKer.epa.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Asymmetric Epanechnikov Kernel ‚Äî AKer.epa","text":"","code":"u <- seq(-0.5, 1.5, length.out = 100) plot(u, AKer.epa(u), type = \"l\", main = \"Asymmetric Epanechnikov Kernel\")"},{"path":"https://sipemu.github.io/fdars/reference/AKer.norm.html","id":null,"dir":"Reference","previous_headings":"","what":"Asymmetric Normal Kernel ‚Äî AKer.norm","title":"Asymmetric Normal Kernel ‚Äî AKer.norm","text":"Asymmetric Normal Kernel","code":""},{"path":"https://sipemu.github.io/fdars/reference/AKer.norm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Asymmetric Normal Kernel ‚Äî AKer.norm","text":"","code":"AKer.norm(u)"},{"path":"https://sipemu.github.io/fdars/reference/AKer.norm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Asymmetric Normal Kernel ‚Äî AKer.norm","text":"u Numeric vector evaluation points.","code":""},{"path":"https://sipemu.github.io/fdars/reference/AKer.norm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Asymmetric Normal Kernel ‚Äî AKer.norm","text":"Kernel values u (0 u < 0).","code":""},{"path":"https://sipemu.github.io/fdars/reference/AKer.norm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Asymmetric Normal Kernel ‚Äî AKer.norm","text":"","code":"u <- seq(-0.5, 3, length.out = 100) plot(u, AKer.norm(u), type = \"l\", main = \"Asymmetric Normal Kernel\")"},{"path":"https://sipemu.github.io/fdars/reference/AKer.quar.html","id":null,"dir":"Reference","previous_headings":"","what":"Asymmetric Quartic Kernel ‚Äî AKer.quar","title":"Asymmetric Quartic Kernel ‚Äî AKer.quar","text":"Asymmetric Quartic Kernel","code":""},{"path":"https://sipemu.github.io/fdars/reference/AKer.quar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Asymmetric Quartic Kernel ‚Äî AKer.quar","text":"","code":"AKer.quar(u)"},{"path":"https://sipemu.github.io/fdars/reference/AKer.quar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Asymmetric Quartic Kernel ‚Äî AKer.quar","text":"u Numeric vector evaluation points.","code":""},{"path":"https://sipemu.github.io/fdars/reference/AKer.quar.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Asymmetric Quartic Kernel ‚Äî AKer.quar","text":"Kernel values u (0 outside [0, 1]).","code":""},{"path":"https://sipemu.github.io/fdars/reference/AKer.quar.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Asymmetric Quartic Kernel ‚Äî AKer.quar","text":"","code":"u <- seq(-0.5, 1.5, length.out = 100) plot(u, AKer.quar(u), type = \"l\", main = \"Asymmetric Quartic Kernel\")"},{"path":"https://sipemu.github.io/fdars/reference/AKer.tri.html","id":null,"dir":"Reference","previous_headings":"","what":"Asymmetric Triweight Kernel ‚Äî AKer.tri","title":"Asymmetric Triweight Kernel ‚Äî AKer.tri","text":"Asymmetric Triweight Kernel","code":""},{"path":"https://sipemu.github.io/fdars/reference/AKer.tri.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Asymmetric Triweight Kernel ‚Äî AKer.tri","text":"","code":"AKer.tri(u)"},{"path":"https://sipemu.github.io/fdars/reference/AKer.tri.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Asymmetric Triweight Kernel ‚Äî AKer.tri","text":"u Numeric vector evaluation points.","code":""},{"path":"https://sipemu.github.io/fdars/reference/AKer.tri.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Asymmetric Triweight Kernel ‚Äî AKer.tri","text":"Kernel values u (0 outside [0, 1]).","code":""},{"path":"https://sipemu.github.io/fdars/reference/AKer.tri.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Asymmetric Triweight Kernel ‚Äî AKer.tri","text":"","code":"u <- seq(-0.5, 1.5, length.out = 100) plot(u, AKer.tri(u), type = \"l\", main = \"Asymmetric Triweight Kernel\")"},{"path":"https://sipemu.github.io/fdars/reference/AKer.unif.html","id":null,"dir":"Reference","previous_headings":"","what":"Asymmetric Uniform Kernel ‚Äî AKer.unif","title":"Asymmetric Uniform Kernel ‚Äî AKer.unif","text":"Asymmetric Uniform Kernel","code":""},{"path":"https://sipemu.github.io/fdars/reference/AKer.unif.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Asymmetric Uniform Kernel ‚Äî AKer.unif","text":"","code":"AKer.unif(u)"},{"path":"https://sipemu.github.io/fdars/reference/AKer.unif.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Asymmetric Uniform Kernel ‚Äî AKer.unif","text":"u Numeric vector evaluation points.","code":""},{"path":"https://sipemu.github.io/fdars/reference/AKer.unif.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Asymmetric Uniform Kernel ‚Äî AKer.unif","text":"Kernel values u (0 outside [0, 1]).","code":""},{"path":"https://sipemu.github.io/fdars/reference/AKer.unif.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Asymmetric Uniform Kernel ‚Äî AKer.unif","text":"","code":"u <- seq(-0.5, 1.5, length.out = 100) plot(u, AKer.unif(u), type = \"l\", main = \"Asymmetric Uniform Kernel\")"},{"path":"https://sipemu.github.io/fdars/reference/CV.S.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-Validation for Smoother Selection ‚Äî CV.S","title":"Cross-Validation for Smoother Selection ‚Äî CV.S","text":"Compute leave-one-cross-validation criterion smoother.","code":""},{"path":"https://sipemu.github.io/fdars/reference/CV.S.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-Validation for Smoother Selection ‚Äî CV.S","text":"","code":"CV.S(S.type, tt, h, y, Ker = \"norm\", w = NULL)"},{"path":"https://sipemu.github.io/fdars/reference/CV.S.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-Validation for Smoother Selection ‚Äî CV.S","text":"S.type Function compute smoother matrix (e.g., S.NW, S.LLR). tt Evaluation points. h Bandwidth parameter. y Response vector smooth. Ker Kernel type. w Optional weights.","code":""},{"path":"https://sipemu.github.io/fdars/reference/CV.S.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-Validation for Smoother Selection ‚Äî CV.S","text":"cross-validation score (mean squared prediction error).","code":""},{"path":"https://sipemu.github.io/fdars/reference/CV.S.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-Validation for Smoother Selection ‚Äî CV.S","text":"","code":"tt <- seq(0, 1, length.out = 50) y <- sin(2 * pi * tt) + rnorm(50, sd = 0.1) cv_score <- CV.S(S.NW, tt, h = 0.1, y = y)"},{"path":"https://sipemu.github.io/fdars/reference/GCV.S.html","id":null,"dir":"Reference","previous_headings":"","what":"Generalized Cross-Validation for Smoother Selection ‚Äî GCV.S","title":"Generalized Cross-Validation for Smoother Selection ‚Äî GCV.S","text":"Compute GCV criterion: RSS / (1 - tr(S)/n)^2","code":""},{"path":"https://sipemu.github.io/fdars/reference/GCV.S.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generalized Cross-Validation for Smoother Selection ‚Äî GCV.S","text":"","code":"GCV.S(S.type, tt, h, y, Ker = \"norm\", w = NULL)"},{"path":"https://sipemu.github.io/fdars/reference/GCV.S.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generalized Cross-Validation for Smoother Selection ‚Äî GCV.S","text":"S.type Function compute smoother matrix. tt Evaluation points. h Bandwidth parameter. y Response vector. Ker Kernel type. w Optional weights.","code":""},{"path":"https://sipemu.github.io/fdars/reference/GCV.S.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generalized Cross-Validation for Smoother Selection ‚Äî GCV.S","text":"GCV score.","code":""},{"path":"https://sipemu.github.io/fdars/reference/GCV.S.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generalized Cross-Validation for Smoother Selection ‚Äî GCV.S","text":"","code":"tt <- seq(0, 1, length.out = 50) y <- sin(2 * pi * tt) + rnorm(50, sd = 0.1) gcv_score <- GCV.S(S.NW, tt, h = 0.1, y = y)"},{"path":"https://sipemu.github.io/fdars/reference/IKer.cos.html","id":null,"dir":"Reference","previous_headings":"","what":"Integrated Cosine Kernel ‚Äî IKer.cos","title":"Integrated Cosine Kernel ‚Äî IKer.cos","text":"Integral Ker.cos -1 u.","code":""},{"path":"https://sipemu.github.io/fdars/reference/IKer.cos.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Integrated Cosine Kernel ‚Äî IKer.cos","text":"","code":"IKer.cos(u)"},{"path":"https://sipemu.github.io/fdars/reference/IKer.cos.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Integrated Cosine Kernel ‚Äî IKer.cos","text":"u Numeric vector evaluation points.","code":""},{"path":"https://sipemu.github.io/fdars/reference/IKer.cos.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Integrated Cosine Kernel ‚Äî IKer.cos","text":"Cumulative integral values.","code":""},{"path":"https://sipemu.github.io/fdars/reference/IKer.cos.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Integrated Cosine Kernel ‚Äî IKer.cos","text":"","code":"u <- seq(-1.5, 1.5, length.out = 100) plot(u, IKer.cos(u), type = \"l\", main = \"Integrated Cosine Kernel\")"},{"path":"https://sipemu.github.io/fdars/reference/IKer.epa.html","id":null,"dir":"Reference","previous_headings":"","what":"Integrated Epanechnikov Kernel ‚Äî IKer.epa","title":"Integrated Epanechnikov Kernel ‚Äî IKer.epa","text":"Integral Ker.epa -1 u.","code":""},{"path":"https://sipemu.github.io/fdars/reference/IKer.epa.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Integrated Epanechnikov Kernel ‚Äî IKer.epa","text":"","code":"IKer.epa(u)"},{"path":"https://sipemu.github.io/fdars/reference/IKer.epa.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Integrated Epanechnikov Kernel ‚Äî IKer.epa","text":"u Numeric vector evaluation points.","code":""},{"path":"https://sipemu.github.io/fdars/reference/IKer.epa.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Integrated Epanechnikov Kernel ‚Äî IKer.epa","text":"Cumulative integral values.","code":""},{"path":"https://sipemu.github.io/fdars/reference/IKer.epa.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Integrated Epanechnikov Kernel ‚Äî IKer.epa","text":"","code":"u <- seq(-1.5, 1.5, length.out = 100) plot(u, IKer.epa(u), type = \"l\", main = \"Integrated Epanechnikov Kernel\")"},{"path":"https://sipemu.github.io/fdars/reference/IKer.norm.html","id":null,"dir":"Reference","previous_headings":"","what":"Integrated Normal Kernel ‚Äî IKer.norm","title":"Integrated Normal Kernel ‚Äî IKer.norm","text":"Integrated Normal Kernel","code":""},{"path":"https://sipemu.github.io/fdars/reference/IKer.norm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Integrated Normal Kernel ‚Äî IKer.norm","text":"","code":"IKer.norm(u)"},{"path":"https://sipemu.github.io/fdars/reference/IKer.norm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Integrated Normal Kernel ‚Äî IKer.norm","text":"u Numeric vector evaluation points.","code":""},{"path":"https://sipemu.github.io/fdars/reference/IKer.norm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Integrated Normal Kernel ‚Äî IKer.norm","text":"Cumulative integral normal kernel -Inf u.","code":""},{"path":"https://sipemu.github.io/fdars/reference/IKer.norm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Integrated Normal Kernel ‚Äî IKer.norm","text":"","code":"u <- seq(-3, 3, length.out = 100) plot(u, IKer.norm(u), type = \"l\", main = \"Integrated Normal Kernel\")"},{"path":"https://sipemu.github.io/fdars/reference/IKer.quar.html","id":null,"dir":"Reference","previous_headings":"","what":"Integrated Quartic Kernel ‚Äî IKer.quar","title":"Integrated Quartic Kernel ‚Äî IKer.quar","text":"Integral Ker.quar -1 u.","code":""},{"path":"https://sipemu.github.io/fdars/reference/IKer.quar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Integrated Quartic Kernel ‚Äî IKer.quar","text":"","code":"IKer.quar(u)"},{"path":"https://sipemu.github.io/fdars/reference/IKer.quar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Integrated Quartic Kernel ‚Äî IKer.quar","text":"u Numeric vector evaluation points.","code":""},{"path":"https://sipemu.github.io/fdars/reference/IKer.quar.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Integrated Quartic Kernel ‚Äî IKer.quar","text":"Cumulative integral values.","code":""},{"path":"https://sipemu.github.io/fdars/reference/IKer.quar.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Integrated Quartic Kernel ‚Äî IKer.quar","text":"","code":"u <- seq(-1.5, 1.5, length.out = 100) plot(u, IKer.quar(u), type = \"l\", main = \"Integrated Quartic Kernel\")"},{"path":"https://sipemu.github.io/fdars/reference/IKer.tri.html","id":null,"dir":"Reference","previous_headings":"","what":"Integrated Triweight Kernel ‚Äî IKer.tri","title":"Integrated Triweight Kernel ‚Äî IKer.tri","text":"Integral Ker.tri -1 u.","code":""},{"path":"https://sipemu.github.io/fdars/reference/IKer.tri.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Integrated Triweight Kernel ‚Äî IKer.tri","text":"","code":"IKer.tri(u)"},{"path":"https://sipemu.github.io/fdars/reference/IKer.tri.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Integrated Triweight Kernel ‚Äî IKer.tri","text":"u Numeric vector evaluation points.","code":""},{"path":"https://sipemu.github.io/fdars/reference/IKer.tri.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Integrated Triweight Kernel ‚Äî IKer.tri","text":"Cumulative integral values.","code":""},{"path":"https://sipemu.github.io/fdars/reference/IKer.tri.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Integrated Triweight Kernel ‚Äî IKer.tri","text":"","code":"u <- seq(-1.5, 1.5, length.out = 100) plot(u, IKer.tri(u), type = \"l\", main = \"Integrated Triweight Kernel\")"},{"path":"https://sipemu.github.io/fdars/reference/IKer.unif.html","id":null,"dir":"Reference","previous_headings":"","what":"Integrated Uniform Kernel ‚Äî IKer.unif","title":"Integrated Uniform Kernel ‚Äî IKer.unif","text":"Integral Ker.unif -1 u.","code":""},{"path":"https://sipemu.github.io/fdars/reference/IKer.unif.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Integrated Uniform Kernel ‚Äî IKer.unif","text":"","code":"IKer.unif(u)"},{"path":"https://sipemu.github.io/fdars/reference/IKer.unif.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Integrated Uniform Kernel ‚Äî IKer.unif","text":"u Numeric vector evaluation points.","code":""},{"path":"https://sipemu.github.io/fdars/reference/IKer.unif.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Integrated Uniform Kernel ‚Äî IKer.unif","text":"Cumulative integral values.","code":""},{"path":"https://sipemu.github.io/fdars/reference/IKer.unif.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Integrated Uniform Kernel ‚Äî IKer.unif","text":"","code":"u <- seq(-1.5, 1.5, length.out = 100) plot(u, IKer.unif(u), type = \"l\", main = \"Integrated Uniform Kernel\")"},{"path":"https://sipemu.github.io/fdars/reference/Ker.cos.html","id":null,"dir":"Reference","previous_headings":"","what":"Cosine Kernel ‚Äî Ker.cos","title":"Cosine Kernel ‚Äî Ker.cos","text":"Cosine Kernel","code":""},{"path":"https://sipemu.github.io/fdars/reference/Ker.cos.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cosine Kernel ‚Äî Ker.cos","text":"","code":"Ker.cos(u)"},{"path":"https://sipemu.github.io/fdars/reference/Ker.cos.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cosine Kernel ‚Äî Ker.cos","text":"u Numeric vector evaluation points.","code":""},{"path":"https://sipemu.github.io/fdars/reference/Ker.cos.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cosine Kernel ‚Äî Ker.cos","text":"Kernel values u (0 outside [-1, 1]).","code":""},{"path":"https://sipemu.github.io/fdars/reference/Ker.cos.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cosine Kernel ‚Äî Ker.cos","text":"","code":"u <- seq(-1.5, 1.5, length.out = 100) plot(u, Ker.cos(u), type = \"l\", main = \"Cosine Kernel\")"},{"path":"https://sipemu.github.io/fdars/reference/Ker.epa.html","id":null,"dir":"Reference","previous_headings":"","what":"Epanechnikov Kernel ‚Äî Ker.epa","title":"Epanechnikov Kernel ‚Äî Ker.epa","text":"Epanechnikov Kernel","code":""},{"path":"https://sipemu.github.io/fdars/reference/Ker.epa.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Epanechnikov Kernel ‚Äî Ker.epa","text":"","code":"Ker.epa(u)"},{"path":"https://sipemu.github.io/fdars/reference/Ker.epa.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Epanechnikov Kernel ‚Äî Ker.epa","text":"u Numeric vector evaluation points.","code":""},{"path":"https://sipemu.github.io/fdars/reference/Ker.epa.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Epanechnikov Kernel ‚Äî Ker.epa","text":"Kernel values u (0 outside [-1, 1]).","code":""},{"path":"https://sipemu.github.io/fdars/reference/Ker.epa.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Epanechnikov Kernel ‚Äî Ker.epa","text":"","code":"u <- seq(-1.5, 1.5, length.out = 100) plot(u, Ker.epa(u), type = \"l\", main = \"Epanechnikov Kernel\")"},{"path":"https://sipemu.github.io/fdars/reference/Ker.norm.html","id":null,"dir":"Reference","previous_headings":"","what":"Kernel Functions ‚Äî Ker.norm","title":"Kernel Functions ‚Äî Ker.norm","text":"Symmetric, asymmetric, integrated kernel functions nonparametric smoothing density estimation. Normal (Gaussian) Kernel","code":""},{"path":"https://sipemu.github.io/fdars/reference/Ker.norm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Kernel Functions ‚Äî Ker.norm","text":"","code":"Ker.norm(u)"},{"path":"https://sipemu.github.io/fdars/reference/Ker.norm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Kernel Functions ‚Äî Ker.norm","text":"u Numeric vector evaluation points.","code":""},{"path":"https://sipemu.github.io/fdars/reference/Ker.norm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Kernel Functions ‚Äî Ker.norm","text":"Kernel values u.","code":""},{"path":"https://sipemu.github.io/fdars/reference/Ker.norm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Kernel Functions ‚Äî Ker.norm","text":"","code":"u <- seq(-3, 3, length.out = 100) plot(u, Ker.norm(u), type = \"l\", main = \"Normal Kernel\")"},{"path":"https://sipemu.github.io/fdars/reference/Ker.quar.html","id":null,"dir":"Reference","previous_headings":"","what":"Quartic (Biweight) Kernel ‚Äî Ker.quar","title":"Quartic (Biweight) Kernel ‚Äî Ker.quar","text":"Quartic (Biweight) Kernel","code":""},{"path":"https://sipemu.github.io/fdars/reference/Ker.quar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Quartic (Biweight) Kernel ‚Äî Ker.quar","text":"","code":"Ker.quar(u)"},{"path":"https://sipemu.github.io/fdars/reference/Ker.quar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Quartic (Biweight) Kernel ‚Äî Ker.quar","text":"u Numeric vector evaluation points.","code":""},{"path":"https://sipemu.github.io/fdars/reference/Ker.quar.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Quartic (Biweight) Kernel ‚Äî Ker.quar","text":"Kernel values u (0 outside [-1, 1]).","code":""},{"path":"https://sipemu.github.io/fdars/reference/Ker.quar.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Quartic (Biweight) Kernel ‚Äî Ker.quar","text":"","code":"u <- seq(-1.5, 1.5, length.out = 100) plot(u, Ker.quar(u), type = \"l\", main = \"Quartic Kernel\")"},{"path":"https://sipemu.github.io/fdars/reference/Ker.tri.html","id":null,"dir":"Reference","previous_headings":"","what":"Triweight Kernel ‚Äî Ker.tri","title":"Triweight Kernel ‚Äî Ker.tri","text":"Triweight Kernel","code":""},{"path":"https://sipemu.github.io/fdars/reference/Ker.tri.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Triweight Kernel ‚Äî Ker.tri","text":"","code":"Ker.tri(u)"},{"path":"https://sipemu.github.io/fdars/reference/Ker.tri.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Triweight Kernel ‚Äî Ker.tri","text":"u Numeric vector evaluation points.","code":""},{"path":"https://sipemu.github.io/fdars/reference/Ker.tri.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Triweight Kernel ‚Äî Ker.tri","text":"Kernel values u (0 outside [-1, 1]).","code":""},{"path":"https://sipemu.github.io/fdars/reference/Ker.tri.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Triweight Kernel ‚Äî Ker.tri","text":"","code":"u <- seq(-1.5, 1.5, length.out = 100) plot(u, Ker.tri(u), type = \"l\", main = \"Triweight Kernel\")"},{"path":"https://sipemu.github.io/fdars/reference/Ker.unif.html","id":null,"dir":"Reference","previous_headings":"","what":"Uniform (Rectangular) Kernel ‚Äî Ker.unif","title":"Uniform (Rectangular) Kernel ‚Äî Ker.unif","text":"Uniform (Rectangular) Kernel","code":""},{"path":"https://sipemu.github.io/fdars/reference/Ker.unif.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Uniform (Rectangular) Kernel ‚Äî Ker.unif","text":"","code":"Ker.unif(u)"},{"path":"https://sipemu.github.io/fdars/reference/Ker.unif.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Uniform (Rectangular) Kernel ‚Äî Ker.unif","text":"u Numeric vector evaluation points.","code":""},{"path":"https://sipemu.github.io/fdars/reference/Ker.unif.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Uniform (Rectangular) Kernel ‚Äî Ker.unif","text":"Kernel values u (0 outside [-1, 1]).","code":""},{"path":"https://sipemu.github.io/fdars/reference/Ker.unif.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Uniform (Rectangular) Kernel ‚Äî Ker.unif","text":"","code":"u <- seq(-1.5, 1.5, length.out = 100) plot(u, Ker.unif(u), type = \"l\", main = \"Uniform Kernel\")"},{"path":"https://sipemu.github.io/fdars/reference/Kernel.asymmetric.html","id":null,"dir":"Reference","previous_headings":"","what":"Unified Asymmetric Kernel Interface ‚Äî Kernel.asymmetric","title":"Unified Asymmetric Kernel Interface ‚Äî Kernel.asymmetric","text":"Evaluates asymmetric kernel function name.","code":""},{"path":"https://sipemu.github.io/fdars/reference/Kernel.asymmetric.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Unified Asymmetric Kernel Interface ‚Äî Kernel.asymmetric","text":"","code":"Kernel.asymmetric(u, type.Ker = \"norm\")"},{"path":"https://sipemu.github.io/fdars/reference/Kernel.asymmetric.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Unified Asymmetric Kernel Interface ‚Äî Kernel.asymmetric","text":"u Numeric vector evaluation points. type.Ker Kernel type: \"norm\", \"epa\", \"tri\", \"quar\", \"cos\", \"unif\".","code":""},{"path":"https://sipemu.github.io/fdars/reference/Kernel.asymmetric.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Unified Asymmetric Kernel Interface ‚Äî Kernel.asymmetric","text":"Kernel values u.","code":""},{"path":"https://sipemu.github.io/fdars/reference/Kernel.asymmetric.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Unified Asymmetric Kernel Interface ‚Äî Kernel.asymmetric","text":"","code":"u <- seq(-0.5, 1.5, length.out = 100) plot(u, Kernel.asymmetric(u, \"epa\"), type = \"l\")"},{"path":"https://sipemu.github.io/fdars/reference/Kernel.html","id":null,"dir":"Reference","previous_headings":"","what":"Unified Symmetric Kernel Interface ‚Äî Kernel","title":"Unified Symmetric Kernel Interface ‚Äî Kernel","text":"Evaluates symmetric kernel function name.","code":""},{"path":"https://sipemu.github.io/fdars/reference/Kernel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Unified Symmetric Kernel Interface ‚Äî Kernel","text":"","code":"Kernel(u, type.Ker = \"norm\")"},{"path":"https://sipemu.github.io/fdars/reference/Kernel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Unified Symmetric Kernel Interface ‚Äî Kernel","text":"u Numeric vector evaluation points. type.Ker Kernel type: \"norm\", \"epa\", \"tri\", \"quar\", \"cos\", \"unif\".","code":""},{"path":"https://sipemu.github.io/fdars/reference/Kernel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Unified Symmetric Kernel Interface ‚Äî Kernel","text":"Kernel values u.","code":""},{"path":"https://sipemu.github.io/fdars/reference/Kernel.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Unified Symmetric Kernel Interface ‚Äî Kernel","text":"","code":"u <- seq(-1.5, 1.5, length.out = 100) plot(u, Kernel(u, \"epa\"), type = \"l\") lines(u, Kernel(u, \"norm\"), col = \"red\")"},{"path":"https://sipemu.github.io/fdars/reference/Kernel.integrate.html","id":null,"dir":"Reference","previous_headings":"","what":"Unified Integrated Kernel Interface ‚Äî Kernel.integrate","title":"Unified Integrated Kernel Interface ‚Äî Kernel.integrate","text":"Evaluates integrated kernel function name.","code":""},{"path":"https://sipemu.github.io/fdars/reference/Kernel.integrate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Unified Integrated Kernel Interface ‚Äî Kernel.integrate","text":"","code":"Kernel.integrate(u, Ker = \"norm\", a = -1)"},{"path":"https://sipemu.github.io/fdars/reference/Kernel.integrate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Unified Integrated Kernel Interface ‚Äî Kernel.integrate","text":"u Numeric vector evaluation points. Ker Kernel type: \"norm\", \"epa\", \"tri\", \"quar\", \"cos\", \"unif\". Lower integration bound (default -1 symmetric kernels). currently used (always integrates -1 -Inf).","code":""},{"path":"https://sipemu.github.io/fdars/reference/Kernel.integrate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Unified Integrated Kernel Interface ‚Äî Kernel.integrate","text":"Cumulative integral values.","code":""},{"path":"https://sipemu.github.io/fdars/reference/Kernel.integrate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Unified Integrated Kernel Interface ‚Äî Kernel.integrate","text":"","code":"u <- seq(-1.5, 1.5, length.out = 100) plot(u, Kernel.integrate(u, \"epa\"), type = \"l\")"},{"path":"https://sipemu.github.io/fdars/reference/S.KNN.html","id":null,"dir":"Reference","previous_headings":"","what":"K-Nearest Neighbors Smoother Matrix ‚Äî S.KNN","title":"K-Nearest Neighbors Smoother Matrix ‚Äî S.KNN","text":"Compute smoother matrix using adaptive bandwidth based k nearest neighbors. bandwidth point distance k-th nearest neighbor.","code":""},{"path":"https://sipemu.github.io/fdars/reference/S.KNN.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"K-Nearest Neighbors Smoother Matrix ‚Äî S.KNN","text":"","code":"S.KNN(tt, knn, Ker = \"norm\", w = NULL, cv = FALSE)"},{"path":"https://sipemu.github.io/fdars/reference/S.KNN.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"K-Nearest Neighbors Smoother Matrix ‚Äî S.KNN","text":"tt Evaluation points (numeric vector). knn Number nearest neighbors. Ker Kernel function name. w Optional weights vector. cv Logical. TRUE, compute leave-one-cross-validation matrix.","code":""},{"path":"https://sipemu.github.io/fdars/reference/S.KNN.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"K-Nearest Neighbors Smoother Matrix ‚Äî S.KNN","text":"n x n smoother matrix S.","code":""},{"path":"https://sipemu.github.io/fdars/reference/S.KNN.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"K-Nearest Neighbors Smoother Matrix ‚Äî S.KNN","text":"","code":"tt <- seq(0, 1, length.out = 50) S <- S.KNN(tt, knn = 10)"},{"path":"https://sipemu.github.io/fdars/reference/S.LCR.html","id":null,"dir":"Reference","previous_headings":"","what":"Local Cubic Regression Smoother Matrix ‚Äî S.LCR","title":"Local Cubic Regression Smoother Matrix ‚Äî S.LCR","text":"Convenience function Local Polynomial Regression degree 3.","code":""},{"path":"https://sipemu.github.io/fdars/reference/S.LCR.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Local Cubic Regression Smoother Matrix ‚Äî S.LCR","text":"","code":"S.LCR(tt, h, Ker = \"norm\", w = NULL, cv = FALSE)"},{"path":"https://sipemu.github.io/fdars/reference/S.LCR.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Local Cubic Regression Smoother Matrix ‚Äî S.LCR","text":"tt Evaluation points (numeric vector). h Bandwidth parameter. Ker Kernel function name. w Optional weights vector. cv Logical. TRUE, compute leave-one-cross-validation matrix.","code":""},{"path":"https://sipemu.github.io/fdars/reference/S.LCR.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Local Cubic Regression Smoother Matrix ‚Äî S.LCR","text":"n x n smoother matrix S.","code":""},{"path":"https://sipemu.github.io/fdars/reference/S.LCR.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Local Cubic Regression Smoother Matrix ‚Äî S.LCR","text":"","code":"tt <- seq(0, 1, length.out = 50) S <- S.LCR(tt, h = 0.15)"},{"path":"https://sipemu.github.io/fdars/reference/S.LLR.html","id":null,"dir":"Reference","previous_headings":"","what":"Local Linear Regression Smoother Matrix ‚Äî S.LLR","title":"Local Linear Regression Smoother Matrix ‚Äî S.LLR","text":"Compute Local Linear Regression (LLR) smoother matrix. LLR better boundary bias properties Nadaraya-Watson.","code":""},{"path":"https://sipemu.github.io/fdars/reference/S.LLR.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Local Linear Regression Smoother Matrix ‚Äî S.LLR","text":"","code":"S.LLR(tt, h, Ker = \"norm\", w = NULL, cv = FALSE)"},{"path":"https://sipemu.github.io/fdars/reference/S.LLR.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Local Linear Regression Smoother Matrix ‚Äî S.LLR","text":"tt Evaluation points (numeric vector). h Bandwidth parameter. Ker Kernel function name. One \"norm\", \"epa\", \"tri\", \"quar\", \"cos\", \"unif\". w Optional weights vector length n. cv Logical. TRUE, compute leave-one-cross-validation matrix.","code":""},{"path":"https://sipemu.github.io/fdars/reference/S.LLR.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Local Linear Regression Smoother Matrix ‚Äî S.LLR","text":"n x n smoother matrix S.","code":""},{"path":"https://sipemu.github.io/fdars/reference/S.LLR.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Local Linear Regression Smoother Matrix ‚Äî S.LLR","text":"","code":"tt <- seq(0, 1, length.out = 50) S <- S.LLR(tt, h = 0.1)"},{"path":"https://sipemu.github.io/fdars/reference/S.LPR.html","id":null,"dir":"Reference","previous_headings":"","what":"Local Polynomial Regression Smoother Matrix ‚Äî S.LPR","title":"Local Polynomial Regression Smoother Matrix ‚Äî S.LPR","text":"Compute Local Polynomial Regression smoother matrix degree p. Special cases: p=0 Nadaraya-Watson, p=1 Local Linear Regression.","code":""},{"path":"https://sipemu.github.io/fdars/reference/S.LPR.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Local Polynomial Regression Smoother Matrix ‚Äî S.LPR","text":"","code":"S.LPR(tt, h, p = 1, Ker = \"norm\", w = NULL, cv = FALSE)"},{"path":"https://sipemu.github.io/fdars/reference/S.LPR.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Local Polynomial Regression Smoother Matrix ‚Äî S.LPR","text":"tt Evaluation points (numeric vector). h Bandwidth parameter. p Polynomial degree (default 1 local linear). Ker Kernel function name. w Optional weights vector. cv Logical. TRUE, compute leave-one-cross-validation matrix.","code":""},{"path":"https://sipemu.github.io/fdars/reference/S.LPR.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Local Polynomial Regression Smoother Matrix ‚Äî S.LPR","text":"n x n smoother matrix S.","code":""},{"path":"https://sipemu.github.io/fdars/reference/S.LPR.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Local Polynomial Regression Smoother Matrix ‚Äî S.LPR","text":"","code":"tt <- seq(0, 1, length.out = 50) S <- S.LPR(tt, h = 0.1, p = 2)  # Local quadratic regression"},{"path":"https://sipemu.github.io/fdars/reference/S.NW.html","id":null,"dir":"Reference","previous_headings":"","what":"Smoothing Functions for Functional Data ‚Äî S.NW","title":"Smoothing Functions for Functional Data ‚Äî S.NW","text":"Functions computing smoothing matrices applying kernel smoothing functional data. Nadaraya-Watson Kernel Smoother Matrix","code":""},{"path":"https://sipemu.github.io/fdars/reference/S.NW.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Smoothing Functions for Functional Data ‚Äî S.NW","text":"","code":"S.NW(tt, h, Ker = \"norm\", w = NULL, cv = FALSE)"},{"path":"https://sipemu.github.io/fdars/reference/S.NW.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Smoothing Functions for Functional Data ‚Äî S.NW","text":"tt Evaluation points (numeric vector). h Bandwidth parameter. Ker Kernel function name. One \"norm\", \"epa\", \"tri\", \"quar\", \"cos\", \"unif\", custom function. w Optional weights vector length n. cv Logical. TRUE, compute leave-one-cross-validation matrix (diagonal zero).","code":""},{"path":"https://sipemu.github.io/fdars/reference/S.NW.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Smoothing Functions for Functional Data ‚Äî S.NW","text":"n x n smoother matrix S smooth(y) = S %*% y.","code":""},{"path":"https://sipemu.github.io/fdars/reference/S.NW.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Smoothing Functions for Functional Data ‚Äî S.NW","text":"Compute Nadaraya-Watson kernel smoother matrix.","code":""},{"path":"https://sipemu.github.io/fdars/reference/S.NW.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Smoothing Functions for Functional Data ‚Äî S.NW","text":"","code":"tt <- seq(0, 1, length.out = 50) S <- S.NW(tt, h = 0.1) dim(S)  # 50 x 50 #> [1] 50 50"},{"path":"https://sipemu.github.io/fdars/reference/analyze_peak_timing.html","id":null,"dir":"Reference","previous_headings":"","what":"Analyze Peak Timing Variability ‚Äî analyze_peak_timing","title":"Analyze Peak Timing Variability ‚Äî analyze_peak_timing","text":"short series (e.g., 3-5 years yearly data), function detects one peak per cycle analyzes peak timing varies cycles.","code":""},{"path":"https://sipemu.github.io/fdars/reference/analyze_peak_timing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Analyze Peak Timing Variability ‚Äî analyze_peak_timing","text":"","code":"analyze_peak_timing(fdataobj, period, smooth_lambda = NULL)"},{"path":"https://sipemu.github.io/fdars/reference/analyze_peak_timing.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Analyze Peak Timing Variability ‚Äî analyze_peak_timing","text":"fdataobj fdata object. period Known period (e.g., 365 daily data yearly seasonality). smooth_lambda Smoothing parameter. NULL, uses GCV automatic selection. Default: NULL.","code":""},{"path":"https://sipemu.github.io/fdars/reference/analyze_peak_timing.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Analyze Peak Timing Variability ‚Äî analyze_peak_timing","text":"list components: peak_times Vector peak times peak_values Vector peak values normalized_timing Position within cycle (0-1 scale) mean_timing Mean normalized timing std_timing Standard deviation normalized timing range_timing Range normalized timing (max - min) variability_score Variability score (0 = stable, 1 = highly variable) timing_trend Linear trend timing (positive = peaks getting later) cycle_indices Cycle indices (1-indexed)","code":""},{"path":"https://sipemu.github.io/fdars/reference/analyze_peak_timing.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Analyze Peak Timing Variability ‚Äî analyze_peak_timing","text":"variability score computed std_timing / 0.1, capped 1. score > 0.5 suggests peaks shifting substantially cycles. timing_trend indicates peaks systematically moving earlier later time.","code":""},{"path":"https://sipemu.github.io/fdars/reference/analyze_peak_timing.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Analyze Peak Timing Variability ‚Äî analyze_peak_timing","text":"","code":"# 5 years of yearly data where peak shifts t <- seq(0, 5, length.out = 365 * 5) periods <- c(1, 1, 1, 1, 1)  # 5 complete years # Peaks shift: March (0.2), April (0.3), May (0.4), April (0.3), March (0.2) peak_phases <- c(0.2, 0.3, 0.4, 0.3, 0.2) X <- sin(2 * pi * t + rep(peak_phases, each = 365)) fd <- fdata(matrix(X, nrow = 1), argvals = t)  result <- analyze_peak_timing(fd, period = 1) print(result$variability_score)  # Shows timing variability #> [1] 0.1168162"},{"path":"https://sipemu.github.io/fdars/reference/autoplot.fdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a ggplot for fdata objects ‚Äî autoplot.fdata","title":"Create a ggplot for fdata objects ‚Äî autoplot.fdata","text":"1D functional data, plots curves lines optional coloring external variables. 2D functional data, plots surfaces heatmaps contour lines.","code":""},{"path":"https://sipemu.github.io/fdars/reference/autoplot.fdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a ggplot for fdata objects ‚Äî autoplot.fdata","text":"","code":"# S3 method for class 'fdata' autoplot(   object,   color = NULL,   alpha = NULL,   show.mean = FALSE,   show.ci = FALSE,   ci.level = 0.9,   palette = NULL,   ... )"},{"path":"https://sipemu.github.io/fdars/reference/autoplot.fdata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a ggplot for fdata objects ‚Äî autoplot.fdata","text":"object object class 'fdata'. color Optional vector coloring curves. Can : Numeric vector: curves colored continuous scale (viridis) Factor/character: curves colored discrete groups Must length equal number curves. alpha Transparency individual curve lines. Default 0.7 basic plots, automatically reduced 0.3 show.mean = TRUE show.ci = TRUE reduce visual clutter allow mean curves stand . Can explicitly set override default. show.mean Logical. TRUE color categorical, overlay group mean curves thicker lines (default FALSE). show.ci Logical. TRUE color categorical, show pointwise confidence interval ribbons per group (default FALSE). ci.level Confidence level CI ribbons (default 0.90 90 percent). palette Optional named vector colors categorical coloring, e.g., c(\"\" = \"blue\", \"B\" = \"red\"). ... Additional arguments (currently ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/autoplot.fdata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a ggplot for fdata objects ‚Äî autoplot.fdata","text":"ggplot object.","code":""},{"path":"https://sipemu.github.io/fdars/reference/autoplot.fdata.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a ggplot for fdata objects ‚Äî autoplot.fdata","text":"Use autoplot() get ggplot object without displaying . Use plot() display plot (returns invisibly).","code":""},{"path":"https://sipemu.github.io/fdars/reference/autoplot.fdata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a ggplot for fdata objects ‚Äî autoplot.fdata","text":"","code":"# Get ggplot object without displaying fd <- fdata(matrix(rnorm(200), 20, 10)) p <- autoplot(fd) #> Error in autoplot(fd): could not find function \"autoplot\"  # Customize the plot p + ggplot2::theme_minimal() #> Error: object 'p' not found  # Color by numeric variable y <- rnorm(20) autoplot(fd, color = y) #> Error in autoplot(fd, color = y): could not find function \"autoplot\"  # Color by category with mean and CI groups <- factor(rep(c(\"A\", \"B\"), each = 10)) autoplot(fd, color = groups, show.mean = TRUE, show.ci = TRUE) #> Error in autoplot(fd, color = groups, show.mean = TRUE, show.ci = TRUE): could not find function \"autoplot\""},{"path":"https://sipemu.github.io/fdars/reference/basis.aic.html","id":null,"dir":"Reference","previous_headings":"","what":"AIC for Basis Representation ‚Äî basis.aic","title":"AIC for Basis Representation ‚Äî basis.aic","text":"Computes Akaike Information Criterion basis representation. Lower AIC indicates better model (balancing fit complexity).","code":""},{"path":"https://sipemu.github.io/fdars/reference/basis.aic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"AIC for Basis Representation ‚Äî basis.aic","text":"","code":"basis.aic(   fdataobj,   nbasis,   type = c(\"bspline\", \"fourier\"),   lambda = 0,   pooled = TRUE )"},{"path":"https://sipemu.github.io/fdars/reference/basis.aic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"AIC for Basis Representation ‚Äî basis.aic","text":"fdataobj fdata object. nbasis Number basis functions. type Basis type: \"bspline\" (default) \"fourier\". lambda Smoothing/penalty parameter (default 0). pooled Logical. TRUE (default), compute single AIC across curves. FALSE, compute AIC curve return mean.","code":""},{"path":"https://sipemu.github.io/fdars/reference/basis.aic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"AIC for Basis Representation ‚Äî basis.aic","text":"AIC value (scalar).","code":""},{"path":"https://sipemu.github.io/fdars/reference/basis.aic.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"AIC for Basis Representation ‚Äî basis.aic","text":"AIC computed : $$AIC = n \\log(RSS/n) + 2 \\cdot edf$$ pooled = TRUE, criterion uses total observations total effective degrees freedom (n_curves * edf). pooled = FALSE, criterion computed curve separately mean returned.","code":""},{"path":"https://sipemu.github.io/fdars/reference/basis.bic.html","id":null,"dir":"Reference","previous_headings":"","what":"BIC for Basis Representation ‚Äî basis.bic","title":"BIC for Basis Representation ‚Äî basis.bic","text":"Computes Bayesian Information Criterion basis representation. BIC penalizes complexity strongly AIC larger samples.","code":""},{"path":"https://sipemu.github.io/fdars/reference/basis.bic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"BIC for Basis Representation ‚Äî basis.bic","text":"","code":"basis.bic(   fdataobj,   nbasis,   type = c(\"bspline\", \"fourier\"),   lambda = 0,   pooled = TRUE )"},{"path":"https://sipemu.github.io/fdars/reference/basis.bic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"BIC for Basis Representation ‚Äî basis.bic","text":"fdataobj fdata object. nbasis Number basis functions. type Basis type: \"bspline\" (default) \"fourier\". lambda Smoothing/penalty parameter (default 0). pooled Logical. TRUE (default), compute single BIC across curves. FALSE, compute BIC curve return mean.","code":""},{"path":"https://sipemu.github.io/fdars/reference/basis.bic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"BIC for Basis Representation ‚Äî basis.bic","text":"BIC value (scalar).","code":""},{"path":"https://sipemu.github.io/fdars/reference/basis.bic.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"BIC for Basis Representation ‚Äî basis.bic","text":"BIC computed : $$BIC = n \\log(RSS/n) + \\log(n) \\cdot edf$$ pooled = TRUE, criterion uses total observations total effective degrees freedom (n_curves * edf). pooled = FALSE, criterion computed curve separately mean returned.","code":""},{"path":"https://sipemu.github.io/fdars/reference/basis.gcv.html","id":null,"dir":"Reference","previous_headings":"","what":"GCV Score for Basis Representation ‚Äî basis.gcv","title":"GCV Score for Basis Representation ‚Äî basis.gcv","text":"Computes Generalized Cross-Validation score basis representation. Lower GCV indicates better fit appropriate complexity.","code":""},{"path":"https://sipemu.github.io/fdars/reference/basis.gcv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"GCV Score for Basis Representation ‚Äî basis.gcv","text":"","code":"basis.gcv(   fdataobj,   nbasis,   type = c(\"bspline\", \"fourier\"),   lambda = 0,   pooled = TRUE )"},{"path":"https://sipemu.github.io/fdars/reference/basis.gcv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"GCV Score for Basis Representation ‚Äî basis.gcv","text":"fdataobj fdata object. nbasis Number basis functions. type Basis type: \"bspline\" (default) \"fourier\". lambda Smoothing/penalty parameter (default 0, penalty). pooled Logical. TRUE (default), compute single GCV across curves. FALSE, compute GCV curve return mean.","code":""},{"path":"https://sipemu.github.io/fdars/reference/basis.gcv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"GCV Score for Basis Representation ‚Äî basis.gcv","text":"GCV score (scalar).","code":""},{"path":"https://sipemu.github.io/fdars/reference/basis.gcv.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"GCV Score for Basis Representation ‚Äî basis.gcv","text":"GCV computed : $$GCV = \\frac{RSS/n}{(1 - edf/n)^2}$$ RSS residual sum squares edf effective degrees freedom (trace hat matrix). pooled = TRUE, criterion computed globally across curves. pooled = FALSE, criterion computed curve separately mean returned. Use pooled = FALSE curves heterogeneous noise levels.","code":""},{"path":"https://sipemu.github.io/fdars/reference/basis.gcv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"GCV Score for Basis Representation ‚Äî basis.gcv","text":"","code":"t <- seq(0, 1, length.out = 50) X <- matrix(sin(2 * pi * t) + rnorm(50, sd = 0.1), nrow = 1) fd <- fdata(X, argvals = t)  # Compare GCV for different nbasis gcv_5 <- basis.gcv(fd, nbasis = 5) gcv_10 <- basis.gcv(fd, nbasis = 10) gcv_20 <- basis.gcv(fd, nbasis = 20)"},{"path":"https://sipemu.github.io/fdars/reference/basis2fdata.2d.html","id":null,"dir":"Reference","previous_headings":"","what":"Reconstruct 2D Functional Data from Tensor Product Basis Coefficients ‚Äî basis2fdata.2d","title":"Reconstruct 2D Functional Data from Tensor Product Basis Coefficients ‚Äî basis2fdata.2d","text":"Reconstructs 2D surfaces tensor product basis coefficients.","code":""},{"path":"https://sipemu.github.io/fdars/reference/basis2fdata.2d.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reconstruct 2D Functional Data from Tensor Product Basis Coefficients ‚Äî basis2fdata.2d","text":"","code":"basis2fdata.2d(   coefs,   argvals,   nbasis.s,   nbasis.t,   type = c(\"bspline\", \"fourier\") )"},{"path":"https://sipemu.github.io/fdars/reference/basis2fdata.2d.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Reconstruct 2D Functional Data from Tensor Product Basis Coefficients ‚Äî basis2fdata.2d","text":"coefs Coefficient matrix [n x (nbasis.s * nbasis.t)]. argvals List two numeric vectors s t coordinates. nbasis.s Number basis functions s direction. nbasis.t Number basis functions t direction. type Basis type: \"bspline\" (default) \"fourier\".","code":""},{"path":"https://sipemu.github.io/fdars/reference/basis2fdata.2d.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Reconstruct 2D Functional Data from Tensor Product Basis Coefficients ‚Äî basis2fdata.2d","text":"2D fdata object.","code":""},{"path":"https://sipemu.github.io/fdars/reference/basis2fdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Basis Representation Functions for Functional Data ‚Äî basis2fdata","title":"Basis Representation Functions for Functional Data ‚Äî basis2fdata","text":"Functions representing functional data using basis expansions, including B-splines, Fourier bases, P-splines penalization. Reconstruct Functional Data Basis Coefficients","code":""},{"path":"https://sipemu.github.io/fdars/reference/basis2fdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Basis Representation Functions for Functional Data ‚Äî basis2fdata","text":"","code":"basis2fdata(   coefs,   argvals,   nbasis = NULL,   type = c(\"bspline\", \"fourier\"),   rangeval = NULL )"},{"path":"https://sipemu.github.io/fdars/reference/basis2fdata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Basis Representation Functions for Functional Data ‚Äî basis2fdata","text":"coefs Coefficient matrix [n x nbasis] n number curves nbasis number basis functions. Can also vector single curve. argvals Numeric vector evaluation points reconstruction. nbasis Number basis functions. NULL, inferred ncol(coefs). type Basis type: \"bspline\" (default) \"fourier\". rangeval Range argvals. Default: range(argvals).","code":""},{"path":"https://sipemu.github.io/fdars/reference/basis2fdata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Basis Representation Functions for Functional Data ‚Äî basis2fdata","text":"fdata object reconstructed curves.","code":""},{"path":"https://sipemu.github.io/fdars/reference/basis2fdata.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Basis Representation Functions for Functional Data ‚Äî basis2fdata","text":"Given basis coefficients, reconstruct functional data evaluating basis expansion specified argument values. reconstruction computes X(t) = sum(coef_k * B_k(t)) B_k basis functions evaluated argvals.","code":""},{"path":"https://sipemu.github.io/fdars/reference/basis2fdata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Basis Representation Functions for Functional Data ‚Äî basis2fdata","text":"","code":"# Create some functional data t <- seq(0, 1, length.out = 100) X <- matrix(sin(2 * pi * t), nrow = 1) fd <- fdata(X, argvals = t)  # Project to basis and reconstruct coefs <- fdata2basis(fd, nbasis = 15, type = \"fourier\") fd_recon <- basis2fdata(coefs, argvals = t, type = \"fourier\")"},{"path":"https://sipemu.github.io/fdars/reference/boxplot.fdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Functional Boxplot ‚Äî boxplot.fdata","title":"Functional Boxplot ‚Äî boxplot.fdata","text":"Creates functional boxplot visualizing distribution functional data. boxplot shows median curve, central 50 percent envelope, fence (equivalent whiskers), outliers.","code":""},{"path":"https://sipemu.github.io/fdars/reference/boxplot.fdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functional Boxplot ‚Äî boxplot.fdata","text":"","code":"# S3 method for class 'fdata' boxplot(   x,   prob = 0.5,   factor = 1.5,   depth.func = depth.MBD,   show.outliers = TRUE,   col.median = \"black\",   col.envelope = \"magenta\",   col.fence = \"pink\",   col.outliers = \"red\",   ... )"},{"path":"https://sipemu.github.io/fdars/reference/boxplot.fdata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functional Boxplot ‚Äî boxplot.fdata","text":"x object class 'fdata'. prob Proportion curves central region (default 0.5 50 percent). factor Factor fence calculation (default 1.5, standard boxplots). depth.func Depth function use. Default depth.MBD. show.outliers Logical. TRUE (default), show outlier curves. col.median Color median curve (default \"black\"). col.envelope Color central envelope (default \"magenta\"). col.fence Color fence region (default \"pink\"). col.outliers Color outlier curves (default \"red\"). ... Additional arguments passed depth function.","code":""},{"path":"https://sipemu.github.io/fdars/reference/boxplot.fdata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functional Boxplot ‚Äî boxplot.fdata","text":"list class 'fbplot' components: median Index median curve central Indices curves central region outliers Indices outlier curves depth Depth values curves plot ggplot object","code":""},{"path":"https://sipemu.github.io/fdars/reference/boxplot.fdata.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Functional Boxplot ‚Äî boxplot.fdata","text":"functional boxplot (Sun & Genton, 2011) generalizes standard boxplot functional data using depth ordering: Median: curve maximum depth Central region: Envelope curves top 50 percent depth Fence: 1.5 times envelope width beyond central region Outliers: Curves exceed fence point","code":""},{"path":"https://sipemu.github.io/fdars/reference/boxplot.fdata.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Functional Boxplot ‚Äî boxplot.fdata","text":"Sun, Y. Genton, M.G. (2011). Functional boxplots. Journal Computational Graphical Statistics, 20(2), 316-334.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/reference/boxplot.fdata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Functional Boxplot ‚Äî boxplot.fdata","text":"","code":"# Create functional data with outliers set.seed(42) t <- seq(0, 1, length.out = 50) X <- matrix(0, 30, 50) for (i in 1:28) X[i, ] <- sin(2*pi*t) + rnorm(50, sd = 0.2) X[29, ] <- sin(2*pi*t) + 2  # Magnitude outlier X[30, ] <- cos(2*pi*t)       # Shape outlier fd <- fdata(X, argvals = t)  # Create functional boxplot fbp <- boxplot(fd)"},{"path":"https://sipemu.github.io/fdars/reference/classify_seasonality.html","id":null,"dir":"Reference","previous_headings":"","what":"Classify Seasonality Type ‚Äî classify_seasonality","title":"Classify Seasonality Type ‚Äî classify_seasonality","text":"Classifies type seasonality functional data. Particularly useful short series (3-5 years) identify stable vs variable timing patterns.","code":""},{"path":"https://sipemu.github.io/fdars/reference/classify_seasonality.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Classify Seasonality Type ‚Äî classify_seasonality","text":"","code":"classify_seasonality(   fdataobj,   period,   strength_threshold = NULL,   timing_threshold = NULL )"},{"path":"https://sipemu.github.io/fdars/reference/classify_seasonality.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Classify Seasonality Type ‚Äî classify_seasonality","text":"fdataobj fdata object. period Known seasonal period. strength_threshold Threshold seasonal/non-seasonal (default: 0.3). timing_threshold Max std normalized timing \"stable\" (default: 0.05).","code":""},{"path":"https://sipemu.github.io/fdars/reference/classify_seasonality.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Classify Seasonality Type ‚Äî classify_seasonality","text":"list components: is_seasonal Logical: series seasonal overall? has_stable_timing Logical: peak timing stable across cycles? timing_variability Timing variability score (0-1) seasonal_strength Overall seasonal strength cycle_strengths Per-cycle seasonal strength weak_seasons Indices weak/missing seasons (0-indexed) classification One : \"StableSeasonal\", \"VariableTiming\", \"IntermittentSeasonal\", \"NonSeasonal\" peak_timing Peak timing analysis (peaks detected)","code":""},{"path":"https://sipemu.github.io/fdars/reference/classify_seasonality.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Classify Seasonality Type ‚Äî classify_seasonality","text":"Classification types: StableSeasonal: Regular peaks consistent timing VariableTiming: Regular peaks timing shifts cycles IntermittentSeasonal: cycles seasonal, NonSeasonal: clear seasonality","code":""},{"path":"https://sipemu.github.io/fdars/reference/classify_seasonality.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Classify Seasonality Type ‚Äî classify_seasonality","text":"","code":"# Pure seasonal signal t <- seq(0, 10, length.out = 500) X <- matrix(sin(2 * pi * t / 2), nrow = 1) fd <- fdata(X, argvals = t)  result <- classify_seasonality(fd, period = 2) print(result$classification)  # \"StableSeasonal\" #> [1] \"StableSeasonal\""},{"path":"https://sipemu.github.io/fdars/reference/cluster.fcm.html","id":null,"dir":"Reference","previous_headings":"","what":"Fuzzy C-Means Clustering for Functional Data ‚Äî cluster.fcm","title":"Fuzzy C-Means Clustering for Functional Data ‚Äî cluster.fcm","text":"Performs fuzzy c-means clustering functional data, curve membership degree cluster rather hard assignment.","code":""},{"path":"https://sipemu.github.io/fdars/reference/cluster.fcm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fuzzy C-Means Clustering for Functional Data ‚Äî cluster.fcm","text":"","code":"cluster.fcm(fdataobj, ncl, m = 2, max.iter = 100, tol = 1e-06, seed = NULL)"},{"path":"https://sipemu.github.io/fdars/reference/cluster.fcm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fuzzy C-Means Clustering for Functional Data ‚Äî cluster.fcm","text":"fdataobj object class 'fdata'. ncl Number clusters. m Fuzziness parameter (default 2). Must > 1. Higher values give softer cluster boundaries. max.iter Maximum number iterations (default 100). tol Convergence tolerance (default 1e-6). seed Optional random seed reproducibility.","code":""},{"path":"https://sipemu.github.io/fdars/reference/cluster.fcm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fuzzy C-Means Clustering for Functional Data ‚Äî cluster.fcm","text":"list class 'fuzzycmeans.fd' components: membership Matrix membership degrees (n x ncl). row sums 1. cluster Hard cluster assignments (argmax membership). centers fdata object containing cluster centers. objective Final value objective function. fdataobj input functional data object.","code":""},{"path":"https://sipemu.github.io/fdars/reference/cluster.fcm.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fuzzy C-Means Clustering for Functional Data ‚Äî cluster.fcm","text":"Fuzzy c-means minimizes objective function: $$J = \\sum_{=1}^n \\sum_{c=1}^k u_{ic}^m ||X_i - v_c||^2$$ u_ic membership curve cluster c, v_c cluster center, m fuzziness parameter. membership degrees updated : $$u_{ic} = 1 / \\sum_{j=1}^k (d_{ic}/d_{ij})^{2/(m-1)}$$ m approaches 1, FCM becomes equivalent hard k-means. m increases, clusters become softer (overlap). m = 2 common choice.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/reference/cluster.fcm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fuzzy C-Means Clustering for Functional Data ‚Äî cluster.fcm","text":"","code":"# Create functional data with two overlapping groups set.seed(42) t <- seq(0, 1, length.out = 50) n <- 30 X <- matrix(0, n, 50) for (i in 1:15) X[i, ] <- sin(2*pi*t) + rnorm(50, sd = 0.2) for (i in 16:30) X[i, ] <- cos(2*pi*t) + rnorm(50, sd = 0.2) fd <- fdata(X, argvals = t)  # Fuzzy clustering fcm <- cluster.fcm(fd, ncl = 2) print(fcm) #> Fuzzy C-Means Clustering #> ======================== #> Number of clusters: 2  #> Number of observations: 30  #> Fuzziness parameter m: 2  #>  #> Cluster sizes (hard assignment): #>  #>  1  2  #> 15 15  #>  #> Objective function: 1.0911  #>  #> Average membership per cluster: #>  C1  C2  #> 0.5 0.5  plot(fcm)   # View membership degrees for first few curves head(fcm$membership) #>           [,1]         [,2] #> [1,] 0.9982817 0.0017182508 #> [2,] 0.9988480 0.0011520129 #> [3,] 0.9991014 0.0008985602 #> [4,] 0.9991047 0.0008952578 #> [5,] 0.9990083 0.0009917289 #> [6,] 0.9987222 0.0012778225"},{"path":"https://sipemu.github.io/fdars/reference/cluster.init.html","id":null,"dir":"Reference","previous_headings":"","what":"K-Means++ Center Initialization ‚Äî cluster.init","title":"K-Means++ Center Initialization ‚Äî cluster.init","text":"Initialize cluster centers using k-means++ algorithm, selects centers probability proportional squared distance existing centers.","code":""},{"path":"https://sipemu.github.io/fdars/reference/cluster.init.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"K-Means++ Center Initialization ‚Äî cluster.init","text":"","code":"cluster.init(fdataobj, ncl, metric = \"L2\", seed = NULL)"},{"path":"https://sipemu.github.io/fdars/reference/cluster.init.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"K-Means++ Center Initialization ‚Äî cluster.init","text":"fdataobj object class 'fdata'. ncl Number clusters. metric Metric use. One \"L2\", \"L1\", \"Linf\". seed Optional random seed.","code":""},{"path":"https://sipemu.github.io/fdars/reference/cluster.init.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"K-Means++ Center Initialization ‚Äî cluster.init","text":"fdata object containing initial cluster centers.","code":""},{"path":"https://sipemu.github.io/fdars/reference/cluster.init.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"K-Means++ Center Initialization ‚Äî cluster.init","text":"","code":"t <- seq(0, 1, length.out = 50) X <- matrix(rnorm(30 * 50), 30, 50) fd <- fdata(X, argvals = t) init_centers <- cluster.init(fd, ncl = 3)"},{"path":"https://sipemu.github.io/fdars/reference/cluster.kmeans.html","id":null,"dir":"Reference","previous_headings":"","what":"Clustering Functions for Functional Data ‚Äî cluster.kmeans","title":"Clustering Functions for Functional Data ‚Äî cluster.kmeans","text":"Functions clustering functional data, including k-means related algorithms. Functional K-Means Clustering","code":""},{"path":"https://sipemu.github.io/fdars/reference/cluster.kmeans.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clustering Functions for Functional Data ‚Äî cluster.kmeans","text":"","code":"cluster.kmeans(   fdataobj,   ncl,   metric = \"L2\",   max.iter = 100,   nstart = 10,   seed = NULL,   draw = FALSE,   ... )"},{"path":"https://sipemu.github.io/fdars/reference/cluster.kmeans.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Clustering Functions for Functional Data ‚Äî cluster.kmeans","text":"fdataobj object class 'fdata'. ncl Number clusters. metric Either string (\"L2\", \"L1\", \"Linf\") fast Rust-based distance computation, metric/semimetric function (e.g., metric.lp, metric.hausdorff, semimetric.pca). Using function provides flexibility may slower semimetrics computed R. max.iter Maximum number iterations (default 100). nstart Number random starts (default 10). best result (lowest within-cluster sum squares) returned. seed Optional random seed reproducibility. draw Logical. TRUE, plot clustered curves (yet implemented). ... Additional arguments passed metric function.","code":""},{"path":"https://sipemu.github.io/fdars/reference/cluster.kmeans.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Clustering Functions for Functional Data ‚Äî cluster.kmeans","text":"list class 'cluster.kmeans' components: cluster Integer vector cluster assignments (1 ncl). centers fdata object containing cluster centers. withinss Within-cluster sum squares cluster. tot.withinss Total within-cluster sum squares. size Number observations cluster. fdataobj input functional data object.","code":""},{"path":"https://sipemu.github.io/fdars/reference/cluster.kmeans.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Clustering Functions for Functional Data ‚Äî cluster.kmeans","text":"Performs k-means clustering functional data using specified metric. Uses k-means++ initialization better initial centers. metric string (\"L2\", \"L1\", \"Linf\"), entire k-means algorithm runs Rust parallel processing, providing 50-200x speedup. metric function, distances computed using function. Functions like metric.lp, metric.hausdorff, metric.DTW Rust backends remain fast. Semimetric functions (semimetric.*) computed R slower large datasets.","code":""},{"path":"https://sipemu.github.io/fdars/reference/cluster.kmeans.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Clustering Functions for Functional Data ‚Äî cluster.kmeans","text":"","code":"# Create functional data with two groups t <- seq(0, 1, length.out = 50) n <- 30 X <- matrix(0, n, 50) true_cluster <- rep(1:2, each = 15) for (i in 1:n) {   if (true_cluster[i] == 1) {     X[i, ] <- sin(2*pi*t) + rnorm(50, sd = 0.1)   } else {     X[i, ] <- cos(2*pi*t) + rnorm(50, sd = 0.1)   } } fd <- fdata(X, argvals = t)  # Cluster with string metric (fast Rust path) result <- cluster.kmeans(fd, ncl = 2, metric = \"L2\") table(result$cluster, true_cluster) #>    true_cluster #>      1  2 #>   1  0 15 #>   2 15  0  # Cluster with metric function (also fast - Rust backend) result2 <- cluster.kmeans(fd, ncl = 2, metric = metric.lp)  # Cluster with semimetric (flexible but slower) result3 <- cluster.kmeans(fd, ncl = 2, metric = semimetric.pca, ncomp = 3)"},{"path":"https://sipemu.github.io/fdars/reference/cluster.optim.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimal Number of Clusters for Functional K-Means ‚Äî cluster.optim","title":"Optimal Number of Clusters for Functional K-Means ‚Äî cluster.optim","text":"Determines optimal number clusters functional k-means clustering using various criteria: elbow method, silhouette score, Calinski-Harabasz index.","code":""},{"path":"https://sipemu.github.io/fdars/reference/cluster.optim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimal Number of Clusters for Functional K-Means ‚Äî cluster.optim","text":"","code":"cluster.optim(   fdataobj,   ncl.range = 2:10,   criterion = c(\"silhouette\", \"CH\", \"elbow\"),   metric = \"L2\",   max.iter = 100,   nstart = 10,   seed = NULL,   ... )"},{"path":"https://sipemu.github.io/fdars/reference/cluster.optim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimal Number of Clusters for Functional K-Means ‚Äî cluster.optim","text":"fdataobj object class 'fdata'. ncl.range Range number clusters evaluate. Default 2:10. criterion Criterion use selecting optimal k: \"silhouette\" Mean silhouette coefficient (default). Higher better. \"CH\" Calinski-Harabasz index. Higher better. \"elbow\" Within-cluster sum squares. Look elbow plot. metric Either string (\"L2\", \"L1\", \"Linf\") metric function. max.iter Maximum iterations k-means (default 100). nstart Number random starts (default 10). seed Random seed reproducibility. ... Additional arguments passed cluster.kmeans.","code":""},{"path":"https://sipemu.github.io/fdars/reference/cluster.optim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Optimal Number of Clusters for Functional K-Means ‚Äî cluster.optim","text":"list class 'cluster.optim' components: optimal.k Optimal number clusters based criterion criterion Name criterion used scores Vector criterion values k ncl.range Range k values tested models List cluster.kmeans objects k best.model cluster.kmeans object optimal k","code":""},{"path":"https://sipemu.github.io/fdars/reference/cluster.optim.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Optimal Number of Clusters for Functional K-Means ‚Äî cluster.optim","text":"Silhouette score: Measures similar curve cluster compared clusters. Values range -1 1, higher better. Optimal k maximizes mean silhouette. Calinski-Harabasz index: Ratio -cluster within-cluster dispersion. Higher values indicate better defined clusters. Optimal k maximizes CH. Elbow method: Plots total within-cluster sum squares vs k. optimal k \"elbow\" adding clusters significantly reduce WSS. subjective best assessed visually using plot().","code":""},{"path":"https://sipemu.github.io/fdars/reference/cluster.optim.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Optimal Number of Clusters for Functional K-Means ‚Äî cluster.optim","text":"","code":"# Create functional data with 3 groups set.seed(42) t <- seq(0, 1, length.out = 50) n <- 60 X <- matrix(0, n, 50) true_k <- rep(1:3, each = 20) for (i in 1:n) {   if (true_k[i] == 1) {     X[i, ] <- sin(2*pi*t) + rnorm(50, sd = 0.1)   } else if (true_k[i] == 2) {     X[i, ] <- cos(2*pi*t) + rnorm(50, sd = 0.1)   } else {     X[i, ] <- sin(4*pi*t) + rnorm(50, sd = 0.1)   } } fd <- fdata(X, argvals = t)  # Find optimal k using silhouette opt <- cluster.optim(fd, ncl.range = 2:6, criterion = \"silhouette\") print(opt) #> Optimal K-Means Clustering #> ========================== #> Criterion: silhouette  #> K range tested: 2 - 6  #> Optimal k: 3  #>  #> Scores by k: #>  k  score #>  2 0.5673 #>  3 0.8597 #>  4 0.6229 #>  5 0.3346 #>  6 0.0636 plot(opt)"},{"path":"https://sipemu.github.io/fdars/reference/cov.html","id":null,"dir":"Reference","previous_headings":"","what":"Functional Covariance Function ‚Äî cov","title":"Functional Covariance Function ‚Äî cov","text":"Computes covariance function (surface) functional data. 1D: Cov(s, t) = E[(X(s) - mu(s))(X(t) - mu(t))] 2D: Covariance across flattened domain.","code":""},{"path":"https://sipemu.github.io/fdars/reference/cov.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functional Covariance Function ‚Äî cov","text":"","code":"cov(fdataobj, ...)"},{"path":"https://sipemu.github.io/fdars/reference/cov.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functional Covariance Function ‚Äî cov","text":"fdataobj object class 'fdata'. ... Additional arguments (currently ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/cov.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functional Covariance Function ‚Äî cov","text":"list components: cov covariance matrix (m x m 1D, (m1m2) x (m1m2) 2D) argvals evaluation points (input) mean mean function","code":""},{"path":"https://sipemu.github.io/fdars/reference/cov.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Functional Covariance Function ‚Äî cov","text":"","code":"# 1D functional data t <- seq(0, 1, length.out = 50) X <- matrix(0, 20, 50) for (i in 1:20) X[i, ] <- sin(2*pi*t) + rnorm(50, sd = 0.2) fd <- fdata(X, argvals = t) cov_result <- cov(fd) image(cov_result$cov, main = \"Covariance Surface\")"},{"path":"https://sipemu.github.io/fdars/reference/depth.BD.html","id":null,"dir":"Reference","previous_headings":"","what":"Band Depth ‚Äî depth.BD","title":"Band Depth ‚Äî depth.BD","text":"Wrapper depth(method = \"BD\"). Useful function argument.","code":""},{"path":"https://sipemu.github.io/fdars/reference/depth.BD.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Band Depth ‚Äî depth.BD","text":"","code":"depth.BD(fdataobj, fdataori = NULL, ...)"},{"path":"https://sipemu.github.io/fdars/reference/depth.BD.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Band Depth ‚Äî depth.BD","text":"fdataobj object class 'fdata'. fdataori Reference sample (default: fdataobj ). ... Additional arguments.","code":""},{"path":"https://sipemu.github.io/fdars/reference/depth.BD.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Band Depth ‚Äî depth.BD","text":"Numeric vector depth values.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/reference/depth.FM.html","id":null,"dir":"Reference","previous_headings":"","what":"Fraiman-Muniz Depth ‚Äî depth.FM","title":"Fraiman-Muniz Depth ‚Äî depth.FM","text":"Wrapper depth(method = \"FM\"). Useful function argument.","code":""},{"path":"https://sipemu.github.io/fdars/reference/depth.FM.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fraiman-Muniz Depth ‚Äî depth.FM","text":"","code":"depth.FM(fdataobj, fdataori = NULL, ...)"},{"path":"https://sipemu.github.io/fdars/reference/depth.FM.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fraiman-Muniz Depth ‚Äî depth.FM","text":"fdataobj object class 'fdata'. fdataori Reference sample (default: fdataobj ). ... Additional arguments.","code":""},{"path":"https://sipemu.github.io/fdars/reference/depth.FM.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fraiman-Muniz Depth ‚Äî depth.FM","text":"Numeric vector depth values.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/reference/depth.FSD.html","id":null,"dir":"Reference","previous_headings":"","what":"Functional Spatial Depth ‚Äî depth.FSD","title":"Functional Spatial Depth ‚Äî depth.FSD","text":"Wrapper depth(method = \"FSD\"). Useful function argument.","code":""},{"path":"https://sipemu.github.io/fdars/reference/depth.FSD.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functional Spatial Depth ‚Äî depth.FSD","text":"","code":"depth.FSD(fdataobj, fdataori = NULL, ...)"},{"path":"https://sipemu.github.io/fdars/reference/depth.FSD.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functional Spatial Depth ‚Äî depth.FSD","text":"fdataobj object class 'fdata'. fdataori Reference sample (default: fdataobj ). ... Additional arguments.","code":""},{"path":"https://sipemu.github.io/fdars/reference/depth.FSD.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functional Spatial Depth ‚Äî depth.FSD","text":"Numeric vector depth values.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/reference/depth.KFSD.html","id":null,"dir":"Reference","previous_headings":"","what":"Kernel Functional Spatial Depth ‚Äî depth.KFSD","title":"Kernel Functional Spatial Depth ‚Äî depth.KFSD","text":"Wrapper depth(method = \"KFSD\"). Useful function argument.","code":""},{"path":"https://sipemu.github.io/fdars/reference/depth.KFSD.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Kernel Functional Spatial Depth ‚Äî depth.KFSD","text":"","code":"depth.KFSD(fdataobj, fdataori = NULL, ...)"},{"path":"https://sipemu.github.io/fdars/reference/depth.KFSD.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Kernel Functional Spatial Depth ‚Äî depth.KFSD","text":"fdataobj object class 'fdata'. fdataori Reference sample (default: fdataobj ). ... Additional arguments.","code":""},{"path":"https://sipemu.github.io/fdars/reference/depth.KFSD.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Kernel Functional Spatial Depth ‚Äî depth.KFSD","text":"Numeric vector depth values.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/reference/depth.MBD.html","id":null,"dir":"Reference","previous_headings":"","what":"Modified Band Depth ‚Äî depth.MBD","title":"Modified Band Depth ‚Äî depth.MBD","text":"Wrapper depth(method = \"MBD\"). Useful function argument.","code":""},{"path":"https://sipemu.github.io/fdars/reference/depth.MBD.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Modified Band Depth ‚Äî depth.MBD","text":"","code":"depth.MBD(fdataobj, fdataori = NULL, ...)"},{"path":"https://sipemu.github.io/fdars/reference/depth.MBD.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Modified Band Depth ‚Äî depth.MBD","text":"fdataobj object class 'fdata'. fdataori Reference sample (default: fdataobj ). ... Additional arguments.","code":""},{"path":"https://sipemu.github.io/fdars/reference/depth.MBD.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Modified Band Depth ‚Äî depth.MBD","text":"Numeric vector depth values.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/reference/depth.MEI.html","id":null,"dir":"Reference","previous_headings":"","what":"Modified Epigraph Index ‚Äî depth.MEI","title":"Modified Epigraph Index ‚Äî depth.MEI","text":"Wrapper depth(method = \"MEI\"). Useful function argument.","code":""},{"path":"https://sipemu.github.io/fdars/reference/depth.MEI.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Modified Epigraph Index ‚Äî depth.MEI","text":"","code":"depth.MEI(fdataobj, fdataori = NULL, ...)"},{"path":"https://sipemu.github.io/fdars/reference/depth.MEI.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Modified Epigraph Index ‚Äî depth.MEI","text":"fdataobj object class 'fdata'. fdataori Reference sample (default: fdataobj ). ... Additional arguments.","code":""},{"path":"https://sipemu.github.io/fdars/reference/depth.MEI.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Modified Epigraph Index ‚Äî depth.MEI","text":"Numeric vector depth values.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/reference/depth.RP.html","id":null,"dir":"Reference","previous_headings":"","what":"Random Projection Depth ‚Äî depth.RP","title":"Random Projection Depth ‚Äî depth.RP","text":"Wrapper depth(method = \"RP\"). Useful function argument.","code":""},{"path":"https://sipemu.github.io/fdars/reference/depth.RP.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random Projection Depth ‚Äî depth.RP","text":"","code":"depth.RP(fdataobj, fdataori = NULL, ...)"},{"path":"https://sipemu.github.io/fdars/reference/depth.RP.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random Projection Depth ‚Äî depth.RP","text":"fdataobj object class 'fdata'. fdataori Reference sample (default: fdataobj ). ... Additional arguments.","code":""},{"path":"https://sipemu.github.io/fdars/reference/depth.RP.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random Projection Depth ‚Äî depth.RP","text":"Numeric vector depth values.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/reference/depth.RPD.html","id":null,"dir":"Reference","previous_headings":"","what":"Random Projection Depth with Derivatives ‚Äî depth.RPD","title":"Random Projection Depth with Derivatives ‚Äî depth.RPD","text":"Wrapper depth(method = \"RPD\"). Useful function argument.","code":""},{"path":"https://sipemu.github.io/fdars/reference/depth.RPD.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random Projection Depth with Derivatives ‚Äî depth.RPD","text":"","code":"depth.RPD(fdataobj, fdataori = NULL, ...)"},{"path":"https://sipemu.github.io/fdars/reference/depth.RPD.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random Projection Depth with Derivatives ‚Äî depth.RPD","text":"fdataobj object class 'fdata'. fdataori Reference sample (default: fdataobj ). ... Additional arguments.","code":""},{"path":"https://sipemu.github.io/fdars/reference/depth.RPD.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random Projection Depth with Derivatives ‚Äî depth.RPD","text":"Numeric vector depth values.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/reference/depth.RT.html","id":null,"dir":"Reference","previous_headings":"","what":"Random Tukey Depth ‚Äî depth.RT","title":"Random Tukey Depth ‚Äî depth.RT","text":"Wrapper depth(method = \"RT\"). Useful function argument.","code":""},{"path":"https://sipemu.github.io/fdars/reference/depth.RT.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Random Tukey Depth ‚Äî depth.RT","text":"","code":"depth.RT(fdataobj, fdataori = NULL, ...)"},{"path":"https://sipemu.github.io/fdars/reference/depth.RT.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Random Tukey Depth ‚Äî depth.RT","text":"fdataobj object class 'fdata'. fdataori Reference sample (default: fdataobj ). ... Additional arguments.","code":""},{"path":"https://sipemu.github.io/fdars/reference/depth.RT.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Random Tukey Depth ‚Äî depth.RT","text":"Numeric vector depth values.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/reference/depth.html","id":null,"dir":"Reference","previous_headings":"","what":"Depth Functions for Functional Data ‚Äî depth","title":"Depth Functions for Functional Data ‚Äî depth","text":"Functions computing various depth measures functional data. Compute Functional Data Depth","code":""},{"path":"https://sipemu.github.io/fdars/reference/depth.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Depth Functions for Functional Data ‚Äî depth","text":"","code":"depth(   fdataobj,   fdataori = NULL,   method = c(\"FM\", \"mode\", \"RP\", \"RT\", \"BD\", \"MBD\", \"MEI\", \"FSD\", \"KFSD\", \"RPD\"),   ... )"},{"path":"https://sipemu.github.io/fdars/reference/depth.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Depth Functions for Functional Data ‚Äî depth","text":"fdataobj object class 'fdata' compute depth . fdataori object class 'fdata' reference sample. NULL, uses fdataobj reference. method Depth method use. One \"FM\" (Fraiman-Muniz), \"mode\" (modal), \"RP\" (random projection), \"RT\" (random Tukey), \"BD\" (band depth), \"MBD\" (modified band depth), \"MEI\" (modified epigraph index), \"FSD\" (functional spatial depth), \"KFSD\" (kernel functional spatial depth), \"RPD\" (random projection derivatives). Default \"FM\". ... Additional arguments passed specific depth function.","code":""},{"path":"https://sipemu.github.io/fdars/reference/depth.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Depth Functions for Functional Data ‚Äî depth","text":"numeric vector depth values, one per curve fdataobj.","code":""},{"path":"https://sipemu.github.io/fdars/reference/depth.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Depth Functions for Functional Data ‚Äî depth","text":"Unified interface computing various depth measures functional data. Available methods: FM Fraiman-Muniz depth - integrates univariate depths domain mode Modal depth - based kernel density estimation RP Random projection depth - projects random directions RT Random Tukey depth - halfspace depth via random projections BD Band depth - proportion bands containing curve (1D ) MBD Modified band depth - allows partial containment (1D ) MEI Modified epigraph index - proportion time curves (1D ) FSD Functional spatial depth - based spatial signs KFSD Kernel functional spatial depth - smoothed FSD RPD Random projection derivatives - includes curve derivatives","code":""},{"path":"https://sipemu.github.io/fdars/reference/depth.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Depth Functions for Functional Data ‚Äî depth","text":"","code":"fd <- fdata(matrix(rnorm(100), 10, 10))  # Different depth methods depth(fd, method = \"FM\") #>  [1] 0.42 0.54 0.46 0.40 0.62 0.48 0.40 0.52 0.64 0.52 depth(fd, method = \"mode\") #>  [1] 0.1647374 0.2644773 0.1686973 0.2073929 0.2763939 0.2009045 0.2027225 #>  [8] 0.2292383 0.2803400 0.2268949 depth(fd, method = \"RP\") #>  [1] 0.2436364 0.2927273 0.2818182 0.2527273 0.3036364 0.2436364 0.2527273 #>  [8] 0.2909091 0.3236364 0.2418182"},{"path":"https://sipemu.github.io/fdars/reference/depth.mode.html","id":null,"dir":"Reference","previous_headings":"","what":"Modal Depth ‚Äî depth.mode","title":"Modal Depth ‚Äî depth.mode","text":"Wrapper depth(method = \"mode\"). Useful function argument.","code":""},{"path":"https://sipemu.github.io/fdars/reference/depth.mode.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Modal Depth ‚Äî depth.mode","text":"","code":"depth.mode(fdataobj, fdataori = NULL, ...)"},{"path":"https://sipemu.github.io/fdars/reference/depth.mode.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Modal Depth ‚Äî depth.mode","text":"fdataobj object class 'fdata'. fdataori Reference sample (default: fdataobj ). ... Additional arguments.","code":""},{"path":"https://sipemu.github.io/fdars/reference/depth.mode.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Modal Depth ‚Äî depth.mode","text":"Numeric vector depth values.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/reference/deriv.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute functional derivative ‚Äî deriv","title":"Compute functional derivative ‚Äî deriv","text":"Compute numerical derivative functional data. Uses finite differences fast computation via Rust.","code":""},{"path":"https://sipemu.github.io/fdars/reference/deriv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute functional derivative ‚Äî deriv","text":"","code":"deriv(   fdataobj,   nderiv = 1,   method = \"diff\",   class.out = \"fdata\",   nbasis = NULL,   ... )"},{"path":"https://sipemu.github.io/fdars/reference/deriv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute functional derivative ‚Äî deriv","text":"fdataobj object class 'fdata'. nderiv Derivative order (1, 2, ...). Default 1. 2D data, first-order derivatives currently supported. method Method computing derivatives. Currently \"diff\" (finite differences) supported. class.Output class, either \"fdata\" \"fd\". Default \"fdata\". nbasis used (compatibility fda.usc). ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/deriv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute functional derivative ‚Äî deriv","text":"1D data: 'fdata' object containing derivative values. 2D data: list components ds, dt, dsdt, 'fdata' object containing respective partial derivative.","code":""},{"path":"https://sipemu.github.io/fdars/reference/deriv.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute functional derivative ‚Äî deriv","text":"1D functional data (curves), computes nth derivative. 2D functional data (surfaces), computes partial derivatives: ds: partial derivative respect s (first argument) dt: partial derivative respect t (second argument) dsdt: mixed partial derivative","code":""},{"path":"https://sipemu.github.io/fdars/reference/deriv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute functional derivative ‚Äî deriv","text":"","code":"# Create smooth curves t <- seq(0, 2*pi, length.out = 100) X <- matrix(0, 10, 100) for (i in 1:10) X[i, ] <- sin(t + i/5) fd <- fdata(X, argvals = t)  # First derivative (should be approximately cos) fd_deriv <- deriv(fd, nderiv = 1)"},{"path":"https://sipemu.github.io/fdars/reference/detect_peaks.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect Peaks in Functional Data ‚Äî detect_peaks","title":"Detect Peaks in Functional Data ‚Äî detect_peaks","text":"Detects local maxima (peaks) functional data using derivative zero-crossings. Returns peak times, values, prominence measures.","code":""},{"path":"https://sipemu.github.io/fdars/reference/detect_peaks.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect Peaks in Functional Data ‚Äî detect_peaks","text":"","code":"detect_peaks(   fdataobj,   min_distance = NULL,   min_prominence = NULL,   smooth_first = FALSE,   smooth_lambda = NULL )"},{"path":"https://sipemu.github.io/fdars/reference/detect_peaks.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detect Peaks in Functional Data ‚Äî detect_peaks","text":"fdataobj fdata object. min_distance Minimum time peaks. Default: NULL (constraint). min_prominence Minimum prominence peak (0-1 scale). Peaks lower prominence filtered . Default: NULL (filter). smooth_first Logical. TRUE, apply P-spline smoothing peak detection. Default: FALSE. smooth_lambda Smoothing parameter P-splines. Default: 10.","code":""},{"path":"https://sipemu.github.io/fdars/reference/detect_peaks.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detect Peaks in Functional Data ‚Äî detect_peaks","text":"list components: peaks List data frames, one per curve, columns: time, value, prominence inter_peak_distances List numeric vectors distances consecutive peaks mean_period Mean inter-peak distance across curves (estimates period)","code":""},{"path":"https://sipemu.github.io/fdars/reference/detect_peaks.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Detect Peaks in Functional Data ‚Äî detect_peaks","text":"Peak prominence measures much peak stands surroundings. computed height difference peak highest two minimum values either side, normalized data range.","code":""},{"path":"https://sipemu.github.io/fdars/reference/detect_peaks.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Detect Peaks in Functional Data ‚Äî detect_peaks","text":"","code":"# Generate data with clear peaks t <- seq(0, 10, length.out = 200) X <- matrix(sin(2 * pi * t / 2), nrow = 1) fd <- fdata(X, argvals = t)  # Detect peaks peaks <- detect_peaks(fd, min_distance = 1.5) print(peaks$mean_period)  # Should be close to 2 #> [1] 2.01005  # With automatic GCV smoothing peaks_smooth <- detect_peaks(fd, min_distance = 1.5, smooth_first = TRUE)"},{"path":"https://sipemu.github.io/fdars/reference/detect_seasonality_changes.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect Changes in Seasonality ‚Äî detect_seasonality_changes","title":"Detect Changes in Seasonality ‚Äî detect_seasonality_changes","text":"Detects points time seasonality starts (onset) stops (cessation) monitoring time-varying seasonal strength.","code":""},{"path":"https://sipemu.github.io/fdars/reference/detect_seasonality_changes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect Changes in Seasonality ‚Äî detect_seasonality_changes","text":"","code":"detect_seasonality_changes(   fdataobj,   period,   threshold = 0.3,   window_size = NULL,   min_duration = NULL )"},{"path":"https://sipemu.github.io/fdars/reference/detect_seasonality_changes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detect Changes in Seasonality ‚Äî detect_seasonality_changes","text":"fdataobj fdata object. period Known estimated period. threshold Seasonal strength threshold classification (0-1). threshold = seasonal, = non-seasonal. Default: 0.3. window_size Width sliding window strength estimation. Default: 2 * period. min_duration Minimum duration confirm change. Prevents detection spurious short-term fluctuations. Default: period.","code":""},{"path":"https://sipemu.github.io/fdars/reference/detect_seasonality_changes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detect Changes in Seasonality ‚Äî detect_seasonality_changes","text":"list components: change_points Data frame columns: time, type (\"onset\" \"cessation\"), strength_before, strength_after strength_curve Time-varying seasonal strength used detection","code":""},{"path":"https://sipemu.github.io/fdars/reference/detect_seasonality_changes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Detect Changes in Seasonality ‚Äî detect_seasonality_changes","text":"","code":"# Signal that starts non-seasonal, becomes seasonal, then stops t <- seq(0, 30, length.out = 600) X <- ifelse(t < 10, rnorm(sum(t < 10), sd = 0.3),             ifelse(t < 20, sin(2 * pi * t[t >= 10 & t < 20] / 2),                    rnorm(sum(t >= 20), sd = 0.3))) X <- matrix(X, nrow = 1) fd <- fdata(X, argvals = t)  # Detect changes changes <- detect_seasonality_changes(fd, period = 2) print(changes$change_points)  # Should show onset ~10, cessation ~20 #>        time      type strength_before strength_after #> 1  9.315526     onset       0.2806238      0.3018192 #> 2 21.736227 cessation       0.3945666      0.2947470"},{"path":"https://sipemu.github.io/fdars/reference/detect_seasonality_changes_auto.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect Seasonality Changes with Automatic Threshold ‚Äî detect_seasonality_changes_auto","title":"Detect Seasonality Changes with Automatic Threshold ‚Äî detect_seasonality_changes_auto","text":"Detects points seasonality starts stops, using automatic threshold selection instead fixed value.","code":""},{"path":"https://sipemu.github.io/fdars/reference/detect_seasonality_changes_auto.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect Seasonality Changes with Automatic Threshold ‚Äî detect_seasonality_changes_auto","text":"","code":"detect_seasonality_changes_auto(   fdataobj,   period,   threshold_method = \"otsu\",   threshold_value = NULL,   window_size = NULL,   min_duration = NULL )"},{"path":"https://sipemu.github.io/fdars/reference/detect_seasonality_changes_auto.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Detect Seasonality Changes with Automatic Threshold ‚Äî detect_seasonality_changes_auto","text":"fdataobj fdata object. period Known seasonal period. threshold_method Method threshold selection: \"fixed\" Use threshold_value fixed threshold \"percentile\" Use threshold_value percentile strength distribution \"otsu\" Use Otsu's method bimodal separation (default) threshold_value Value \"fixed\" \"percentile\" methods. window_size Width sliding window strength estimation. Default: 2 * period. min_duration Minimum duration confirm change. Default: period.","code":""},{"path":"https://sipemu.github.io/fdars/reference/detect_seasonality_changes_auto.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detect Seasonality Changes with Automatic Threshold ‚Äî detect_seasonality_changes_auto","text":"list components: change_points Data frame time, type, strength_before, strength_after strength_curve Time-varying seasonal strength used detection computed_threshold threshold computed/used","code":""},{"path":"https://sipemu.github.io/fdars/reference/detect_seasonality_changes_auto.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Detect Seasonality Changes with Automatic Threshold ‚Äî detect_seasonality_changes_auto","text":"Otsu's method automatically finds optimal threshold separating seasonal non-seasonal regions based strength distribution. particularly useful know appropriate threshold data.","code":""},{"path":"https://sipemu.github.io/fdars/reference/detect_seasonality_changes_auto.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Detect Seasonality Changes with Automatic Threshold ‚Äî detect_seasonality_changes_auto","text":"","code":"# Signal that transitions from seasonal to non-seasonal t <- seq(0, 20, length.out = 400) X <- ifelse(t < 10, sin(2 * pi * t / 2), rnorm(sum(t >= 10), sd = 0.3)) X <- matrix(X, nrow = 1) fd <- fdata(X, argvals = t)  # Detect changes with Otsu threshold changes <- detect_seasonality_changes_auto(fd, period = 2) print(changes$computed_threshold) #> [1] 0.5475812"},{"path":"https://sipemu.github.io/fdars/reference/df_to_fdata2d.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert DataFrame to 2D functional data ‚Äî df_to_fdata2d","title":"Convert DataFrame to 2D functional data ‚Äî df_to_fdata2d","text":"Converts data frame long format 2D fdata object (surfaces). expected format : one identifier column, one column s-dimension index, multiple columns t-dimension values.","code":""},{"path":"https://sipemu.github.io/fdars/reference/df_to_fdata2d.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert DataFrame to 2D functional data ‚Äî df_to_fdata2d","text":"","code":"df_to_fdata2d(   df,   id_col = 1,   s_col = 2,   t_cols = NULL,   names = NULL,   metadata = NULL )"},{"path":"https://sipemu.github.io/fdars/reference/df_to_fdata2d.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert DataFrame to 2D functional data ‚Äî df_to_fdata2d","text":"df data frame structure described . id_col Name index identifier column (default: 1). s_col Name index s-dimension column (default: 2). t_cols Names indices t-dimension value columns. NULL (default), uses columns s_col. names Optional list 'main', 'xlab', 'ylab', 'zlab' labels. metadata Optional data.frame additional covariates (one row per surface). metadata \"id\" column non-default row names, must match surface identifiers id_col.","code":""},{"path":"https://sipemu.github.io/fdars/reference/df_to_fdata2d.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert DataFrame to 2D functional data ‚Äî df_to_fdata2d","text":"object class 'fdata' 2D functional data.","code":""},{"path":"https://sipemu.github.io/fdars/reference/df_to_fdata2d.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert DataFrame to 2D functional data ‚Äî df_to_fdata2d","text":"expected data frame structure : Column 1 (id_col): Surface identifier (e.g., \"surface_1\", \"surface_2\") Column 2 (s_col): Index s-dimension (row index surface) Columns 3+ (t_cols): Values t-dimension point (columns surface) unique identifier represents one surface. surface, m1 rows (one per s-value), m2 t-columns, resulting m1 x m2 surface.","code":""},{"path":"https://sipemu.github.io/fdars/reference/df_to_fdata2d.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert DataFrame to 2D functional data ‚Äî df_to_fdata2d","text":"","code":"# Create example data frame df <- data.frame(   id = rep(c(\"surf1\", \"surf2\"), each = 5),   s = rep(1:5, 2),   t1 = rnorm(10),   t2 = rnorm(10),   t3 = rnorm(10) ) fd <- df_to_fdata2d(df) print(fd) #> Functional data object #>   Type: 2D (surface)  #>   Number of observations: 2  #>   Grid dimensions: 5 x 3  #>   Range s: 1 - 5  #>   Range t: 1 - 3   # With metadata meta <- data.frame(group = c(\"A\", \"B\"), value = c(1.5, 2.3)) fd <- df_to_fdata2d(df, metadata = meta)"},{"path":"https://sipemu.github.io/fdars/reference/dot-onLoad.html","id":null,"dir":"Reference","previous_headings":"","what":"Package initialization ‚Äî .onLoad","title":"Package initialization ‚Äî .onLoad","text":"Package initialization","code":""},{"path":"https://sipemu.github.io/fdars/reference/dot-onLoad.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Package initialization ‚Äî .onLoad","text":"","code":".onLoad(libname, pkgname)"},{"path":"https://sipemu.github.io/fdars/reference/estimate_period.html","id":null,"dir":"Reference","previous_headings":"","what":"Seasonal Analysis Functions for Functional Data ‚Äî estimate_period","title":"Seasonal Analysis Functions for Functional Data ‚Äî estimate_period","text":"Functions analyzing seasonal patterns functional data including period estimation, peak detection, seasonal strength measurement, detection seasonality changes. Estimate Seasonal Period using FFT","code":""},{"path":"https://sipemu.github.io/fdars/reference/estimate_period.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Seasonal Analysis Functions for Functional Data ‚Äî estimate_period","text":"","code":"estimate_period(fdataobj, method = c(\"fft\", \"acf\"), max_lag = NULL)"},{"path":"https://sipemu.github.io/fdars/reference/estimate_period.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Seasonal Analysis Functions for Functional Data ‚Äî estimate_period","text":"fdataobj fdata object.","code":""},{"path":"https://sipemu.github.io/fdars/reference/estimate_period.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Seasonal Analysis Functions for Functional Data ‚Äî estimate_period","text":"list components: period Estimated period frequency Dominant frequency (1/period) power Power dominant frequency confidence Confidence measure (ratio peak power mean power)","code":""},{"path":"https://sipemu.github.io/fdars/reference/estimate_period.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Seasonal Analysis Functions for Functional Data ‚Äî estimate_period","text":"Estimates dominant period functional data using Fast Fourier Transform periodogram analysis. function computes periodogram mean curve finds frequency maximum power. confidence measure indicates pronounced dominant frequency relative background.","code":""},{"path":"https://sipemu.github.io/fdars/reference/estimate_period.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Seasonal Analysis Functions for Functional Data ‚Äî estimate_period","text":"","code":"# Generate seasonal data with period = 2 t <- seq(0, 10, length.out = 200) X <- matrix(sin(2 * pi * t / 2) + rnorm(200, sd = 0.1), nrow = 1) fd <- fdata(X, argvals = t)  # Estimate period result <- estimate_period(fd, method = \"fft\") print(result$period)  # Should be close to 2 #> [1] 2.01005"},{"path":"https://sipemu.github.io/fdars/reference/fdars-package.html","id":null,"dir":"Reference","previous_headings":"","what":"fdars: Functional Data Analysis in Rust ‚Äî fdars-package","title":"fdars: Functional Data Analysis in Rust ‚Äî fdars-package","text":"Functional data analysis tools high-performance Rust backend. Provides methods functional data manipulation, depth computation, distance metrics, regression, statistical testing. Supports 1D functional data (curves) 2D functional data (surfaces).","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/reference/fdars-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"fdars: Functional Data Analysis in Rust ‚Äî fdars-package","text":"Maintainer: Simon M√ºller sm@data-zoo.de","code":""},{"path":"https://sipemu.github.io/fdars/reference/fdata.bootstrap.ci.html","id":null,"dir":"Reference","previous_headings":"","what":"Bootstrap Confidence Intervals for Functional Statistics ‚Äî fdata.bootstrap.ci","title":"Bootstrap Confidence Intervals for Functional Statistics ‚Äî fdata.bootstrap.ci","text":"Compute bootstrap confidence intervals functional statistics mean function, depth values, regression coefficients.","code":""},{"path":"https://sipemu.github.io/fdars/reference/fdata.bootstrap.ci.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bootstrap Confidence Intervals for Functional Statistics ‚Äî fdata.bootstrap.ci","text":"","code":"fdata.bootstrap.ci(   fdataobj,   statistic,   n.boot = 200,   alpha = 0.05,   method = c(\"percentile\", \"basic\", \"normal\"),   seed = NULL )"},{"path":"https://sipemu.github.io/fdars/reference/fdata.bootstrap.ci.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bootstrap Confidence Intervals for Functional Statistics ‚Äî fdata.bootstrap.ci","text":"fdataobj object class 'fdata'. statistic function computes statistic interest. Must take fdata object return numeric vector. n.boot Number bootstrap replications (default 200). alpha Significance level confidence intervals (default 0.05 95 percent CI). method CI method: \"percentile\" simple percentile method, \"basic\" basic bootstrap, \"normal\" normal approximation (default \"percentile\"). seed Optional seed reproducibility.","code":""},{"path":"https://sipemu.github.io/fdars/reference/fdata.bootstrap.ci.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bootstrap Confidence Intervals for Functional Statistics ‚Äî fdata.bootstrap.ci","text":"list class 'fdata.bootstrap.ci' components: estimate statistic computed original data ci.lower Lower confidence bound ci.upper Upper confidence bound boot.stats Matrix bootstrap statistics (n.boot x length(statistic)) alpha significance level used method CI method used","code":""},{"path":"https://sipemu.github.io/fdars/reference/fdata.bootstrap.ci.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bootstrap Confidence Intervals for Functional Statistics ‚Äî fdata.bootstrap.ci","text":"","code":"# Create functional data t <- seq(0, 1, length.out = 50) X <- matrix(0, 20, 50) for (i in 1:20) X[i, ] <- sin(2*pi*t) + rnorm(50, sd = 0.1) fd <- fdata(X, argvals = t)  # Bootstrap CI for the mean function (returns numeric vector) ci_mean <- fdata.bootstrap.ci(fd,   statistic = function(x) as.numeric(mean(x)$data),   n.boot = 100)  # Bootstrap CI for depth values ci_depth <- fdata.bootstrap.ci(fd,   statistic = function(x) depth.FM(x),   n.boot = 100)"},{"path":"https://sipemu.github.io/fdars/reference/fdata.bootstrap.html","id":null,"dir":"Reference","previous_headings":"","what":"Bootstrap Functional Data ‚Äî fdata.bootstrap","title":"Bootstrap Functional Data ‚Äî fdata.bootstrap","text":"Generate bootstrap samples functional data. Supports naive bootstrap (resampling curves replacement) smooth bootstrap (adding noise based estimated covariance structure).","code":""},{"path":"https://sipemu.github.io/fdars/reference/fdata.bootstrap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bootstrap Functional Data ‚Äî fdata.bootstrap","text":"","code":"fdata.bootstrap(   fdataobj,   n.boot = 200,   method = c(\"naive\", \"smooth\"),   variance = NULL,   seed = NULL )"},{"path":"https://sipemu.github.io/fdars/reference/fdata.bootstrap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bootstrap Functional Data ‚Äî fdata.bootstrap","text":"fdataobj object class 'fdata'. n.boot Number bootstrap replications (default 200). method Bootstrap method: \"naive\" resampling replacement, \"smooth\" adding Gaussian noise (default \"naive\"). variance method=\"smooth\", variance added noise. NULL, estimated data. seed Optional seed reproducibility.","code":""},{"path":"https://sipemu.github.io/fdars/reference/fdata.bootstrap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bootstrap Functional Data ‚Äî fdata.bootstrap","text":"list class 'fdata.bootstrap' components: boot.samples List n.boot fdata objects, bootstrap sample original original fdata object method bootstrap method used n.boot Number bootstrap replications","code":""},{"path":"https://sipemu.github.io/fdars/reference/fdata.bootstrap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bootstrap Functional Data ‚Äî fdata.bootstrap","text":"","code":"# Create functional data t <- seq(0, 1, length.out = 50) X <- matrix(0, 20, 50) for (i in 1:20) X[i, ] <- sin(2*pi*t) + rnorm(50, sd = 0.1) fd <- fdata(X, argvals = t)  # Naive bootstrap boot_naive <- fdata.bootstrap(fd, n.boot = 100, method = \"naive\")  # Smooth bootstrap boot_smooth <- fdata.bootstrap(fd, n.boot = 100, method = \"smooth\")"},{"path":"https://sipemu.github.io/fdars/reference/fdata.cen.html","id":null,"dir":"Reference","previous_headings":"","what":"Center functional data ‚Äî fdata.cen","title":"Center functional data ‚Äî fdata.cen","text":"Subtract mean function curve.","code":""},{"path":"https://sipemu.github.io/fdars/reference/fdata.cen.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Center functional data ‚Äî fdata.cen","text":"","code":"fdata.cen(fdataobj)"},{"path":"https://sipemu.github.io/fdars/reference/fdata.cen.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Center functional data ‚Äî fdata.cen","text":"fdataobj object class 'fdata'.","code":""},{"path":"https://sipemu.github.io/fdars/reference/fdata.cen.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Center functional data ‚Äî fdata.cen","text":"centered 'fdata' object.","code":""},{"path":"https://sipemu.github.io/fdars/reference/fdata.cen.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Center functional data ‚Äî fdata.cen","text":"","code":"fd <- fdata(matrix(rnorm(100), 10, 10)) fd_centered <- fdata.cen(fd)"},{"path":"https://sipemu.github.io/fdars/reference/fdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a functional data object ‚Äî fdata","title":"Create a functional data object ‚Äî fdata","text":"Creates fdata object 1D functional data (curves) 2D functional data (surfaces). 2D data, internal storage uses flattened matrix format [n, m1*m2] row represents surface stored row-major order.","code":""},{"path":"https://sipemu.github.io/fdars/reference/fdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a functional data object ‚Äî fdata","text":"","code":"fdata(   mdata,   argvals = NULL,   rangeval = NULL,   names = NULL,   fdata2d = FALSE,   id = NULL,   metadata = NULL )"},{"path":"https://sipemu.github.io/fdars/reference/fdata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a functional data object ‚Äî fdata","text":"mdata Input data. Can : 1D: matrix [n, m] n number curves, m number evaluation points 2D: 3D array [n, m1, m2] n number surfaces, m1 x m2 grid size. Automatically detected converted flattened storage. 2D: matrix [n, m1*m2] (already flattened) argvals specifying grid dimensions 2D: single surface matrix [m1, m2] argvals specifying grid dimensions argvals Evaluation points. 1D: numeric vector. 2D: list two numeric vectors specifying s t coordinates. rangeval Range argument values. 1D: numeric vector length 2. 2D: list two numeric vectors length 2. names List components 'main', 'xlab', 'ylab' plot titles. 2D, also 'zlab' surface value label. fdata2d Logical. TRUE, create 2D functional data (surface). Automatically set TRUE mdata 3D array. id Optional character vector identifiers observation. NULL, uses row names mdata generates \"obs_1\", \"obs_2\", etc. metadata Optional data.frame additional covariates (one row per observation). metadata \"id\" column non-default row names, must match id parameter.","code":""},{"path":"https://sipemu.github.io/fdars/reference/fdata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a functional data object ‚Äî fdata","text":"object class 'fdata' containing: data data matrix. 2D: flattened [n, m1*m2] format argvals Evaluation points rangeval Range arguments names Plot labels fdata2d Logical indicating 2D dims 2D : c(m1, m2) grid dimensions id Character vector observation identifiers metadata Data frame additional covariates (NULL)","code":""},{"path":"https://sipemu.github.io/fdars/reference/fdata.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a functional data object ‚Äî fdata","text":"2D functional data, surfaces stored internally flattened matrix row surface row-major order. extract single surface matrix, use subsetting drop = TRUE reshape manually:","code":"# Extract surface i as matrix surface_i <- fd[i, drop = TRUE] # Or manually: surface_i <- matrix(fd$data[i, ], nrow = fd$dims[1], ncol = fd$dims[2])"},{"path":"https://sipemu.github.io/fdars/reference/fdata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a functional data object ‚Äî fdata","text":"","code":"# Create 1D functional data (curves) x <- matrix(rnorm(100), nrow = 10, ncol = 10) fd <- fdata(x, argvals = seq(0, 1, length.out = 10))  # Create with identifiers and metadata meta <- data.frame(group = rep(c(\"A\", \"B\"), 5), endpoint = rnorm(10)) fd <- fdata(x, id = paste0(\"patient_\", 1:10), metadata = meta)  # Access metadata fd$id #>  [1] \"patient_1\"  \"patient_2\"  \"patient_3\"  \"patient_4\"  \"patient_5\"  #>  [6] \"patient_6\"  \"patient_7\"  \"patient_8\"  \"patient_9\"  \"patient_10\" fd$metadata$group #>  [1] \"A\" \"B\" \"A\" \"B\" \"A\" \"B\" \"A\" \"B\" \"A\" \"B\"  # Create 2D functional data from 3D array [n, m1, m2] surfaces <- array(rnorm(500), dim = c(5, 10, 10)) fd2d <- fdata(surfaces)  # Access individual surface as matrix surface_1 <- fd2d[1, drop = TRUE]"},{"path":"https://sipemu.github.io/fdars/reference/fdata2basis.2d.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert 2D Functional Data to Tensor Product Basis Coefficients ‚Äî fdata2basis.2d","title":"Convert 2D Functional Data to Tensor Product Basis Coefficients ‚Äî fdata2basis.2d","text":"Projects 2D functional data (surfaces) onto tensor product basis, Kronecker product two 1D bases.","code":""},{"path":"https://sipemu.github.io/fdars/reference/fdata2basis.2d.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert 2D Functional Data to Tensor Product Basis Coefficients ‚Äî fdata2basis.2d","text":"","code":"fdata2basis.2d(   fdataobj,   nbasis.s = 10,   nbasis.t = 10,   type = c(\"bspline\", \"fourier\") )"},{"path":"https://sipemu.github.io/fdars/reference/fdata2basis.2d.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert 2D Functional Data to Tensor Product Basis Coefficients ‚Äî fdata2basis.2d","text":"fdataobj 2D fdata object (surfaces). nbasis.s Number basis functions s (first) direction. nbasis.t Number basis functions t (second) direction. type Basis type: \"bspline\" (default) \"fourier\".","code":""},{"path":"https://sipemu.github.io/fdars/reference/fdata2basis.2d.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert 2D Functional Data to Tensor Product Basis Coefficients ‚Äî fdata2basis.2d","text":"matrix coefficients [n x (nbasis.s * nbasis.t)].","code":""},{"path":"https://sipemu.github.io/fdars/reference/fdata2basis.2d.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert 2D Functional Data to Tensor Product Basis Coefficients ‚Äî fdata2basis.2d","text":"tensor product basis defined : $$B_{2d}(s, t) = B_s(s) \\otimes B_t(t)$$","code":""},{"path":"https://sipemu.github.io/fdars/reference/fdata2basis.2d.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert 2D Functional Data to Tensor Product Basis Coefficients ‚Äî fdata2basis.2d","text":"","code":"# Create 2D surface data s <- seq(0, 1, length.out = 20) t <- seq(0, 1, length.out = 20) surface <- outer(sin(2*pi*s), cos(2*pi*t)) fd2d <- fdata(array(surface, dim = c(1, 20, 20)))  # Project to tensor product basis coefs <- fdata2basis.2d(fd2d, nbasis.s = 7, nbasis.t = 7, type = \"fourier\")"},{"path":"https://sipemu.github.io/fdars/reference/fdata2basis.cv.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-Validation for Basis Function Number Selection ‚Äî fdata2basis.cv","title":"Cross-Validation for Basis Function Number Selection ‚Äî fdata2basis.cv","text":"Selects optimal number basis functions using k-fold cross-validation generalized cross-validation.","code":""},{"path":"https://sipemu.github.io/fdars/reference/fdata2basis.cv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-Validation for Basis Function Number Selection ‚Äî fdata2basis.cv","text":"","code":"fdata2basis.cv(   fdataobj,   nbasis.range = 4:20,   type = c(\"bspline\", \"fourier\"),   criterion = c(\"GCV\", \"CV\", \"AIC\", \"BIC\"),   kfold = 10,   lambda = 0 )"},{"path":"https://sipemu.github.io/fdars/reference/fdata2basis.cv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-Validation for Basis Function Number Selection ‚Äî fdata2basis.cv","text":"fdataobj fdata object. nbasis.range Vector nbasis values evaluate (default: 4:20). type Basis type: \"bspline\" (default) \"fourier\". criterion Selection criterion: \"GCV\" (default), \"CV\", \"AIC\", \"BIC\". kfold Number folds k-fold CV (default 10). Ignored criterion \"GCV\", \"AIC\", \"BIC\". lambda Smoothing parameter (default 0).","code":""},{"path":"https://sipemu.github.io/fdars/reference/fdata2basis.cv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-Validation for Basis Function Number Selection ‚Äî fdata2basis.cv","text":"list : optimal.nbasis Optimal number basis functions scores Score nbasis value nbasis.range tested nbasis values criterion criterion used fitted fdata object fitted optimal nbasis","code":""},{"path":"https://sipemu.github.io/fdars/reference/fdata2basis.cv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-Validation for Basis Function Number Selection ‚Äî fdata2basis.cv","text":"","code":"set.seed(42) t <- seq(0, 1, length.out = 50) X <- matrix(0, 20, 50) for (i in 1:20) X[i, ] <- sin(4 * pi * t) + rnorm(50, sd = 0.1) fd <- fdata(X, argvals = t)  # Find optimal nbasis cv_result <- fdata2basis.cv(fd, nbasis.range = 5:15, type = \"fourier\") print(cv_result$optimal.nbasis) #> [1] 5"},{"path":"https://sipemu.github.io/fdars/reference/fdata2basis.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Functional Data to Basis Coefficients ‚Äî fdata2basis","title":"Convert Functional Data to Basis Coefficients ‚Äî fdata2basis","text":"Project functional data onto basis system return coefficients. Supports B-spline Fourier basis.","code":""},{"path":"https://sipemu.github.io/fdars/reference/fdata2basis.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Functional Data to Basis Coefficients ‚Äî fdata2basis","text":"","code":"fdata2basis(fdataobj, nbasis = 10, type = c(\"bspline\", \"fourier\"))"},{"path":"https://sipemu.github.io/fdars/reference/fdata2basis.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Functional Data to Basis Coefficients ‚Äî fdata2basis","text":"fdataobj object class 'fdata'. nbasis Number basis functions (default 10). type Type basis: \"bspline\" (default) \"fourier\".","code":""},{"path":"https://sipemu.github.io/fdars/reference/fdata2basis.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Functional Data to Basis Coefficients ‚Äî fdata2basis","text":"matrix coefficients (n x nbasis).","code":""},{"path":"https://sipemu.github.io/fdars/reference/fdata2basis.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert Functional Data to Basis Coefficients ‚Äî fdata2basis","text":"","code":"t <- seq(0, 1, length.out = 50) X <- matrix(0, 20, 50) for (i in 1:20) X[i, ] <- sin(2*pi*t) + rnorm(50, sd = 0.1) fd <- fdata(X, argvals = t) coefs <- fdata2basis(fd, nbasis = 10, type = \"bspline\")"},{"path":"https://sipemu.github.io/fdars/reference/fdata2fd.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Functional Data to fd class ‚Äî fdata2fd","title":"Convert Functional Data to fd class ‚Äî fdata2fd","text":"Converts fdata object fd object fda package. Requires fda package installed.","code":""},{"path":"https://sipemu.github.io/fdars/reference/fdata2fd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Functional Data to fd class ‚Äî fdata2fd","text":"","code":"fdata2fd(fdataobj, nbasis = 10, type = c(\"bspline\", \"fourier\"))"},{"path":"https://sipemu.github.io/fdars/reference/fdata2fd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Functional Data to fd class ‚Äî fdata2fd","text":"fdataobj object class 'fdata'. nbasis Number basis functions (default 10). type Type basis: \"bspline\" (default) \"fourier\".","code":""},{"path":"https://sipemu.github.io/fdars/reference/fdata2fd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Functional Data to fd class ‚Äî fdata2fd","text":"object class 'fd' fda package.","code":""},{"path":"https://sipemu.github.io/fdars/reference/fdata2fd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert Functional Data to fd class ‚Äî fdata2fd","text":"","code":"if (FALSE) { # \\dontrun{ t <- seq(0, 1, length.out = 50) X <- matrix(0, 20, 50) for (i in 1:20) X[i, ] <- sin(2*pi*t) + rnorm(50, sd = 0.1) fd <- fdata(X, argvals = t) fd_obj <- fdata2fd(fd, nbasis = 10) } # }"},{"path":"https://sipemu.github.io/fdars/reference/fdata2pc.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Functional Data to Principal Component Scores ‚Äî fdata2pc","title":"Convert Functional Data to Principal Component Scores ‚Äî fdata2pc","text":"Performs functional PCA returns principal component scores functional data. Uses SVD centered data.","code":""},{"path":"https://sipemu.github.io/fdars/reference/fdata2pc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Functional Data to Principal Component Scores ‚Äî fdata2pc","text":"","code":"fdata2pc(fdataobj, ncomp = 2, lambda = 0, norm = TRUE)"},{"path":"https://sipemu.github.io/fdars/reference/fdata2pc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Functional Data to Principal Component Scores ‚Äî fdata2pc","text":"fdataobj object class 'fdata'. ncomp Number principal components extract (default 2). lambda Regularization parameter (default 0, currently used). norm Logical. TRUE (default), normalize scores.","code":""},{"path":"https://sipemu.github.io/fdars/reference/fdata2pc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Functional Data to Principal Component Scores ‚Äî fdata2pc","text":"list components: d Singular values (proportional sqrt eigenvalues) rotation fdata object containing PC loadings x Matrix PC scores (n x ncomp) mean Mean function (numeric vector) fdataobj.cen Centered fdata object call function call","code":""},{"path":"https://sipemu.github.io/fdars/reference/fdata2pc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert Functional Data to Principal Component Scores ‚Äî fdata2pc","text":"","code":"t <- seq(0, 1, length.out = 50) X <- matrix(0, 20, 50) for (i in 1:20) X[i, ] <- sin(2*pi*t) + rnorm(50, sd = 0.1) fd <- fdata(X, argvals = t) pc <- fdata2pc(fd, ncomp = 3)"},{"path":"https://sipemu.github.io/fdars/reference/fdata2pls.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert Functional Data to PLS Scores ‚Äî fdata2pls","title":"Convert Functional Data to PLS Scores ‚Äî fdata2pls","text":"Performs Partial Least Squares regression returns component scores functional data using NIPALS algorithm.","code":""},{"path":"https://sipemu.github.io/fdars/reference/fdata2pls.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert Functional Data to PLS Scores ‚Äî fdata2pls","text":"","code":"fdata2pls(fdataobj, y, ncomp = 2, lambda = 0, norm = TRUE)"},{"path":"https://sipemu.github.io/fdars/reference/fdata2pls.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert Functional Data to PLS Scores ‚Äî fdata2pls","text":"fdataobj object class 'fdata'. y Response vector (numeric). ncomp Number PLS components extract (default 2). lambda Regularization parameter (default 0, currently used). norm Logical. TRUE (default), normalize scores.","code":""},{"path":"https://sipemu.github.io/fdars/reference/fdata2pls.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert Functional Data to PLS Scores ‚Äî fdata2pls","text":"list components: weights Matrix PLS weights (m x ncomp) scores Matrix PLS scores (n x ncomp) loadings Matrix PLS loadings (m x ncomp) call function call","code":""},{"path":"https://sipemu.github.io/fdars/reference/fdata2pls.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert Functional Data to PLS Scores ‚Äî fdata2pls","text":"","code":"t <- seq(0, 1, length.out = 50) X <- matrix(0, 20, 50) for (i in 1:20) X[i, ] <- sin(2*pi*t) + rnorm(50, sd = 0.1) y <- rowMeans(X) + rnorm(20, sd = 0.1) fd <- fdata(X, argvals = t) pls <- fdata2pls(fd, y, ncomp = 3)"},{"path":"https://sipemu.github.io/fdars/reference/flm.test.html","id":null,"dir":"Reference","previous_headings":"","what":"Statistical Tests for Functional Data ‚Äî flm.test","title":"Statistical Tests for Functional Data ‚Äî flm.test","text":"Functions hypothesis testing functional data. Test Functional Linear Model","code":""},{"path":"https://sipemu.github.io/fdars/reference/flm.test.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Statistical Tests for Functional Data ‚Äî flm.test","text":"","code":"flm.test(fdataobj, y, B = 500, ...)"},{"path":"https://sipemu.github.io/fdars/reference/flm.test.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Statistical Tests for Functional Data ‚Äî flm.test","text":"fdataobj object class 'fdata' (functional covariate). y Response vector. B Number bootstrap samples p-value computation. ... Additional arguments.","code":""},{"path":"https://sipemu.github.io/fdars/reference/flm.test.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Statistical Tests for Functional Data ‚Äî flm.test","text":"list class 'htest' components: statistic test statistic p.value Bootstrap p-value method Name test","code":""},{"path":"https://sipemu.github.io/fdars/reference/flm.test.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Statistical Tests for Functional Data ‚Äî flm.test","text":"Tests goodness--fit functional linear model using projected Cramer-von Mises statistic.","code":""},{"path":"https://sipemu.github.io/fdars/reference/flm.test.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Statistical Tests for Functional Data ‚Äî flm.test","text":"","code":"fd <- fdata(matrix(rnorm(200), 20, 10)) y <- rnorm(20) # test_result <- flm.test(fd, y, B = 100)"},{"path":"https://sipemu.github.io/fdars/reference/fmean.test.fdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Test for Equality of Functional Means ‚Äî fmean.test.fdata","title":"Test for Equality of Functional Means ‚Äî fmean.test.fdata","text":"Tests whether mean function equals specified value.","code":""},{"path":"https://sipemu.github.io/fdars/reference/fmean.test.fdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test for Equality of Functional Means ‚Äî fmean.test.fdata","text":"","code":"fmean.test.fdata(fdataobj, mu0 = NULL, B = 500, ...)"},{"path":"https://sipemu.github.io/fdars/reference/fmean.test.fdata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test for Equality of Functional Means ‚Äî fmean.test.fdata","text":"fdataobj object class 'fdata'. mu0 Hypothesized mean function (vector). NULL, tests zero. B Number bootstrap samples p-value computation. ... Additional arguments.","code":""},{"path":"https://sipemu.github.io/fdars/reference/fmean.test.fdata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test for Equality of Functional Means ‚Äî fmean.test.fdata","text":"list class 'htest' components: statistic test statistic p.value Bootstrap p-value method Name test","code":""},{"path":"https://sipemu.github.io/fdars/reference/fmean.test.fdata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test for Equality of Functional Means ‚Äî fmean.test.fdata","text":"","code":"fd <- fdata(matrix(rnorm(200), 20, 10)) # test_result <- fmean.test.fdata(fd, B = 100)"},{"path":"https://sipemu.github.io/fdars/reference/fregre.basis.cv.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-Validation for Functional Basis Regression ‚Äî fregre.basis.cv","title":"Cross-Validation for Functional Basis Regression ‚Äî fregre.basis.cv","text":"Performs k-fold cross-validation select optimal regularization parameter (lambda) functional basis regression.","code":""},{"path":"https://sipemu.github.io/fdars/reference/fregre.basis.cv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-Validation for Functional Basis Regression ‚Äî fregre.basis.cv","text":"","code":"fregre.basis.cv(fdataobj, y, kfold = 10, lambda.range = NULL, seed = NULL, ...)"},{"path":"https://sipemu.github.io/fdars/reference/fregre.basis.cv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-Validation for Functional Basis Regression ‚Äî fregre.basis.cv","text":"fdataobj object class 'fdata' (functional covariate). y Response vector. kfold Number folds cross-validation (default 10). lambda.range Range lambda values try. Default 10^seq(-4, 4, length.= 20). seed Random seed fold assignment. ... Additional arguments passed fregre.basis.","code":""},{"path":"https://sipemu.github.io/fdars/reference/fregre.basis.cv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-Validation for Functional Basis Regression ‚Äî fregre.basis.cv","text":"list components: optimal.lambda Optimal regularization parameter cv.errors Mean squared prediction error lambda cv.se Standard error cv.errors model Fitted model optimal lambda","code":""},{"path":"https://sipemu.github.io/fdars/reference/fregre.basis.html","id":null,"dir":"Reference","previous_headings":"","what":"Functional Basis Regression ‚Äî fregre.basis","title":"Functional Basis Regression ‚Äî fregre.basis","text":"Fits functional linear model using basis expansion (ridge regression). Uses anofox-regression Rust backend efficient L2-regularized regression.","code":""},{"path":"https://sipemu.github.io/fdars/reference/fregre.basis.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functional Basis Regression ‚Äî fregre.basis","text":"","code":"fregre.basis(fdataobj, y, basis.x = NULL, basis.b = NULL, lambda = 0, ...)"},{"path":"https://sipemu.github.io/fdars/reference/fregre.basis.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functional Basis Regression ‚Äî fregre.basis","text":"fdataobj object class 'fdata' (functional covariate). y Response vector. basis.x Basis functional covariate (currently ignored). basis.b Basis coefficient function (currently ignored). lambda Smoothing/regularization parameter (L2 penalty). ... Additional arguments.","code":""},{"path":"https://sipemu.github.io/fdars/reference/fregre.basis.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functional Basis Regression ‚Äî fregre.basis","text":"fitted regression object class 'fregre.fd' components: coefficients Beta coefficient function values intercept Intercept term fitted.values Fitted values residuals Residuals lambda Regularization parameter used r.squared R-squared (coefficient determination) mean.X Mean functional covariate (prediction) mean.y Mean response (prediction) sr2 Residual variance fdataobj Original functional data y Response vector call function call","code":""},{"path":"https://sipemu.github.io/fdars/reference/fregre.np.cv.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-Validation for Nonparametric Functional Regression ‚Äî fregre.np.cv","title":"Cross-Validation for Nonparametric Functional Regression ‚Äî fregre.np.cv","text":"Performs k-fold cross-validation select optimal bandwidth parameter (h) nonparametric functional regression.","code":""},{"path":"https://sipemu.github.io/fdars/reference/fregre.np.cv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-Validation for Nonparametric Functional Regression ‚Äî fregre.np.cv","text":"","code":"fregre.np.cv(   fdataobj,   y,   kfold = 10,   h.range = NULL,   metric = metric.lp,   seed = NULL,   ... )"},{"path":"https://sipemu.github.io/fdars/reference/fregre.np.cv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-Validation for Nonparametric Functional Regression ‚Äî fregre.np.cv","text":"fdataobj object class 'fdata' (functional covariate). y Response vector. kfold Number folds cross-validation (default 10). h.range Range bandwidth values try. NULL, automatically determined distance matrix. metric Distance metric function. Default metric.lp. seed Random seed fold assignment. ... Additional arguments passed metric function.","code":""},{"path":"https://sipemu.github.io/fdars/reference/fregre.np.cv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-Validation for Nonparametric Functional Regression ‚Äî fregre.np.cv","text":"list components: optimal.h Optimal bandwidth parameter cv.errors Mean squared prediction error h cv.se Standard error cv.errors model Fitted model optimal h","code":""},{"path":"https://sipemu.github.io/fdars/reference/fregre.np.html","id":null,"dir":"Reference","previous_headings":"","what":"Nonparametric Functional Regression ‚Äî fregre.np","title":"Nonparametric Functional Regression ‚Äî fregre.np","text":"Fits functional regression model using kernel smoothing (Nadaraya-Watson). Supports fixed bandwidth (h), k-nearest neighbors global (kNN.gCV) local (kNN.lCV) cross-validation.","code":""},{"path":"https://sipemu.github.io/fdars/reference/fregre.np.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nonparametric Functional Regression ‚Äî fregre.np","text":"","code":"fregre.np(   fdataobj,   y,   h = NULL,   knn = NULL,   type.S = c(\"S.NW\", \"kNN.gCV\", \"kNN.lCV\"),   Ker = \"norm\",   metric = metric.lp,   ... )"},{"path":"https://sipemu.github.io/fdars/reference/fregre.np.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nonparametric Functional Regression ‚Äî fregre.np","text":"fdataobj object class 'fdata' (functional covariate). y Response vector. h Bandwidth parameter. NULL knn NULL, computed automatically. knn Number nearest neighbors consider bandwidth selection. used type.S \"kNN.gCV\" \"kNN.lCV\". type.S Type smoother: \"S.NW\" Nadaraya-Watson fixed h (default), \"kNN.gCV\" k-NN global CV (single k observations), \"kNN.lCV\" k-NN local CV (different k per observation). Ker Kernel type smoothing. Default \"norm\" (Gaussian). metric Distance metric function. Default metric.lp. ... Additional arguments passed metric function.","code":""},{"path":"https://sipemu.github.io/fdars/reference/fregre.np.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Nonparametric Functional Regression ‚Äî fregre.np","text":"fitted regression object class 'fregre.np' components: fitted.values Fitted values residuals Residuals h.opt Optimal/used bandwidth (type.S = \"S.NW\") knn Number neighbors used (kNN methods) k.opt Optimal k value(s) - scalar global, vector local type.S Type smoother used Ker Kernel type used fdataobj Original functional data y Response vector mdist Distance matrix sr2 Residual variance metric Metric function used call function call","code":""},{"path":"https://sipemu.github.io/fdars/reference/fregre.np.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Nonparametric Functional Regression ‚Äî fregre.np","text":"Three smoothing approaches available: Fixed bandwidth (type.S = \"S.NW\"): Uses single bandwidth h predictions. h provided, set median non-zero pairwise distances. k-NN Global CV (type.S = \"kNN.gCV\"): Selects single optimal k observations using leave-one-cross-validation. bandwidth point set include k neighbors. k-NN Local CV (type.S = \"kNN.lCV\"): Selects optimal k_i observation , allowing adaptive smoothing. Useful data varying density across functional space.","code":""},{"path":"https://sipemu.github.io/fdars/reference/fregre.np.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Nonparametric Functional Regression ‚Äî fregre.np","text":"","code":"# Create functional data t <- seq(0, 1, length.out = 50) n <- 50 X <- matrix(0, n, 50) for (i in 1:n) X[i, ] <- sin(2*pi*t) * i/n + rnorm(50, sd = 0.1) y <- rowMeans(X) + rnorm(n, sd = 0.1) fd <- fdata(X, argvals = t)  # Fixed bandwidth fit1 <- fregre.np(fd, y, h = 0.5)  # k-NN with global CV fit2 <- fregre.np(fd, y, type.S = \"kNN.gCV\", knn = 20)  # k-NN with local CV fit3 <- fregre.np(fd, y, type.S = \"kNN.lCV\", knn = 20)"},{"path":"https://sipemu.github.io/fdars/reference/fregre.np.multi.html","id":null,"dir":"Reference","previous_headings":"","what":"Nonparametric Regression with Multiple Functional Predictors ‚Äî fregre.np.multi","title":"Nonparametric Regression with Multiple Functional Predictors ‚Äî fregre.np.multi","text":"Fits nonparametric regression model multiple functional predictors using weighted combination distance matrices.","code":""},{"path":"https://sipemu.github.io/fdars/reference/fregre.np.multi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nonparametric Regression with Multiple Functional Predictors ‚Äî fregre.np.multi","text":"","code":"fregre.np.multi(   fdataobj.list,   y,   weights = NULL,   h = NULL,   knn = NULL,   type.S = c(\"S.NW\", \"kNN.gCV\", \"kNN.lCV\"),   Ker = \"norm\",   metric = metric.lp,   cv.grid = NULL,   cv.folds = 5,   ... )"},{"path":"https://sipemu.github.io/fdars/reference/fregre.np.multi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nonparametric Regression with Multiple Functional Predictors ‚Äî fregre.np.multi","text":"fdataobj.list list fdata objects (functional predictors). must number observations. y Response vector (scalar). weights Weights combining distances. Can : NULL: Equal weights (1/p predictor) Numeric vector: Fixed weights (normalized sum 1) \"cv\": Cross-validate find optimal weights h Bandwidth Nadaraya-Watson kernel (optional). knn Maximum k k-NN methods. type.S Smoother type: \"S.NW\", \"kNN.gCV\", \"kNN.lCV\". Ker Kernel type (default \"norm\" Gaussian). metric Distance metric function (default metric.lp). cv.grid Grid weight values CV (used weights = \"cv\"). Default seq(0, 1, = 0.1) 2 predictors. cv.folds Number folds weight CV (default 5). ... Additional arguments passed metric function.","code":""},{"path":"https://sipemu.github.io/fdars/reference/fregre.np.multi.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Nonparametric Regression with Multiple Functional Predictors ‚Äî fregre.np.multi","text":"object class 'fregre.np.multi' containing: fdataobj.list List functional predictors y Response vector weights Weights used (optimized) weights.cv CV results weights = \"cv\" fitted.values Fitted values residuals Residuals D.list List distance matrices D.combined Combined distance matrix","code":""},{"path":"https://sipemu.github.io/fdars/reference/fregre.np.multi.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Nonparametric Regression with Multiple Functional Predictors ‚Äî fregre.np.multi","text":"","code":"# Create two functional predictors set.seed(42) n <- 50 m <- 30 t_grid <- seq(0, 1, length.out = m)  X1 <- matrix(0, n, m) X2 <- matrix(0, n, m) for (i in 1:n) {   X1[i, ] <- sin(2 * pi * t_grid) * i/n + rnorm(m, sd = 0.1)   X2[i, ] <- cos(2 * pi * t_grid) * i/n + rnorm(m, sd = 0.1) } y <- rowMeans(X1) + 0.5 * rowMeans(X2) + rnorm(n, sd = 0.1)  fd1 <- fdata(X1, argvals = t_grid) fd2 <- fdata(X2, argvals = t_grid)  # Fit with equal weights fit1 <- fregre.np.multi(list(fd1, fd2), y)  # Fit with cross-validated weights fit2 <- fregre.np.multi(list(fd1, fd2), y, weights = \"cv\")"},{"path":"https://sipemu.github.io/fdars/reference/fregre.pc.cv.html","id":null,"dir":"Reference","previous_headings":"","what":"Cross-Validation for Functional PC Regression ‚Äî fregre.pc.cv","title":"Cross-Validation for Functional PC Regression ‚Äî fregre.pc.cv","text":"Performs k-fold cross-validation select optimal number principal components functional PC regression.","code":""},{"path":"https://sipemu.github.io/fdars/reference/fregre.pc.cv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cross-Validation for Functional PC Regression ‚Äî fregre.pc.cv","text":"","code":"fregre.pc.cv(fdataobj, y, kfold = 10, ncomp.range = NULL, seed = NULL, ...)"},{"path":"https://sipemu.github.io/fdars/reference/fregre.pc.cv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cross-Validation for Functional PC Regression ‚Äî fregre.pc.cv","text":"fdataobj object class 'fdata' (functional covariate). y Response vector. kfold Number folds cross-validation (default 10). ncomp.range Range number components try. Default 1 min(n-1, ncol(data)). seed Random seed fold assignment. ... Additional arguments passed fregre.pc.","code":""},{"path":"https://sipemu.github.io/fdars/reference/fregre.pc.cv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cross-Validation for Functional PC Regression ‚Äî fregre.pc.cv","text":"list components: optimal.ncomp Optimal number components cv.errors Mean squared prediction error ncomp cv.se Standard error cv.errors model Fitted model optimal ncomp","code":""},{"path":"https://sipemu.github.io/fdars/reference/fregre.pc.cv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cross-Validation for Functional PC Regression ‚Äî fregre.pc.cv","text":"","code":"# Create functional data with a linear relationship set.seed(42) t <- seq(0, 1, length.out = 50) X <- matrix(0, 100, 50) for (i in 1:100) X[i, ] <- sin(2*pi*t) * i/100 + rnorm(50, sd = 0.1) beta_true <- cos(2*pi*t) y <- X %*% beta_true + rnorm(100, sd = 0.5) fd <- fdata(X, argvals = t)  # Cross-validate to find optimal number of PCs cv_result <- fregre.pc.cv(fd, y, ncomp.range = 1:10)"},{"path":"https://sipemu.github.io/fdars/reference/fregre.pc.html","id":null,"dir":"Reference","previous_headings":"","what":"Functional Regression ‚Äî fregre.pc","title":"Functional Regression ‚Äî fregre.pc","text":"Functions functional regression models. Functional Principal Component Regression","code":""},{"path":"https://sipemu.github.io/fdars/reference/fregre.pc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functional Regression ‚Äî fregre.pc","text":"","code":"fregre.pc(fdataobj, y, ncomp = NULL, ...)"},{"path":"https://sipemu.github.io/fdars/reference/fregre.pc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functional Regression ‚Äî fregre.pc","text":"fdataobj object class 'fdata' (functional covariate). y Response vector. ncomp Number principal components use. ... Additional arguments.","code":""},{"path":"https://sipemu.github.io/fdars/reference/fregre.pc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functional Regression ‚Äî fregre.pc","text":"fitted regression object class 'fregre.fd' components: coefficients Beta coefficient function values intercept Intercept term fitted.values Fitted values residuals Residuals ncomp Number components used mean.X Mean functional covariate (prediction) mean.y Mean response (prediction) rotation PC loadings (prediction) l Indices selected components lm Underlying linear model sr2 Residual variance fdataobj Original functional data y Response vector call function call","code":""},{"path":"https://sipemu.github.io/fdars/reference/fregre.pc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Functional Regression ‚Äî fregre.pc","text":"Fits functional linear model using principal component regression.","code":""},{"path":"https://sipemu.github.io/fdars/reference/gmed.html","id":null,"dir":"Reference","previous_headings":"","what":"Geometric Median of Functional Data ‚Äî gmed","title":"Geometric Median of Functional Data ‚Äî gmed","text":"Computes geometric median (L1 median) functional data using Weiszfeld's iterative algorithm. geometric median minimizes sum L2 distances curves/surfaces, making robust outliers.","code":""},{"path":"https://sipemu.github.io/fdars/reference/gmed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Geometric Median of Functional Data ‚Äî gmed","text":"","code":"gmed(fdataobj, max.iter = 100, tol = 1e-06)"},{"path":"https://sipemu.github.io/fdars/reference/gmed.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Geometric Median of Functional Data ‚Äî gmed","text":"fdataobj object class 'fdata'. max.iter Maximum number iterations (default 100). tol Convergence tolerance (default 1e-6).","code":""},{"path":"https://sipemu.github.io/fdars/reference/gmed.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Geometric Median of Functional Data ‚Äî gmed","text":"fdata object containing geometric median function (1D 2D).","code":""},{"path":"https://sipemu.github.io/fdars/reference/gmed.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Geometric Median of Functional Data ‚Äî gmed","text":"geometric median y minimizes: $$\\sum_{=1}^n ||X_i - y||_{L2}$$ Unlike mean (L2 center), geometric median robust outliers extreme values bounded influence (influence function bounded). Weiszfeld algorithm iteratively reweighted least squares method converges geometric median.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/reference/gmed.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Geometric Median of Functional Data ‚Äî gmed","text":"","code":"# Create functional data with an outlier t <- seq(0, 1, length.out = 50) X <- matrix(0, 20, 50) for (i in 1:19) X[i, ] <- sin(2*pi*t) + rnorm(50, sd = 0.1) X[20, ] <- sin(2*pi*t) + 5  # Large outlier fd <- fdata(X, argvals = t)  # Compare mean vs geometric median mean_curve <- mean(fd) gmed_curve <- gmed(fd)  # The geometric median is less affected by the outlier"},{"path":"https://sipemu.github.io/fdars/reference/group.distance.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Distance/Similarity Between Groups of Functional Data ‚Äî group.distance","title":"Compute Distance/Similarity Between Groups of Functional Data ‚Äî group.distance","text":"Computes various distance similarity measures pre-defined groups functional curves.","code":""},{"path":"https://sipemu.github.io/fdars/reference/group.distance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Distance/Similarity Between Groups of Functional Data ‚Äî group.distance","text":"","code":"group.distance(   fdataobj,   groups,   method = c(\"centroid\", \"hausdorff\", \"depth\", \"all\"),   metric = \"lp\",   p = 2,   depth.method = \"FM\",   ... )"},{"path":"https://sipemu.github.io/fdars/reference/group.distance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Distance/Similarity Between Groups of Functional Data ‚Äî group.distance","text":"fdataobj object class 'fdata'. groups factor character vector specifying group membership curve. Must length equal number curves. method Distance/similarity method: \"centroid\": L2 distance group mean curves \"hausdorff\": Hausdorff-style distance groups \"depth\": Depth-based overlap (similarity, distance) \"\": Compute methods metric Distance metric centroid method (default \"lp\"). p Power Lp metric (default 2 L2). depth.method Depth method depth-based overlap (default \"FM\"). ... Additional arguments passed metric functions.","code":""},{"path":"https://sipemu.github.io/fdars/reference/group.distance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Distance/Similarity Between Groups of Functional Data ‚Äî group.distance","text":"object class 'group.distance' containing: centroid Centroid distance matrix (method includes centroid) hausdorff Hausdorff distance matrix (method includes hausdorff) depth Depth-based similarity matrix (method includes depth) groups Unique group labels group.sizes Number curves per group method Methods used","code":""},{"path":"https://sipemu.github.io/fdars/reference/group.distance.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Distance/Similarity Between Groups of Functional Data ‚Äî group.distance","text":"","code":"# Create grouped functional data set.seed(42) n <- 30 m <- 50 t_grid <- seq(0, 1, length.out = m) X <- matrix(0, n, m) for (i in 1:15) X[i, ] <- sin(2 * pi * t_grid) + rnorm(m, sd = 0.1) for (i in 16:30) X[i, ] <- cos(2 * pi * t_grid) + rnorm(m, sd = 0.1) fd <- fdata(X, argvals = t_grid) groups <- factor(rep(c(\"A\", \"B\"), each = 15))  # Compute all distance measures gd <- group.distance(fd, groups, method = \"all\") print(gd) #> Group Distance Analysis #> ======================= #> Groups: A, B  #> Group sizes: A=15, B=15  #>  #> Centroid Distance (L2 between group means): #>       A     B #> A 0.000 1.002 #> B 1.002 0.000 #>  #> Hausdorff Distance (worst-case between groups): #>       A     B #> A 0.000 1.018 #> B 1.018 0.000 #>  #> Depth Overlap (similarity, higher = more similar): #>       A     B #> A 1.000 0.029 #> B 0.027 1.000 #>"},{"path":"https://sipemu.github.io/fdars/reference/group.test.html","id":null,"dir":"Reference","previous_headings":"","what":"Permutation Test for Group Differences ‚Äî group.test","title":"Permutation Test for Group Differences ‚Äî group.test","text":"Tests whether groups functional data significantly different using permutation testing.","code":""},{"path":"https://sipemu.github.io/fdars/reference/group.test.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Permutation Test for Group Differences ‚Äî group.test","text":"","code":"group.test(   fdataobj,   groups,   n.perm = 1000,   statistic = c(\"centroid\", \"ratio\"),   ... )"},{"path":"https://sipemu.github.io/fdars/reference/group.test.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Permutation Test for Group Differences ‚Äî group.test","text":"fdataobj object class 'fdata'. groups factor character vector specifying group membership. n.perm Number permutations (default 1000). statistic Test statistic: \"centroid\" (distance group means) \"ratio\" (/within group variance ratio). ... Additional arguments passed distance functions.","code":""},{"path":"https://sipemu.github.io/fdars/reference/group.test.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Permutation Test for Group Differences ‚Äî group.test","text":"object class 'group.test' containing: statistic Observed test statistic p.value Permutation p-value perm.dist Permutation distribution test statistic n.perm Number permutations used","code":""},{"path":"https://sipemu.github.io/fdars/reference/group.test.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Permutation Test for Group Differences ‚Äî group.test","text":"Null Hypothesis (H0): groups come distribution. , group labels exchangeable systematic difference functional curves different groups. Alternative Hypothesis (H1): least one group differs others terms location (mean function) dispersion. test works : Computing test statistic observed data Repeatedly permuting group labels recomputing statistic Calculating p-value proportion permuted statistics >= observed Two test statistics available: \"centroid\": Sum pairwise L2 distances group mean functions. Sensitive differences group locations (means). \"ratio\": Ratio -group within-group variance, similar F-statistic. Sensitive location dispersion. small p-value (e.g., < 0.05) indicates evidence H0, suggesting groups significantly different.","code":""},{"path":"https://sipemu.github.io/fdars/reference/group.test.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Permutation Test for Group Differences ‚Äî group.test","text":"","code":"if (FALSE) { # \\dontrun{ set.seed(42) n <- 30 m <- 50 t_grid <- seq(0, 1, length.out = m) X <- matrix(0, n, m) for (i in 1:15) X[i, ] <- sin(2 * pi * t_grid) + rnorm(m, sd = 0.1) for (i in 16:30) X[i, ] <- cos(2 * pi * t_grid) + rnorm(m, sd = 0.1) fd <- fdata(X, argvals = t_grid) groups <- factor(rep(c(\"A\", \"B\"), each = 15))  # Test for significant difference gt <- group.test(fd, groups, n.perm = 500) print(gt) } # }"},{"path":"https://sipemu.github.io/fdars/reference/h.default.html","id":null,"dir":"Reference","previous_headings":"","what":"Default Bandwidth ‚Äî h.default","title":"Default Bandwidth ‚Äî h.default","text":"Compute default bandwidth 15th percentile pairwise distances.","code":""},{"path":"https://sipemu.github.io/fdars/reference/h.default.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Default Bandwidth ‚Äî h.default","text":"","code":"h.default(fdataobj, ...)"},{"path":"https://sipemu.github.io/fdars/reference/h.default.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Default Bandwidth ‚Äî h.default","text":"fdataobj object class 'fdata', numeric vector evaluation points. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/h.default.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Default Bandwidth ‚Äî h.default","text":"scalar bandwidth value.","code":""},{"path":"https://sipemu.github.io/fdars/reference/h.default.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Default Bandwidth ‚Äî h.default","text":"","code":"tt <- seq(0, 1, length.out = 50) h <- h.default(tt)"},{"path":"https://sipemu.github.io/fdars/reference/inprod.fdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Inner Product of Functional Data ‚Äî inprod.fdata","title":"Inner Product of Functional Data ‚Äî inprod.fdata","text":"Compute inner product two functional data objects. <f, g> = integral(f(t) * g(t) dt)","code":""},{"path":"https://sipemu.github.io/fdars/reference/inprod.fdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inner Product of Functional Data ‚Äî inprod.fdata","text":"","code":"inprod.fdata(fdata1, fdata2 = NULL)"},{"path":"https://sipemu.github.io/fdars/reference/inprod.fdata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inner Product of Functional Data ‚Äî inprod.fdata","text":"fdata1 First functional data object. fdata2 Second functional data object. NULL, computes inner products fdata1 .","code":""},{"path":"https://sipemu.github.io/fdars/reference/inprod.fdata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Inner Product of Functional Data ‚Äî inprod.fdata","text":"matrix inner products. fdata1 n1 curves fdata2 n2 curves, returns n1 x n2 matrix.","code":""},{"path":"https://sipemu.github.io/fdars/reference/inprod.fdata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Inner Product of Functional Data ‚Äî inprod.fdata","text":"","code":"t <- seq(0, 1, length.out = 100) X1 <- matrix(sin(2*pi*t), nrow = 1) X2 <- matrix(cos(2*pi*t), nrow = 1) fd1 <- fdata(X1, argvals = t) fd2 <- fdata(X2, argvals = t) # Inner product of sin and cos over [0,1] should be 0 inprod.fdata(fd1, fd2) #>              [,1] #> [1,] 2.218175e-17"},{"path":"https://sipemu.github.io/fdars/reference/instantaneous_period.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate Instantaneous Period ‚Äî instantaneous_period","title":"Estimate Instantaneous Period ‚Äî instantaneous_period","text":"signals time-varying frequency (drifting period), estimates instantaneous period time point using Hilbert transform.","code":""},{"path":"https://sipemu.github.io/fdars/reference/instantaneous_period.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate Instantaneous Period ‚Äî instantaneous_period","text":"","code":"instantaneous_period(fdataobj)"},{"path":"https://sipemu.github.io/fdars/reference/instantaneous_period.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate Instantaneous Period ‚Äî instantaneous_period","text":"fdataobj fdata object.","code":""},{"path":"https://sipemu.github.io/fdars/reference/instantaneous_period.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate Instantaneous Period ‚Äî instantaneous_period","text":"list fdata objects: period Instantaneous period time point frequency Instantaneous frequency time point amplitude Instantaneous amplitude (envelope) time point","code":""},{"path":"https://sipemu.github.io/fdars/reference/instantaneous_period.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Estimate Instantaneous Period ‚Äî instantaneous_period","text":"Hilbert transform used compute analytic signal, instantaneous phase extracted. derivative phase gives instantaneous frequency, 1/frequency gives period. particularly useful signals period constant, circadian rhythms drift frequency-modulated signals.","code":""},{"path":"https://sipemu.github.io/fdars/reference/instantaneous_period.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate Instantaneous Period ‚Äî instantaneous_period","text":"","code":"# Chirp signal with increasing frequency t <- seq(0, 10, length.out = 500) freq <- 0.5 + 0.1 * t  # Frequency increases from 0.5 to 1.5 X <- matrix(sin(2 * pi * cumsum(freq) * diff(c(0, t))), nrow = 1) fd <- fdata(X, argvals = t)  # Estimate instantaneous period inst <- instantaneous_period(fd) # plot(inst$period)  # Shows decreasing period over time"},{"path":"https://sipemu.github.io/fdars/reference/int.simpson.html","id":null,"dir":"Reference","previous_headings":"","what":"Utility Functions for Functional Data Analysis ‚Äî int.simpson","title":"Utility Functions for Functional Data Analysis ‚Äî int.simpson","text":"Various utility functions including integration, inner products, random process generation, prediction metrics. Simpson's Rule Integration","code":""},{"path":"https://sipemu.github.io/fdars/reference/int.simpson.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Utility Functions for Functional Data Analysis ‚Äî int.simpson","text":"","code":"int.simpson(fdataobj)"},{"path":"https://sipemu.github.io/fdars/reference/int.simpson.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Utility Functions for Functional Data Analysis ‚Äî int.simpson","text":"fdataobj object class 'fdata'.","code":""},{"path":"https://sipemu.github.io/fdars/reference/int.simpson.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Utility Functions for Functional Data Analysis ‚Äî int.simpson","text":"numeric vector integrals, one per curve.","code":""},{"path":"https://sipemu.github.io/fdars/reference/int.simpson.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Utility Functions for Functional Data Analysis ‚Äî int.simpson","text":"Integrate functional data domain using Simpson's rule (composite trapezoidal rule non-uniform grids).","code":""},{"path":"https://sipemu.github.io/fdars/reference/int.simpson.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Utility Functions for Functional Data Analysis ‚Äî int.simpson","text":"","code":"t <- seq(0, 1, length.out = 100) X <- matrix(0, 10, 100) for (i in 1:10) X[i, ] <- sin(2*pi*t) fd <- fdata(X, argvals = t) integrals <- int.simpson(fd)  # Should be approximately 0"},{"path":"https://sipemu.github.io/fdars/reference/kernel_add.html","id":null,"dir":"Reference","previous_headings":"","what":"Add Covariance Functions ‚Äî kernel_add","title":"Add Covariance Functions ‚Äî kernel_add","text":"Combines two covariance functions addition.","code":""},{"path":"https://sipemu.github.io/fdars/reference/kernel_add.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add Covariance Functions ‚Äî kernel_add","text":"","code":"kernel_add(kernel1, kernel2)"},{"path":"https://sipemu.github.io/fdars/reference/kernel_add.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add Covariance Functions ‚Äî kernel_add","text":"kernel1 First covariance function. kernel2 Second covariance function.","code":""},{"path":"https://sipemu.github.io/fdars/reference/kernel_add.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add Covariance Functions ‚Äî kernel_add","text":"combined covariance function.","code":""},{"path":"https://sipemu.github.io/fdars/reference/kernel_add.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add Covariance Functions ‚Äî kernel_add","text":"","code":"# Combine Gaussian with white noise k_signal <- kernel_gaussian(variance = 1, length_scale = 0.2) k_noise <- kernel_whitenoise(variance = 0.1) k_total <- kernel_add(k_signal, k_noise)  t <- seq(0, 1, length.out = 50) fd <- make_gaussian_process(n = 5, t = t, cov = k_total)"},{"path":"https://sipemu.github.io/fdars/reference/kernel_brownian.html","id":null,"dir":"Reference","previous_headings":"","what":"Brownian Motion Covariance Function ‚Äî kernel_brownian","title":"Brownian Motion Covariance Function ‚Äî kernel_brownian","text":"Computes Brownian motion (Wiener process) covariance function: $$k(s, t) = \\sigma^2 \\min(s, t)$$","code":""},{"path":"https://sipemu.github.io/fdars/reference/kernel_brownian.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Brownian Motion Covariance Function ‚Äî kernel_brownian","text":"","code":"kernel_brownian(variance = 1)"},{"path":"https://sipemu.github.io/fdars/reference/kernel_brownian.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Brownian Motion Covariance Function ‚Äî kernel_brownian","text":"variance Variance parameter \\(\\sigma^2\\) (default 1).","code":""},{"path":"https://sipemu.github.io/fdars/reference/kernel_brownian.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Brownian Motion Covariance Function ‚Äî kernel_brownian","text":"covariance function object class 'kernel_brownian'.","code":""},{"path":"https://sipemu.github.io/fdars/reference/kernel_brownian.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Brownian Motion Covariance Function ‚Äî kernel_brownian","text":"Brownian motion covariance produces sample paths start 0 independent increments. covariance two points equals variance times minimum positions. covariance defined 1D domains starting 0.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/reference/kernel_brownian.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Brownian Motion Covariance Function ‚Äî kernel_brownian","text":"","code":"# Generate Brownian motion paths cov_func <- kernel_brownian(variance = 1) t <- seq(0, 1, length.out = 100) fd <- make_gaussian_process(n = 10, t = t, cov = cov_func) plot(fd)"},{"path":"https://sipemu.github.io/fdars/reference/kernel_exponential.html","id":null,"dir":"Reference","previous_headings":"","what":"Exponential Covariance Function ‚Äî kernel_exponential","title":"Exponential Covariance Function ‚Äî kernel_exponential","text":"Computes exponential covariance function: $$k(s, t) = \\sigma^2 \\exp\\left(-\\frac{|s-t|}{\\ell}\\right)$$","code":""},{"path":"https://sipemu.github.io/fdars/reference/kernel_exponential.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exponential Covariance Function ‚Äî kernel_exponential","text":"","code":"kernel_exponential(variance = 1, length_scale = 1)"},{"path":"https://sipemu.github.io/fdars/reference/kernel_exponential.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exponential Covariance Function ‚Äî kernel_exponential","text":"variance Variance parameter \\(\\sigma^2\\) (default 1). length_scale Length scale parameter \\(\\ell\\) (default 1).","code":""},{"path":"https://sipemu.github.io/fdars/reference/kernel_exponential.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Exponential Covariance Function ‚Äî kernel_exponential","text":"covariance function object class 'kernel_exponential'.","code":""},{"path":"https://sipemu.github.io/fdars/reference/kernel_exponential.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Exponential Covariance Function ‚Äî kernel_exponential","text":"equivalent Matern covariance \\(\\nu = 0.5\\). Sample paths continuous differentiable (rough). exponential covariance function produces sample paths continuous nowhere differentiable, resulting rough-looking curves. special case Matern family \\(\\nu = 0.5\\).","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/reference/kernel_exponential.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Exponential Covariance Function ‚Äî kernel_exponential","text":"","code":"# Create an exponential covariance function cov_func <- kernel_exponential(variance = 1, length_scale = 0.2)  # Evaluate covariance matrix t <- seq(0, 1, length.out = 50) K <- cov_func(t)  # Generate rough GP samples fd <- make_gaussian_process(n = 10, t = t, cov = cov_func) plot(fd)"},{"path":"https://sipemu.github.io/fdars/reference/kernel_gaussian.html","id":null,"dir":"Reference","previous_headings":"","what":"Gaussian (Squared Exponential) Covariance Function ‚Äî kernel_gaussian","title":"Gaussian (Squared Exponential) Covariance Function ‚Äî kernel_gaussian","text":"Computes Gaussian (RBF/squared exponential) covariance function: $$k(s, t) = \\sigma^2 \\exp\\left(-\\frac{(s-t)^2}{2\\ell^2}\\right)$$","code":""},{"path":"https://sipemu.github.io/fdars/reference/kernel_gaussian.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Gaussian (Squared Exponential) Covariance Function ‚Äî kernel_gaussian","text":"","code":"kernel_gaussian(variance = 1, length_scale = 1)"},{"path":"https://sipemu.github.io/fdars/reference/kernel_gaussian.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Gaussian (Squared Exponential) Covariance Function ‚Äî kernel_gaussian","text":"variance Variance parameter \\(\\sigma^2\\) (default 1). length_scale Length scale parameter \\(\\ell\\) (default 1).","code":""},{"path":"https://sipemu.github.io/fdars/reference/kernel_gaussian.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Gaussian (Squared Exponential) Covariance Function ‚Äî kernel_gaussian","text":"covariance function object class 'kernel_gaussian'.","code":""},{"path":"https://sipemu.github.io/fdars/reference/kernel_gaussian.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Gaussian (Squared Exponential) Covariance Function ‚Äî kernel_gaussian","text":"kernel produces infinitely differentiable (smooth) sample paths. Gaussian covariance function, also known squared exponential radial basis function (RBF) kernel, one commonly used covariance functions. produces smooth sample paths infinitely differentiable. length scale parameter controls quickly correlation decays distance. Larger values produce smoother, slowly varying functions.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/reference/kernel_gaussian.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Gaussian (Squared Exponential) Covariance Function ‚Äî kernel_gaussian","text":"","code":"# Create a Gaussian covariance function cov_func <- kernel_gaussian(variance = 1, length_scale = 0.2)  # Evaluate covariance matrix on a grid t <- seq(0, 1, length.out = 50) K <- cov_func(t) image(K, main = \"Gaussian Covariance Matrix\")   # Generate Gaussian process samples fd <- make_gaussian_process(n = 10, t = t, cov = cov_func) plot(fd)"},{"path":"https://sipemu.github.io/fdars/reference/kernel_linear.html","id":null,"dir":"Reference","previous_headings":"","what":"Linear Covariance Function ‚Äî kernel_linear","title":"Linear Covariance Function ‚Äî kernel_linear","text":"Computes linear covariance function: $$k(s, t) = \\sigma^2 (s - c)(t - c)$$","code":""},{"path":"https://sipemu.github.io/fdars/reference/kernel_linear.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Linear Covariance Function ‚Äî kernel_linear","text":"","code":"kernel_linear(variance = 1, offset = 0)"},{"path":"https://sipemu.github.io/fdars/reference/kernel_linear.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Linear Covariance Function ‚Äî kernel_linear","text":"variance Variance parameter \\(\\sigma^2\\) (default 1). offset Offset parameter \\(c\\) (default 0).","code":""},{"path":"https://sipemu.github.io/fdars/reference/kernel_linear.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Linear Covariance Function ‚Äî kernel_linear","text":"covariance function object class 'kernel_linear'.","code":""},{"path":"https://sipemu.github.io/fdars/reference/kernel_linear.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Linear Covariance Function ‚Äî kernel_linear","text":"linear covariance function produces sample paths linear functions. useful underlying process expected linear trend.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/reference/kernel_linear.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Linear Covariance Function ‚Äî kernel_linear","text":"","code":"# Generate linear function samples cov_func <- kernel_linear(variance = 1) t <- seq(0, 1, length.out = 50) fd <- make_gaussian_process(n = 10, t = t, cov = cov_func) plot(fd)"},{"path":"https://sipemu.github.io/fdars/reference/kernel_matern.html","id":null,"dir":"Reference","previous_headings":"","what":"Matern Covariance Function ‚Äî kernel_matern","title":"Matern Covariance Function ‚Äî kernel_matern","text":"Computes Matern covariance function smoothness parameter \\(\\nu\\): $$k(s, t) = \\sigma^2 \\frac{2^{1-\\nu}}{\\Gamma(\\nu)} \\left(\\sqrt{2\\nu}\\frac{|s-t|}{\\ell}\\right)^\\nu K_\\nu\\left(\\sqrt{2\\nu}\\frac{|s-t|}{\\ell}\\right)$$","code":""},{"path":"https://sipemu.github.io/fdars/reference/kernel_matern.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Matern Covariance Function ‚Äî kernel_matern","text":"","code":"kernel_matern(variance = 1, length_scale = 1, nu = 1.5)"},{"path":"https://sipemu.github.io/fdars/reference/kernel_matern.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Matern Covariance Function ‚Äî kernel_matern","text":"variance Variance parameter \\(\\sigma^2\\) (default 1). length_scale Length scale parameter \\(\\ell\\) (default 1). nu Smoothness parameter \\(\\nu\\) (default 1.5). Common values: nu = 0.5: Exponential (continuous, differentiable) nu = 1.5: differentiable nu = 2.5: Twice differentiable nu = Inf: Gaussian/squared exponential (infinitely differentiable)","code":""},{"path":"https://sipemu.github.io/fdars/reference/kernel_matern.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Matern Covariance Function ‚Äî kernel_matern","text":"covariance function object class 'kernel_matern'.","code":""},{"path":"https://sipemu.github.io/fdars/reference/kernel_matern.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Matern Covariance Function ‚Äî kernel_matern","text":"\\(K_\\nu\\) modified Bessel function second kind. Matern family covariance functions provides flexible control smoothness sample paths \\(\\nu\\) parameter. \\(\\nu\\) increases, sample paths become smoother. Matern family includes exponential (\\(\\nu = 0.5\\)) approaches Gaussian kernel \\(\\nu \\\\infty\\). computational efficiency, special cases \\(\\nu \\\\{0.5, 1.5, 2.5, \\infty\\}\\) use simplified closed-form expressions.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/reference/kernel_matern.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Matern Covariance Function ‚Äî kernel_matern","text":"","code":"# Create Matern covariance functions with different smoothness cov_rough <- kernel_matern(nu = 0.5)    # Equivalent to exponential cov_smooth <- kernel_matern(nu = 2.5)   # Twice differentiable  t <- seq(0, 1, length.out = 50)  # Compare sample paths fd_rough <- make_gaussian_process(n = 5, t = t, cov = cov_rough, seed = 42) fd_smooth <- make_gaussian_process(n = 5, t = t, cov = cov_smooth, seed = 42)"},{"path":"https://sipemu.github.io/fdars/reference/kernel_mult.html","id":null,"dir":"Reference","previous_headings":"","what":"Multiply Covariance Functions ‚Äî kernel_mult","title":"Multiply Covariance Functions ‚Äî kernel_mult","text":"Combines two covariance functions multiplication.","code":""},{"path":"https://sipemu.github.io/fdars/reference/kernel_mult.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Multiply Covariance Functions ‚Äî kernel_mult","text":"","code":"kernel_mult(kernel1, kernel2)"},{"path":"https://sipemu.github.io/fdars/reference/kernel_mult.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Multiply Covariance Functions ‚Äî kernel_mult","text":"kernel1 First covariance function. kernel2 Second covariance function.","code":""},{"path":"https://sipemu.github.io/fdars/reference/kernel_mult.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Multiply Covariance Functions ‚Äî kernel_mult","text":"combined covariance function.","code":""},{"path":"https://sipemu.github.io/fdars/reference/kernel_mult.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Multiply Covariance Functions ‚Äî kernel_mult","text":"","code":"# Multiply periodic with Gaussian for locally periodic behavior k_periodic <- kernel_periodic(period = 0.3) k_gaussian <- kernel_gaussian(length_scale = 0.5) k_prod <- kernel_mult(k_periodic, k_gaussian)"},{"path":"https://sipemu.github.io/fdars/reference/kernel_periodic.html","id":null,"dir":"Reference","previous_headings":"","what":"Periodic Covariance Function ‚Äî kernel_periodic","title":"Periodic Covariance Function ‚Äî kernel_periodic","text":"Computes periodic covariance function: $$k(s, t) = \\sigma^2 \\exp\\left(-\\frac{2\\sin^2(\\pi|s-t|/p)}{\\ell^2}\\right)$$","code":""},{"path":"https://sipemu.github.io/fdars/reference/kernel_periodic.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Periodic Covariance Function ‚Äî kernel_periodic","text":"","code":"kernel_periodic(variance = 1, length_scale = 1, period = 1)"},{"path":"https://sipemu.github.io/fdars/reference/kernel_periodic.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Periodic Covariance Function ‚Äî kernel_periodic","text":"variance Variance parameter \\(\\sigma^2\\) (default 1). length_scale Length scale parameter \\(\\ell\\) (default 1). period Period parameter \\(p\\) (default 1).","code":""},{"path":"https://sipemu.github.io/fdars/reference/kernel_periodic.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Periodic Covariance Function ‚Äî kernel_periodic","text":"covariance function object class 'kernel_periodic'.","code":""},{"path":"https://sipemu.github.io/fdars/reference/kernel_periodic.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Periodic Covariance Function ‚Äî kernel_periodic","text":"periodic covariance function produces sample paths periodic specified period. useful modeling seasonal cyclical patterns functional data.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/reference/kernel_periodic.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Periodic Covariance Function ‚Äî kernel_periodic","text":"","code":"# Generate periodic function samples cov_func <- kernel_periodic(period = 0.5, length_scale = 0.5) t <- seq(0, 2, length.out = 100) fd <- make_gaussian_process(n = 5, t = t, cov = cov_func) plot(fd)"},{"path":"https://sipemu.github.io/fdars/reference/kernel_polynomial.html","id":null,"dir":"Reference","previous_headings":"","what":"Polynomial Covariance Function ‚Äî kernel_polynomial","title":"Polynomial Covariance Function ‚Äî kernel_polynomial","text":"Computes polynomial covariance function: $$k(s, t) = \\sigma^2 (s \\cdot t + c)^p$$","code":""},{"path":"https://sipemu.github.io/fdars/reference/kernel_polynomial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Polynomial Covariance Function ‚Äî kernel_polynomial","text":"","code":"kernel_polynomial(variance = 1, offset = 0, degree = 2)"},{"path":"https://sipemu.github.io/fdars/reference/kernel_polynomial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Polynomial Covariance Function ‚Äî kernel_polynomial","text":"variance Variance parameter \\(\\sigma^2\\) (default 1). offset Offset parameter \\(c\\) (default 0). degree Polynomial degree \\(p\\) (default 2).","code":""},{"path":"https://sipemu.github.io/fdars/reference/kernel_polynomial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Polynomial Covariance Function ‚Äî kernel_polynomial","text":"covariance function object class 'kernel_polynomial'.","code":""},{"path":"https://sipemu.github.io/fdars/reference/kernel_polynomial.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Polynomial Covariance Function ‚Äî kernel_polynomial","text":"polynomial covariance function produces sample paths polynomial functions degree degree. Setting degree = 1 offset = 0 gives linear kernel.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/reference/kernel_polynomial.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Polynomial Covariance Function ‚Äî kernel_polynomial","text":"","code":"# Generate quadratic function samples cov_func <- kernel_polynomial(degree = 2, offset = 1) t <- seq(0, 1, length.out = 50) fd <- make_gaussian_process(n = 10, t = t, cov = cov_func) plot(fd)"},{"path":"https://sipemu.github.io/fdars/reference/kernel_whitenoise.html","id":null,"dir":"Reference","previous_headings":"","what":"White Noise Covariance Function ‚Äî kernel_whitenoise","title":"White Noise Covariance Function ‚Äî kernel_whitenoise","text":"Computes white noise covariance function: $$k(s, t) = \\sigma^2 \\mathbf{1}_{s = t}$$","code":""},{"path":"https://sipemu.github.io/fdars/reference/kernel_whitenoise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"White Noise Covariance Function ‚Äî kernel_whitenoise","text":"","code":"kernel_whitenoise(variance = 1)"},{"path":"https://sipemu.github.io/fdars/reference/kernel_whitenoise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"White Noise Covariance Function ‚Äî kernel_whitenoise","text":"variance Variance (noise level) parameter \\(\\sigma^2\\) (default 1).","code":""},{"path":"https://sipemu.github.io/fdars/reference/kernel_whitenoise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"White Noise Covariance Function ‚Äî kernel_whitenoise","text":"covariance function object class 'kernel_whitenoise'.","code":""},{"path":"https://sipemu.github.io/fdars/reference/kernel_whitenoise.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"White Noise Covariance Function ‚Äî kernel_whitenoise","text":"\\(\\mathbf{1}_{s = t}\\) 1 \\(s = t\\) 0 otherwise. white noise covariance function represents independent noise point. can added covariance functions model observation noise.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/reference/kernel_whitenoise.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"White Noise Covariance Function ‚Äî kernel_whitenoise","text":"","code":"# White noise covariance produces independent samples at each point cov_func <- kernel_whitenoise(variance = 0.1) t <- seq(0, 1, length.out = 50) K <- cov_func(t) # K is diagonal"},{"path":"https://sipemu.github.io/fdars/reference/kernels.html","id":null,"dir":"Reference","previous_headings":"","what":"Covariance Kernel Functions for Gaussian Processes ‚Äî kernels","title":"Covariance Kernel Functions for Gaussian Processes ‚Äî kernels","text":"Parametric covariance functions (kernels) used define covariance structure Gaussian processes. can used make_gaussian_process generate synthetic functional data.","code":""},{"path":"https://sipemu.github.io/fdars/reference/localavg.fdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Local Averages Feature Extraction ‚Äî localavg.fdata","title":"Local Averages Feature Extraction ‚Äî localavg.fdata","text":"Extracts features functional data computing local averages specified intervals. simple effective dimension reduction technique functional data.","code":""},{"path":"https://sipemu.github.io/fdars/reference/localavg.fdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Local Averages Feature Extraction ‚Äî localavg.fdata","text":"","code":"localavg.fdata(fdataobj, n.intervals = 10, intervals = NULL)"},{"path":"https://sipemu.github.io/fdars/reference/localavg.fdata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Local Averages Feature Extraction ‚Äî localavg.fdata","text":"fdataobj object class 'fdata'. n.intervals Number equal-width intervals (default 10). intervals Optional matrix custom intervals (2 columns: start, end). provided, n.intervals ignored.","code":""},{"path":"https://sipemu.github.io/fdars/reference/localavg.fdata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Local Averages Feature Extraction ‚Äî localavg.fdata","text":"matrix n rows (curves) one column per interval, containing local average curve interval.","code":""},{"path":"https://sipemu.github.io/fdars/reference/localavg.fdata.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Local Averages Feature Extraction ‚Äî localavg.fdata","text":"Local averages provide simple way convert functional data multivariate data preserving local structure. curve summarized average value interval. can useful preprocessing step classification clustering methods require fixed-dimensional input.","code":""},{"path":"https://sipemu.github.io/fdars/reference/localavg.fdata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Local Averages Feature Extraction ‚Äî localavg.fdata","text":"","code":"# Create functional data t <- seq(0, 1, length.out = 100) X <- matrix(0, 20, 100) for (i in 1:20) X[i, ] <- sin(2*pi*t) + rnorm(100, sd = 0.1) fd <- fdata(X, argvals = t)  # Extract 5 local average features features <- localavg.fdata(fd, n.intervals = 5) dim(features)  # 20 x 5 #> [1] 20  5  # Use custom intervals intervals <- cbind(c(0, 0.25, 0.5), c(0.25, 0.5, 1)) features2 <- localavg.fdata(fd, intervals = intervals)"},{"path":"https://sipemu.github.io/fdars/reference/magnitudeshape.html","id":null,"dir":"Reference","previous_headings":"","what":"Magnitude-Shape Outlier Detection for Functional Data ‚Äî magnitudeshape","title":"Magnitude-Shape Outlier Detection for Functional Data ‚Äî magnitudeshape","text":"Performs Magnitude-Shape (MS) outlier detection functional data. curve represented point 2D space x-axis represents magnitude outlyingness y-axis represents shape outlyingness.","code":""},{"path":"https://sipemu.github.io/fdars/reference/magnitudeshape.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Magnitude-Shape Outlier Detection for Functional Data ‚Äî magnitudeshape","text":"","code":"magnitudeshape(   fdataobj,   depth.func = depth.MBD,   cutoff.quantile = 0.993,   col.normal = \"black\",   col.outliers = \"red\",   label = \"index\",   label_all = FALSE,   ... )"},{"path":"https://sipemu.github.io/fdars/reference/magnitudeshape.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Magnitude-Shape Outlier Detection for Functional Data ‚Äî magnitudeshape","text":"fdataobj object class 'fdata'. depth.func Depth function use computing outlyingness. Default depth.MBD. cutoff.quantile Quantile outlier cutoff (default 0.993). col.normal Color normal curves (default \"black\"). col.outliers Color outlier curves (default \"red\"). label use labeling outlier points. Options: \"index\": Use numeric indices (default) \"id\": Use observation IDs fdata object column name fdata metadata (e.g., \"patient_id\") NULL: labels label_all Logical. TRUE, label points, just outliers. Default FALSE. ... Additional arguments passed depth function.","code":""},{"path":"https://sipemu.github.io/fdars/reference/magnitudeshape.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Magnitude-Shape Outlier Detection for Functional Data ‚Äî magnitudeshape","text":"list class 'magnitudeshape' components: MO Magnitude outlyingness values VO Shape (variability) outlyingness values outliers Indices detected outliers cutoff Chi-squared cutoff value used plot ggplot object","code":""},{"path":"https://sipemu.github.io/fdars/reference/magnitudeshape.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Magnitude-Shape Outlier Detection for Functional Data ‚Äî magnitudeshape","text":"MS plot (Dai & Genton, 2019) decomposes functional outlyingness : Magnitude Outlyingness (MO): Based pointwise median directional outlyingness - captures shift outliers Shape Outlyingness (VO): Based variability directional outlyingness - captures shape outliers Outliers detected using chi-squared distribution cutoff specified quantile.","code":""},{"path":"https://sipemu.github.io/fdars/reference/magnitudeshape.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Magnitude-Shape Outlier Detection for Functional Data ‚Äî magnitudeshape","text":"Dai, W. Genton, M.G. (2019). Directional outlyingness multivariate functional data. Computational Statistics & Data Analysis, 131, 50-65.","code":""},{"path":"https://sipemu.github.io/fdars/reference/magnitudeshape.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Magnitude-Shape Outlier Detection for Functional Data ‚Äî magnitudeshape","text":"","code":"# Create functional data with outliers set.seed(42) t <- seq(0, 1, length.out = 50) X <- matrix(0, 30, 50) for (i in 1:28) X[i, ] <- sin(2*pi*t) + rnorm(50, sd = 0.2) X[29, ] <- sin(2*pi*t) + 2  # Magnitude outlier X[30, ] <- sin(4*pi*t)       # Shape outlier fd <- fdata(X, argvals = t)  # Create MS plot ms <- magnitudeshape(fd)  # With IDs and metadata fd <- fdata(X, argvals = t, id = paste0(\"curve_\", 1:30)) ms <- magnitudeshape(fd, label = \"id\")"},{"path":"https://sipemu.github.io/fdars/reference/make_gaussian_process.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Gaussian Process Samples ‚Äî make_gaussian_process","title":"Generate Gaussian Process Samples ‚Äî make_gaussian_process","text":"Generates functional data samples Gaussian process specified mean covariance functions.","code":""},{"path":"https://sipemu.github.io/fdars/reference/make_gaussian_process.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Gaussian Process Samples ‚Äî make_gaussian_process","text":"","code":"make_gaussian_process(n, t, cov = kernel_gaussian(), mean = 0, seed = NULL)"},{"path":"https://sipemu.github.io/fdars/reference/make_gaussian_process.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Gaussian Process Samples ‚Äî make_gaussian_process","text":"n Number samples generate. t Evaluation points (vector 1D, list two vectors 2D). cov Covariance function (kernel_gaussian, kernel_matern, etc.). mean Mean function. Can scalar (default 0), vector length equal number evaluation points, function. seed Optional random seed reproducibility.","code":""},{"path":"https://sipemu.github.io/fdars/reference/make_gaussian_process.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Gaussian Process Samples ‚Äî make_gaussian_process","text":"fdata object containing generated samples.","code":""},{"path":"https://sipemu.github.io/fdars/reference/make_gaussian_process.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Gaussian Process Samples ‚Äî make_gaussian_process","text":"function generates samples Gaussian process specified covariance structure. samples generated computing Cholesky decomposition covariance matrix multiplying standard normal random variables. 2D functional data, pass t list two vectors representing grid dimension.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/reference/make_gaussian_process.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Gaussian Process Samples ‚Äî make_gaussian_process","text":"","code":"# Generate smooth GP samples with Gaussian covariance t <- seq(0, 1, length.out = 100) fd <- make_gaussian_process(n = 20, t = t,                             cov = kernel_gaussian(length_scale = 0.2),                             seed = 42) plot(fd)   # Generate rough GP samples with exponential covariance fd_rough <- make_gaussian_process(n = 20, t = t,                                   cov = kernel_exponential(length_scale = 0.1),                                   seed = 42) plot(fd_rough)   # Generate 2D GP samples (surfaces) s <- seq(0, 1, length.out = 20) t2 <- seq(0, 1, length.out = 20) fd2d <- make_gaussian_process(n = 5, t = list(s, t2),                               cov = kernel_gaussian(length_scale = 0.3),                               seed = 42) plot(fd2d)   # Generate GP with non-zero mean mean_func <- function(t) sin(2 * pi * t) fd_mean <- make_gaussian_process(n = 10, t = t,                                  cov = kernel_gaussian(variance = 0.1),                                  mean = mean_func, seed = 42) plot(fd_mean)"},{"path":"https://sipemu.github.io/fdars/reference/mean.fdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute functional mean ‚Äî mean.fdata","title":"Compute functional mean ‚Äî mean.fdata","text":"Computes pointwise mean function across observations. S3 method generic mean function.","code":""},{"path":"https://sipemu.github.io/fdars/reference/mean.fdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute functional mean ‚Äî mean.fdata","text":"","code":"# S3 method for class 'fdata' mean(x, ...)"},{"path":"https://sipemu.github.io/fdars/reference/mean.fdata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute functional mean ‚Äî mean.fdata","text":"x object class 'fdata'. ... Additional arguments (currently ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/mean.fdata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute functional mean ‚Äî mean.fdata","text":"1D fdata: numeric vector containing mean function values. 2D fdata: fdata object containing mean surface.","code":""},{"path":"https://sipemu.github.io/fdars/reference/mean.fdata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute functional mean ‚Äî mean.fdata","text":"","code":"# 1D functional data fd <- fdata(matrix(rnorm(100), 10, 10)) fm <- mean(fd)  # 2D functional data X <- array(rnorm(500), dim = c(5, 10, 10)) fd2d <- fdata(X, argvals = list(1:10, 1:10), fdata2d = TRUE) fm2d <- mean(fd2d)"},{"path":"https://sipemu.github.io/fdars/reference/median.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Functional Median ‚Äî median","title":"Compute Functional Median ‚Äî median","text":"Returns curve maximum depth using specified depth method.","code":""},{"path":"https://sipemu.github.io/fdars/reference/median.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Functional Median ‚Äî median","text":"","code":"median(   fdataobj,   method = c(\"FM\", \"mode\", \"RP\", \"RT\", \"BD\", \"MBD\", \"FSD\", \"KFSD\", \"RPD\"),   ... )"},{"path":"https://sipemu.github.io/fdars/reference/median.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Functional Median ‚Äî median","text":"fdataobj object class 'fdata'. method Depth method use. One \"FM\", \"mode\", \"RP\", \"RT\", \"BD\", \"MBD\", \"FSD\", \"KFSD\", \"RPD\". Default \"FM\". ... Additional arguments passed depth function.","code":""},{"path":"https://sipemu.github.io/fdars/reference/median.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Functional Median ‚Äî median","text":"curve (fdata object) maximum depth.","code":""},{"path":"https://sipemu.github.io/fdars/reference/median.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Functional Median ‚Äî median","text":"","code":"fd <- fdata(matrix(rnorm(100), 10, 10)) med <- median(fd) med_mode <- median(fd, method = \"mode\")"},{"path":"https://sipemu.github.io/fdars/reference/metric.DTW.html","id":null,"dir":"Reference","previous_headings":"","what":"Dynamic Time Warping for Functional Data ‚Äî metric.DTW","title":"Dynamic Time Warping for Functional Data ‚Äî metric.DTW","text":"Computes Dynamic Time Warping distance functional data. DTW allows non-linear alignment curves.","code":""},{"path":"https://sipemu.github.io/fdars/reference/metric.DTW.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dynamic Time Warping for Functional Data ‚Äî metric.DTW","text":"","code":"metric.DTW(fdata1, fdata2 = NULL, p = 2, w = NULL, ...)"},{"path":"https://sipemu.github.io/fdars/reference/metric.DTW.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dynamic Time Warping for Functional Data ‚Äî metric.DTW","text":"fdata1 object class 'fdata'. fdata2 object class 'fdata'. NULL, computes self-distances. p p Lp distance (default 2 L2/Euclidean). w Sakoe-Chiba window constraint. Default min(ncol(fdata1), ncol(fdata2)). Use -1 window constraint. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/metric.DTW.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Dynamic Time Warping for Functional Data ‚Äî metric.DTW","text":"distance matrix.","code":""},{"path":"https://sipemu.github.io/fdars/reference/metric.DTW.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Dynamic Time Warping for Functional Data ‚Äî metric.DTW","text":"","code":"fd <- fdata(matrix(rnorm(100), 10, 10)) D <- metric.DTW(fd)"},{"path":"https://sipemu.github.io/fdars/reference/metric.hausdorff.html","id":null,"dir":"Reference","previous_headings":"","what":"Hausdorff Metric for Functional Data ‚Äî metric.hausdorff","title":"Hausdorff Metric for Functional Data ‚Äî metric.hausdorff","text":"Computes Hausdorff distance functional data objects. Hausdorff distance treats curve set points (t, f(t)) 2D space computes maximum minimum distances.","code":""},{"path":"https://sipemu.github.io/fdars/reference/metric.hausdorff.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hausdorff Metric for Functional Data ‚Äî metric.hausdorff","text":"","code":"metric.hausdorff(fdata1, fdata2 = NULL, ...)"},{"path":"https://sipemu.github.io/fdars/reference/metric.hausdorff.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hausdorff Metric for Functional Data ‚Äî metric.hausdorff","text":"fdata1 object class 'fdata'. fdata2 object class 'fdata'. NULL, uses fdata1. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/metric.hausdorff.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hausdorff Metric for Functional Data ‚Äî metric.hausdorff","text":"distance matrix.","code":""},{"path":"https://sipemu.github.io/fdars/reference/metric.hausdorff.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hausdorff Metric for Functional Data ‚Äî metric.hausdorff","text":"","code":"fd <- fdata(matrix(rnorm(100), 10, 10)) D <- metric.hausdorff(fd)"},{"path":"https://sipemu.github.io/fdars/reference/metric.html","id":null,"dir":"Reference","previous_headings":"","what":"Distance Metrics for Functional Data ‚Äî metric","title":"Distance Metrics for Functional Data ‚Äî metric","text":"Functions computing various distance metrics functional data. Compute Distance Metric Functional Data","code":""},{"path":"https://sipemu.github.io/fdars/reference/metric.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Distance Metrics for Functional Data ‚Äî metric","text":"","code":"metric(fdata1, fdata2 = NULL, method = \"lp\", ...)"},{"path":"https://sipemu.github.io/fdars/reference/metric.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Distance Metrics for Functional Data ‚Äî metric","text":"fdata1 object class 'fdata'. fdata2 object class 'fdata'. NULL, computes self-distances. method Distance method use. One : \"lp\" - Lp metric (default) \"hausdorff\" - Hausdorff distance \"dtw\" - Dynamic Time Warping \"pca\" - Semi-metric based PCA scores \"deriv\" - Semi-metric based derivatives \"basis\" - Semi-metric based basis coefficients \"fourier\" - Semi-metric based FFT coefficients \"hshift\" - Semi-metric horizontal shift \"kl\" - Symmetric Kullback-Leibler divergence ... Additional arguments passed specific distance function.","code":""},{"path":"https://sipemu.github.io/fdars/reference/metric.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Distance Metrics for Functional Data ‚Äî metric","text":"distance matrix.","code":""},{"path":"https://sipemu.github.io/fdars/reference/metric.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Distance Metrics for Functional Data ‚Äî metric","text":"Unified interface computing various distance metrics functional data objects. function dispatches appropriate specialized distance function based method parameter. function provides convenient unified interface distance computations fdars. additional arguments ... passed underlying distance function: lp: lp, w hausdorff: (none) dtw: p, w pca: ncomp deriv: nderiv, lp basis: nbasis, basis, nderiv fourier: nfreq hshift: max_shift kl: eps, normalize","code":""},{"path":"https://sipemu.github.io/fdars/reference/metric.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Distance Metrics for Functional Data ‚Äî metric","text":"","code":"fd <- fdata(matrix(rnorm(200), 20, 10))  # Using different distance methods D_lp <- metric(fd, method = \"lp\") D_hausdorff <- metric(fd, method = \"hausdorff\") D_pca <- metric(fd, method = \"pca\", ncomp = 3)  # Cross-distances fd2 <- fdata(matrix(rnorm(100), 10, 10)) D_cross <- metric(fd, fd2, method = \"lp\")"},{"path":"https://sipemu.github.io/fdars/reference/metric.kl.html","id":null,"dir":"Reference","previous_headings":"","what":"Kullback-Leibler Divergence Metric for Functional Data ‚Äî metric.kl","title":"Kullback-Leibler Divergence Metric for Functional Data ‚Äî metric.kl","text":"Computes symmetric Kullback-Leibler divergence functional data treated probability distributions. Curves first normalized valid probability density functions.","code":""},{"path":"https://sipemu.github.io/fdars/reference/metric.kl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Kullback-Leibler Divergence Metric for Functional Data ‚Äî metric.kl","text":"","code":"metric.kl(fdata1, fdata2 = NULL, eps = 1e-10, normalize = TRUE, ...)"},{"path":"https://sipemu.github.io/fdars/reference/metric.kl.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Kullback-Leibler Divergence Metric for Functional Data ‚Äî metric.kl","text":"fdata1 object class 'fdata'. fdata2 object class 'fdata'. NULL, computes self-distances. eps Small value numerical stability (default 1e-10). normalize Logical. TRUE (default), curves shifted non-negative normalized integrate 1. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/metric.kl.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Kullback-Leibler Divergence Metric for Functional Data ‚Äî metric.kl","text":"distance matrix based symmetric KL divergence.","code":""},{"path":"https://sipemu.github.io/fdars/reference/metric.kl.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Kullback-Leibler Divergence Metric for Functional Data ‚Äî metric.kl","text":"symmetric KL divergence computed : $$D_{KL}(f, g) = \\frac{1}{2}[KL(f||g) + KL(g||f)]$$ $$KL(f||g) = \\int f(t) \\log\\frac{f(t)}{g(t)} dt$$ normalize = TRUE, curves first shifted non-negative (subtracting minimum adding eps), normalized integrate 1. makes valid probability density functions. symmetric KL divergence always non-negative equals zero two distributions identical. However, satisfy triangle inequality.","code":""},{"path":"https://sipemu.github.io/fdars/reference/metric.kl.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Kullback-Leibler Divergence Metric for Functional Data ‚Äî metric.kl","text":"","code":"# Create curves that look like probability densities t <- seq(0, 1, length.out = 100) X <- matrix(0, 10, 100) for (i in 1:10) {   # Shifted Gaussian-like curves   X[i, ] <- exp(-(t - 0.3 - i/50)^2 / 0.02) + rnorm(100, sd = 0.01) } fd <- fdata(X, argvals = t)  # Compute KL divergence D <- metric.kl(fd)"},{"path":"https://sipemu.github.io/fdars/reference/metric.lp.html","id":null,"dir":"Reference","previous_headings":"","what":"Lp Metric for Functional Data ‚Äî metric.lp","title":"Lp Metric for Functional Data ‚Äî metric.lp","text":"Computes Lp distance functional data objects using numerical integration (Simpson's rule).","code":""},{"path":"https://sipemu.github.io/fdars/reference/metric.lp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Lp Metric for Functional Data ‚Äî metric.lp","text":"","code":"metric.lp(fdata1, fdata2 = NULL, lp = 2, w = 1, ...)"},{"path":"https://sipemu.github.io/fdars/reference/metric.lp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Lp Metric for Functional Data ‚Äî metric.lp","text":"fdata1 object class 'fdata'. fdata2 object class 'fdata'. NULL, computes self-distances fdata1 (efficient symmetric computation). lp p Lp metric. Default 2 (L2 distance). w Optional weight vector length equal number evaluation points. Default uniform weighting. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/metric.lp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Lp Metric for Functional Data ‚Äî metric.lp","text":"distance matrix dimensions n1 x n2 (n x n fdata2 NULL).","code":""},{"path":"https://sipemu.github.io/fdars/reference/metric.lp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Lp Metric for Functional Data ‚Äî metric.lp","text":"","code":"fd <- fdata(matrix(rnorm(100), 10, 10)) D <- metric.lp(fd)  # Self-distances  fd2 <- fdata(matrix(rnorm(50), 5, 10)) D2 <- metric.lp(fd, fd2)  # Cross-distances"},{"path":"https://sipemu.github.io/fdars/reference/norm.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Lp norm of functional data ‚Äî norm","title":"Compute Lp norm of functional data ‚Äî norm","text":"Compute Lp norm functional data","code":""},{"path":"https://sipemu.github.io/fdars/reference/norm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Lp norm of functional data ‚Äî norm","text":"","code":"norm(fdataobj, lp = 2)"},{"path":"https://sipemu.github.io/fdars/reference/norm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Lp norm of functional data ‚Äî norm","text":"fdataobj object class 'fdata'. lp p Lp norm (default 2 L2 norm).","code":""},{"path":"https://sipemu.github.io/fdars/reference/norm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Lp norm of functional data ‚Äî norm","text":"numeric vector norms, one per curve.","code":""},{"path":"https://sipemu.github.io/fdars/reference/norm.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Lp norm of functional data ‚Äî norm","text":"","code":"fd <- fdata(matrix(rnorm(100), 10, 10)) norms <- norm(fd)"},{"path":"https://sipemu.github.io/fdars/reference/normalize.html","id":null,"dir":"Reference","previous_headings":"","what":"Normalize functional data ‚Äî normalize","title":"Normalize functional data ‚Äî normalize","text":"Scales curve Lp norm equal 1.","code":""},{"path":"https://sipemu.github.io/fdars/reference/normalize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Normalize functional data ‚Äî normalize","text":"","code":"normalize(fdataobj, lp = 2)"},{"path":"https://sipemu.github.io/fdars/reference/normalize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Normalize functional data ‚Äî normalize","text":"fdataobj object class 'fdata'. lp p Lp norm (default 2 L2 norm).","code":""},{"path":"https://sipemu.github.io/fdars/reference/normalize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Normalize functional data ‚Äî normalize","text":"normalized 'fdata' object curve unit norm.","code":""},{"path":"https://sipemu.github.io/fdars/reference/normalize.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Normalize functional data ‚Äî normalize","text":"","code":"fd <- fdata(matrix(rnorm(100), 10, 10), argvals = seq(0, 1, length.out = 10)) fd_norm <- normalize(fd) norm(fd_norm)  # All values should be 1 #>  [1] 1 1 1 1 1 1 1 1 1 1"},{"path":"https://sipemu.github.io/fdars/reference/optim.np.html","id":null,"dir":"Reference","previous_headings":"","what":"Optimize Bandwidth Using Cross-Validation ‚Äî optim.np","title":"Optimize Bandwidth Using Cross-Validation ‚Äî optim.np","text":"Find optimal bandwidth minimizing CV GCV criterion.","code":""},{"path":"https://sipemu.github.io/fdars/reference/optim.np.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Optimize Bandwidth Using Cross-Validation ‚Äî optim.np","text":"","code":"optim.np(   fdataobj,   S.type,   h.range = NULL,   criterion = \"GCV\",   Ker = \"norm\",   ... )"},{"path":"https://sipemu.github.io/fdars/reference/optim.np.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Optimize Bandwidth Using Cross-Validation ‚Äî optim.np","text":"fdataobj fdata object. S.type Smoother function (S.NW, S.LLR, etc.). h.range Range bandwidths search (default: data-driven). criterion \"CV\" \"GCV\". Ker Kernel type. ... Additional arguments passed optimizer.","code":""},{"path":"https://sipemu.github.io/fdars/reference/optim.np.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Optimize Bandwidth Using Cross-Validation ‚Äî optim.np","text":"list optimal bandwidth CV/GCV score.","code":""},{"path":"https://sipemu.github.io/fdars/reference/optim.np.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Optimize Bandwidth Using Cross-Validation ‚Äî optim.np","text":"","code":"tt <- seq(0, 1, length.out = 50) y <- sin(2 * pi * tt) + rnorm(50, sd = 0.1) fd <- fdata(matrix(y, nrow = 1), argvals = tt) result <- optim.np(fd, S.NW)"},{"path":"https://sipemu.github.io/fdars/reference/outliergram.html","id":null,"dir":"Reference","previous_headings":"","what":"Outliergram for Functional Data ‚Äî outliergram","title":"Outliergram for Functional Data ‚Äî outliergram","text":"Creates outliergram plot displays MEI (Modified Epigraph Index) versus MBD (Modified Band Depth) outlier detection. Points parabolic boundary identified outliers, outlier classified type.","code":""},{"path":"https://sipemu.github.io/fdars/reference/outliergram.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Outliergram for Functional Data ‚Äî outliergram","text":"","code":"outliergram(fdataobj, factor = 1.5, mei_threshold = 0.25, ...)"},{"path":"https://sipemu.github.io/fdars/reference/outliergram.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Outliergram for Functional Data ‚Äî outliergram","text":"fdataobj object class 'fdata'. factor Factor adjust outlier detection threshold. Higher values make detection less sensitive. Default 1.5. mei_threshold Threshold classifying magnitude outliers based MEI. Curves MEI < mei_threshold MEI > (1 - mei_threshold) considered extreme magnitude. Default 0.25. ... Additional arguments (currently ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/outliergram.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Outliergram for Functional Data ‚Äî outliergram","text":"object class 'outliergram' components: fdataobj input functional data mei MEI values curve mbd MBD values curve outliers Indices detected outliers outlier_type Character vector outlier types detected outlier: \"shape\", \"magnitude_high\", \"magnitude_low\", \"mixed\" n_outliers Number outliers detected factor factor used threshold adjustment parabola Coefficients parabolic boundary (a0, a1, a2)","code":""},{"path":"https://sipemu.github.io/fdars/reference/outliergram.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Outliergram for Functional Data ‚Äî outliergram","text":"outliergram plots MEI x-axis versus MBD y-axis. standard functional data, values lie near parabola. theoretical relationship uniformly distributed data : $$MBD = a_0 + a_1 \\cdot MEI + a_2 \\cdot MEI^2$$ Points fall significantly parabola identified outliers. factor parameter controls sensitivity: lower values detect outliers. Outlier Type Classification: shape: Curves unusual shape typical magnitude (moderate MEI, low MBD). curves cross curves frequently. magnitude_high: Curves shifted upward (high MEI, typically curves). magnitude_low: Curves shifted downward (low MEI, typically curves). mixed: Curves unusual shape extreme magnitude (extreme MEI low MBD).","code":""},{"path":"https://sipemu.github.io/fdars/reference/outliergram.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Outliergram for Functional Data ‚Äî outliergram","text":"Arribas-Gil, . Romo, J. (2014). Shape outlier detection visualization functional data: outliergram. Biostatistics, 15(4), 603-619.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/reference/outliergram.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Outliergram for Functional Data ‚Äî outliergram","text":"","code":"# Create functional data with different outlier types set.seed(42) t <- seq(0, 1, length.out = 50) X <- matrix(0, 32, 50) for (i in 1:29) X[i, ] <- sin(2 * pi * t) + rnorm(50, sd = 0.2) X[30, ] <- sin(2 * pi * t) + 2       # magnitude outlier (high) X[31, ] <- sin(2 * pi * t) - 2       # magnitude outlier (low) X[32, ] <- sin(4 * pi * t)           # shape outlier fd <- fdata(X, argvals = t)  # Create outliergram og <- outliergram(fd) print(og) #> Outliergram #> =========== #> Number of curves: 32  #> Outliers detected: 6  #>  #> Outlier types: #>   Shape:           4  #>   Magnitude (high): 1  #>   Magnitude (low):  1  #>  #> Outlier details: #>   Index 11 : shape  #>   Index 19 : shape  #>   Index 20 : shape  #>   Index 30 : magnitude_high  #>   Index 31 : magnitude_low  #>   Index 32 : shape  #>  #> Parameters: #>   Factor: 1.5  #>   MEI threshold: 0.25  plot(og, color_by_type = TRUE)"},{"path":"https://sipemu.github.io/fdars/reference/outliers.boxplot.html","id":null,"dir":"Reference","previous_headings":"","what":"Outlier Detection using Functional Boxplot ‚Äî outliers.boxplot","title":"Outlier Detection using Functional Boxplot ‚Äî outliers.boxplot","text":"Detects outliers based functional boxplot method. Curves exceed fence (1.5 times central envelope width) point flagged outliers.","code":""},{"path":"https://sipemu.github.io/fdars/reference/outliers.boxplot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Outlier Detection using Functional Boxplot ‚Äî outliers.boxplot","text":"","code":"outliers.boxplot(   fdataobj,   prob = 0.5,   factor = 1.5,   depth.func = depth.MBD,   ... )"},{"path":"https://sipemu.github.io/fdars/reference/outliers.boxplot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Outlier Detection using Functional Boxplot ‚Äî outliers.boxplot","text":"fdataobj object class 'fdata'. prob Proportion curves central region (default 0.5). factor Factor fence calculation (default 1.5). depth.func Depth function use. Default depth.MBD. ... Additional arguments passed depth function.","code":""},{"path":"https://sipemu.github.io/fdars/reference/outliers.boxplot.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Outlier Detection using Functional Boxplot ‚Äî outliers.boxplot","text":"list class 'outliers.fdata' components: outliers Indices detected outliers depths Depth values curves cutoff used (compatibility) fdataobj Original fdata object","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/reference/outliers.boxplot.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Outlier Detection using Functional Boxplot ‚Äî outliers.boxplot","text":"","code":"# Create functional data with outliers set.seed(42) t <- seq(0, 1, length.out = 50) X <- matrix(0, 30, 50) for (i in 1:28) X[i, ] <- sin(2*pi*t) + rnorm(50, sd = 0.2) X[29, ] <- sin(2*pi*t) + 2  # Magnitude outlier X[30, ] <- cos(2*pi*t)       # Shape outlier fd <- fdata(X, argvals = t)  # Detect outliers out <- outliers.boxplot(fd) print(out) #> Functional data outlier detection #>   Number of observations: 30  #>   Number of outliers: 2  #>   Outlier indices: 29 30 #>   Depth cutoff: NA"},{"path":"https://sipemu.github.io/fdars/reference/outliers.depth.pond.html","id":null,"dir":"Reference","previous_headings":"","what":"Outlier Detection for Functional Data ‚Äî outliers.depth.pond","title":"Outlier Detection for Functional Data ‚Äî outliers.depth.pond","text":"Functions detecting outliers functional data using depth measures. Outlier Detection using Weighted Depth","code":""},{"path":"https://sipemu.github.io/fdars/reference/outliers.depth.pond.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Outlier Detection for Functional Data ‚Äî outliers.depth.pond","text":"","code":"outliers.depth.pond(fdataobj, nb = 200, dfunc = depth.mode, quan = 0.5, ...)"},{"path":"https://sipemu.github.io/fdars/reference/outliers.depth.pond.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Outlier Detection for Functional Data ‚Äî outliers.depth.pond","text":"fdataobj object class 'fdata'. nb Number bootstrap samples. Default 200. dfunc Depth function use. Default depth.mode. quan Quantile outlier cutoff. Default 0.5. ... Additional arguments passed depth function.","code":""},{"path":"https://sipemu.github.io/fdars/reference/outliers.depth.pond.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Outlier Detection for Functional Data ‚Äî outliers.depth.pond","text":"list class 'outliers.fdata' components: outliers Indices detected outliers depths Depth values curves cutoff Depth cutoff used","code":""},{"path":"https://sipemu.github.io/fdars/reference/outliers.depth.pond.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Outlier Detection for Functional Data ‚Äî outliers.depth.pond","text":"Detects outliers based depth bootstrap resampling.","code":""},{"path":"https://sipemu.github.io/fdars/reference/outliers.depth.pond.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Outlier Detection for Functional Data ‚Äî outliers.depth.pond","text":"","code":"fd <- fdata(matrix(rnorm(200), 20, 10)) out <- outliers.depth.pond(fd, nb = 50)"},{"path":"https://sipemu.github.io/fdars/reference/outliers.depth.trim.html","id":null,"dir":"Reference","previous_headings":"","what":"Outlier Detection using Trimmed Depth ‚Äî outliers.depth.trim","title":"Outlier Detection using Trimmed Depth ‚Äî outliers.depth.trim","text":"Detects outliers based depth trimming.","code":""},{"path":"https://sipemu.github.io/fdars/reference/outliers.depth.trim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Outlier Detection using Trimmed Depth ‚Äî outliers.depth.trim","text":"","code":"outliers.depth.trim(fdataobj, trim = 0.1, dfunc = depth.mode, ...)"},{"path":"https://sipemu.github.io/fdars/reference/outliers.depth.trim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Outlier Detection using Trimmed Depth ‚Äî outliers.depth.trim","text":"fdataobj object class 'fdata'. trim Proportion curves consider potential outliers. Default 0.1 (curves depth bottom 10%). dfunc Depth function use. Default depth.mode. ... Additional arguments passed depth function.","code":""},{"path":"https://sipemu.github.io/fdars/reference/outliers.depth.trim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Outlier Detection using Trimmed Depth ‚Äî outliers.depth.trim","text":"list class 'outliers.fdata' components: outliers Indices detected outliers depths Depth values curves cutoff Depth cutoff used","code":""},{"path":"https://sipemu.github.io/fdars/reference/outliers.depth.trim.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Outlier Detection using Trimmed Depth ‚Äî outliers.depth.trim","text":"","code":"fd <- fdata(matrix(rnorm(200), 20, 10)) out <- outliers.depth.trim(fd, trim = 0.1)"},{"path":"https://sipemu.github.io/fdars/reference/outliers.lrt.html","id":null,"dir":"Reference","previous_headings":"","what":"LRT-based Outlier Detection for Functional Data ‚Äî outliers.lrt","title":"LRT-based Outlier Detection for Functional Data ‚Äî outliers.lrt","text":"Detects outliers using Likelihood Ratio Test approach based Febrero-Bande et al. Uses bootstrap estimate threshold iteratively removes curves exceeding threshold. Implemented Rust high performance parallelized bootstrap.","code":""},{"path":"https://sipemu.github.io/fdars/reference/outliers.lrt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LRT-based Outlier Detection for Functional Data ‚Äî outliers.lrt","text":"","code":"outliers.lrt(fdataobj, nb = 200, smo = 0.05, trim = 0.1, seed = NULL)"},{"path":"https://sipemu.github.io/fdars/reference/outliers.lrt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LRT-based Outlier Detection for Functional Data ‚Äî outliers.lrt","text":"fdataobj object class 'fdata'. nb Number bootstrap replications threshold estimation (default 200). smo Smoothing parameter bootstrap noise (default 0.05). trim Proportion curves trim robust estimation (default 0.1). seed Random seed reproducibility.","code":""},{"path":"https://sipemu.github.io/fdars/reference/outliers.lrt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"LRT-based Outlier Detection for Functional Data ‚Äî outliers.lrt","text":"list class 'outliers.fdata' components: outliers Indices detected outliers distances Normalized distances curves threshold Bootstrap threshold used fdataobj Original fdata object","code":""},{"path":"https://sipemu.github.io/fdars/reference/outliers.lrt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"LRT-based Outlier Detection for Functional Data ‚Äî outliers.lrt","text":"","code":"t <- seq(0, 1, length.out = 50) X <- matrix(0, 30, 50) for (i in 1:30) X[i, ] <- sin(2*pi*t) + rnorm(50, sd = 0.1) # Add an outlier X[1, ] <- X[1, ] + 3 fd <- fdata(X, argvals = t) out <- outliers.lrt(fd, nb = 100)"},{"path":"https://sipemu.github.io/fdars/reference/outliers.thres.lrt.html","id":null,"dir":"Reference","previous_headings":"","what":"LRT Outlier Detection Threshold ‚Äî outliers.thres.lrt","title":"LRT Outlier Detection Threshold ‚Äî outliers.thres.lrt","text":"Computes bootstrap threshold LRT-based outlier detection. highly parallelized Rust implementation providing significant speedup pure R implementations.","code":""},{"path":"https://sipemu.github.io/fdars/reference/outliers.thres.lrt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"LRT Outlier Detection Threshold ‚Äî outliers.thres.lrt","text":"","code":"outliers.thres.lrt(fdataobj, nb = 200, smo = 0.05, trim = 0.1, seed = NULL)"},{"path":"https://sipemu.github.io/fdars/reference/outliers.thres.lrt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"LRT Outlier Detection Threshold ‚Äî outliers.thres.lrt","text":"fdataobj object class 'fdata'. nb Number bootstrap replications (default 200). smo Smoothing parameter bootstrap noise (default 0.05). trim Proportion curves trim robust estimation (default 0.1). seed Random seed reproducibility.","code":""},{"path":"https://sipemu.github.io/fdars/reference/outliers.thres.lrt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"LRT Outlier Detection Threshold ‚Äî outliers.thres.lrt","text":"99th percentile threshold value.","code":""},{"path":"https://sipemu.github.io/fdars/reference/outliers.thres.lrt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"LRT Outlier Detection Threshold ‚Äî outliers.thres.lrt","text":"","code":"t <- seq(0, 1, length.out = 50) X <- matrix(0, 30, 50) for (i in 1:30) X[i, ] <- sin(2*pi*t) + rnorm(50, sd = 0.1) fd <- fdata(X, argvals = t) thresh <- outliers.thres.lrt(fd, nb = 100)"},{"path":"https://sipemu.github.io/fdars/reference/plot.basis.cv.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for basis.cv objects ‚Äî plot.basis.cv","title":"Plot method for basis.cv objects ‚Äî plot.basis.cv","text":"Plot method basis.cv objects","code":""},{"path":"https://sipemu.github.io/fdars/reference/plot.basis.cv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for basis.cv objects ‚Äî plot.basis.cv","text":"","code":"# S3 method for class 'basis.cv' plot(x, ...)"},{"path":"https://sipemu.github.io/fdars/reference/plot.basis.cv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for basis.cv objects ‚Äî plot.basis.cv","text":"x basis.cv object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/plot.cluster.fcm.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Method for cluster.fcm Objects ‚Äî plot.cluster.fcm","title":"Plot Method for cluster.fcm Objects ‚Äî plot.cluster.fcm","text":"Plot Method cluster.fcm Objects","code":""},{"path":"https://sipemu.github.io/fdars/reference/plot.cluster.fcm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Method for cluster.fcm Objects ‚Äî plot.cluster.fcm","text":"","code":"# S3 method for class 'cluster.fcm' plot(x, type = c(\"curves\", \"membership\"), ...)"},{"path":"https://sipemu.github.io/fdars/reference/plot.cluster.fcm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Method for cluster.fcm Objects ‚Äî plot.cluster.fcm","text":"x object class 'cluster.fcm'. type Type plot: \"curves\" (default) \"membership\". ... Additional arguments (currently ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/plot.cluster.fcm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Method for cluster.fcm Objects ‚Äî plot.cluster.fcm","text":"ggplot object.","code":""},{"path":"https://sipemu.github.io/fdars/reference/plot.cluster.kmeans.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Method for cluster.kmeans Objects ‚Äî plot.cluster.kmeans","title":"Plot Method for cluster.kmeans Objects ‚Äî plot.cluster.kmeans","text":"Plot Method cluster.kmeans Objects","code":""},{"path":"https://sipemu.github.io/fdars/reference/plot.cluster.kmeans.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Method for cluster.kmeans Objects ‚Äî plot.cluster.kmeans","text":"","code":"# S3 method for class 'cluster.kmeans' plot(x, ...)"},{"path":"https://sipemu.github.io/fdars/reference/plot.cluster.kmeans.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Method for cluster.kmeans Objects ‚Äî plot.cluster.kmeans","text":"x object class 'cluster.kmeans'. ... Additional arguments (currently ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/plot.cluster.kmeans.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Method for cluster.kmeans Objects ‚Äî plot.cluster.kmeans","text":"ggplot object.","code":""},{"path":"https://sipemu.github.io/fdars/reference/plot.cluster.optim.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Method for cluster.optim Objects ‚Äî plot.cluster.optim","title":"Plot Method for cluster.optim Objects ‚Äî plot.cluster.optim","text":"Plot Method cluster.optim Objects","code":""},{"path":"https://sipemu.github.io/fdars/reference/plot.cluster.optim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Method for cluster.optim Objects ‚Äî plot.cluster.optim","text":"","code":"# S3 method for class 'cluster.optim' plot(x, ...)"},{"path":"https://sipemu.github.io/fdars/reference/plot.cluster.optim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Method for cluster.optim Objects ‚Äî plot.cluster.optim","text":"x object class 'cluster.optim'. ... Additional arguments (currently ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/plot.cluster.optim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Method for cluster.optim Objects ‚Äî plot.cluster.optim","text":"ggplot object.","code":""},{"path":"https://sipemu.github.io/fdars/reference/plot.fdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for fdata objects ‚Äî plot.fdata","title":"Plot method for fdata objects ‚Äî plot.fdata","text":"Displays plot functional data. 1D functional data, plots curves lines optional coloring. 2D functional data, plots surfaces heatmaps contour lines.","code":""},{"path":"https://sipemu.github.io/fdars/reference/plot.fdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for fdata objects ‚Äî plot.fdata","text":"","code":"# S3 method for class 'fdata' plot(   x,   color = NULL,   alpha = NULL,   show.mean = FALSE,   show.ci = FALSE,   ci.level = 0.9,   palette = NULL,   ... )"},{"path":"https://sipemu.github.io/fdars/reference/plot.fdata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for fdata objects ‚Äî plot.fdata","text":"x object class 'fdata'. color Optional vector coloring curves. Can : Numeric vector: curves colored continuous scale (viridis) Factor/character: curves colored discrete groups Must length equal number curves. alpha Transparency individual curve lines. Default 0.7 basic plots, automatically reduced 0.3 show.mean = TRUE show.ci = TRUE reduce visual clutter allow mean curves stand . Can explicitly set override default. show.mean Logical. TRUE color categorical, overlay group mean curves thicker lines (default FALSE). show.ci Logical. TRUE color categorical, show pointwise confidence interval ribbons per group (default FALSE). ci.level Confidence level CI ribbons (default 0.90 90 percent). palette Optional named vector colors categorical coloring, e.g., c(\"\" = \"blue\", \"B\" = \"red\"). ... Additional arguments (currently ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/plot.fdata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot method for fdata objects ‚Äî plot.fdata","text":"ggplot object (invisibly).","code":""},{"path":"https://sipemu.github.io/fdars/reference/plot.fdata.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot method for fdata objects ‚Äî plot.fdata","text":"function displays plot immediately. get ggplot object without displaying (e.g., customization), use autoplot.fdata.","code":""},{"path":"https://sipemu.github.io/fdars/reference/plot.fdata.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot method for fdata objects ‚Äî plot.fdata","text":"","code":"# Display plot immediately fd <- fdata(matrix(rnorm(200), 20, 10)) plot(fd)   # To get ggplot object without displaying, use autoplot: p <- autoplot(fd) #> Error in autoplot(fd): could not find function \"autoplot\""},{"path":"https://sipemu.github.io/fdars/reference/plot.fdata2pc.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot FPCA Results ‚Äî plot.fdata2pc","title":"Plot FPCA Results ‚Äî plot.fdata2pc","text":"Visualize functional principal component analysis results multiple plot types: component perturbation plots, variance explained (scree plot), score plots.","code":""},{"path":"https://sipemu.github.io/fdars/reference/plot.fdata2pc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot FPCA Results ‚Äî plot.fdata2pc","text":"","code":"# S3 method for class 'fdata2pc' plot(   x,   type = c(\"components\", \"variance\", \"scores\"),   ncomp = 3,   multiple = 2,   ... )"},{"path":"https://sipemu.github.io/fdars/reference/plot.fdata2pc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot FPCA Results ‚Äî plot.fdata2pc","text":"x object class 'fdata2pc' fdata2pc. type Type plot: \"components\" (default) shows mean +/- scaled PC loadings, \"variance\" shows scree plot variance explained, \"scores\" shows PC1 vs PC2 scatter plot observations. ncomp Number components display (default 3 fewer available). multiple Factor scaling PC perturbations. Default 2 (shows +/- 2*sqrt(eigenvalue)*PC). ... Additional arguments passed plotting functions.","code":""},{"path":"https://sipemu.github.io/fdars/reference/plot.fdata2pc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot FPCA Results ‚Äî plot.fdata2pc","text":"ggplot object (invisibly).","code":""},{"path":"https://sipemu.github.io/fdars/reference/plot.fdata2pc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot FPCA Results ‚Äî plot.fdata2pc","text":"\"components\" plot shows mean function (black) perturbations direction principal component. perturbation computed : mean +/- multiple * sqrt(variance_explained) * PC_loading \"variance\" plot shows scree plot proportion variance explained component bar chart. \"scores\" plot shows scatter plot observations PC space, typically PC1 vs PC2.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/reference/plot.fdata2pc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot FPCA Results ‚Äî plot.fdata2pc","text":"","code":"t <- seq(0, 1, length.out = 50) X <- matrix(0, 30, 50) for (i in 1:30) X[i, ] <- sin(2*pi*t + runif(1, 0, pi)) + rnorm(50, sd = 0.1) fd <- fdata(X, argvals = t) pc <- fdata2pc(fd, ncomp = 3)  # Plot PC components (mean +/- perturbations) plot(pc, type = \"components\")   # Scree plot plot(pc, type = \"variance\")   # Score plot plot(pc, type = \"scores\")"},{"path":"https://sipemu.github.io/fdars/reference/plot.group.distance.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for group.distance ‚Äî plot.group.distance","title":"Plot method for group.distance ‚Äî plot.group.distance","text":"Plot method group.distance","code":""},{"path":"https://sipemu.github.io/fdars/reference/plot.group.distance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for group.distance ‚Äî plot.group.distance","text":"","code":"# S3 method for class 'group.distance' plot(x, type = c(\"heatmap\", \"dendrogram\"), which = NULL, ...)"},{"path":"https://sipemu.github.io/fdars/reference/plot.group.distance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for group.distance ‚Äî plot.group.distance","text":"x object class 'group.distance'. type Plot type: \"heatmap\" \"dendrogram\". distance matrix plot. NULL (default), uses first available matrix group.distance object. ... Additional arguments.","code":""},{"path":"https://sipemu.github.io/fdars/reference/plot.group.distance.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot method for group.distance ‚Äî plot.group.distance","text":"ggplot object (heatmap) NULL (dendrogram, uses base graphics).","code":""},{"path":"https://sipemu.github.io/fdars/reference/plot.magnitudeshape.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Method for magnitudeshape Objects ‚Äî plot.magnitudeshape","title":"Plot Method for magnitudeshape Objects ‚Äî plot.magnitudeshape","text":"Plot Method magnitudeshape Objects","code":""},{"path":"https://sipemu.github.io/fdars/reference/plot.magnitudeshape.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Method for magnitudeshape Objects ‚Äî plot.magnitudeshape","text":"","code":"# S3 method for class 'magnitudeshape' plot(x, ...)"},{"path":"https://sipemu.github.io/fdars/reference/plot.magnitudeshape.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Method for magnitudeshape Objects ‚Äî plot.magnitudeshape","text":"x object class 'magnitudeshape'. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/plot.magnitudeshape.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Method for magnitudeshape Objects ‚Äî plot.magnitudeshape","text":"ggplot object (invisibly).","code":""},{"path":"https://sipemu.github.io/fdars/reference/plot.outliergram.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Method for Outliergram Objects ‚Äî plot.outliergram","title":"Plot Method for Outliergram Objects ‚Äî plot.outliergram","text":"Creates scatter plot MEI vs MBD parabolic boundary identified outliers highlighted.","code":""},{"path":"https://sipemu.github.io/fdars/reference/plot.outliergram.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Method for Outliergram Objects ‚Äî plot.outliergram","text":"","code":"# S3 method for class 'outliergram' plot(   x,   col_normal = \"gray60\",   col_outlier = \"red\",   color_by_type = FALSE,   show_parabola = TRUE,   show_threshold = TRUE,   label = \"index\",   label_all = FALSE,   ... )"},{"path":"https://sipemu.github.io/fdars/reference/plot.outliergram.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Method for Outliergram Objects ‚Äî plot.outliergram","text":"x object class 'outliergram'. col_normal Color normal observations. Default \"gray60\". col_outlier Color outliers (used color_by_type = FALSE). Default \"red\". color_by_type Logical. TRUE, color outliers type (shape, magnitude_high, magnitude_low, mixed). Default FALSE. show_parabola Logical. TRUE, draw theoretical parabola. Default TRUE. show_threshold Logical. TRUE, draw adjusted threshold parabola. Default TRUE. label use labeling outlier points. Options: \"index\": Use numeric indices (default) \"id\": Use observation IDs fdata object column name fdata metadata (e.g., \"patient_id\") label_all Logical. TRUE, label points, just outliers. Default FALSE. ... Additional arguments passed plotting functions.","code":""},{"path":"https://sipemu.github.io/fdars/reference/plot.outliers.fdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for outliers.fdata objects ‚Äî plot.outliers.fdata","title":"Plot method for outliers.fdata objects ‚Äî plot.outliers.fdata","text":"Plot method outliers.fdata objects","code":""},{"path":"https://sipemu.github.io/fdars/reference/plot.outliers.fdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for outliers.fdata objects ‚Äî plot.outliers.fdata","text":"","code":"# S3 method for class 'outliers.fdata' plot(x, col.outliers = \"red\", ...)"},{"path":"https://sipemu.github.io/fdars/reference/plot.outliers.fdata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for outliers.fdata objects ‚Äî plot.outliers.fdata","text":"x object class 'outliers.fdata'. col.outliers Color outlier curves (default \"red\"). ... Additional arguments (currently ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/plot.outliers.fdata.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot method for outliers.fdata objects ‚Äî plot.outliers.fdata","text":"ggplot object.","code":""},{"path":"https://sipemu.github.io/fdars/reference/plot.pspline.2d.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for pspline.2d objects ‚Äî plot.pspline.2d","title":"Plot method for pspline.2d objects ‚Äî plot.pspline.2d","text":"Plot method pspline.2d objects","code":""},{"path":"https://sipemu.github.io/fdars/reference/plot.pspline.2d.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for pspline.2d objects ‚Äî plot.pspline.2d","text":"","code":"# S3 method for class 'pspline.2d' plot(x, ...)"},{"path":"https://sipemu.github.io/fdars/reference/plot.pspline.2d.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for pspline.2d objects ‚Äî plot.pspline.2d","text":"x pspline.2d object. ... Additional arguments passed plot.fdata.","code":""},{"path":"https://sipemu.github.io/fdars/reference/plot.pspline.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot method for pspline objects ‚Äî plot.pspline","title":"Plot method for pspline objects ‚Äî plot.pspline","text":"Plot method pspline objects","code":""},{"path":"https://sipemu.github.io/fdars/reference/plot.pspline.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot method for pspline objects ‚Äî plot.pspline","text":"","code":"# S3 method for class 'pspline' plot(x, ...)"},{"path":"https://sipemu.github.io/fdars/reference/plot.pspline.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot method for pspline objects ‚Äî plot.pspline","text":"x pspline object. ... Additional arguments passed plot.fdata.","code":""},{"path":"https://sipemu.github.io/fdars/reference/plot.register.fd.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot Method for register.fd Objects ‚Äî plot.register.fd","title":"Plot Method for register.fd Objects ‚Äî plot.register.fd","text":"Plot Method register.fd Objects","code":""},{"path":"https://sipemu.github.io/fdars/reference/plot.register.fd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot Method for register.fd Objects ‚Äî plot.register.fd","text":"","code":"# S3 method for class 'register.fd' plot(x, type = c(\"registered\", \"original\", \"both\"), ...)"},{"path":"https://sipemu.github.io/fdars/reference/plot.register.fd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot Method for register.fd Objects ‚Äî plot.register.fd","text":"x object class 'register.fd'. type Type plot: \"registered\" (default), \"original\", \"\". ... Additional arguments (currently ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/plot.register.fd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot Method for register.fd Objects ‚Äî plot.register.fd","text":"ggplot object.","code":""},{"path":"https://sipemu.github.io/fdars/reference/pred.MAE.html","id":null,"dir":"Reference","previous_headings":"","what":"Mean Absolute Error ‚Äî pred.MAE","title":"Mean Absolute Error ‚Äî pred.MAE","text":"Compute Mean Absolute Error predicted actual values.","code":""},{"path":"https://sipemu.github.io/fdars/reference/pred.MAE.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mean Absolute Error ‚Äî pred.MAE","text":"","code":"pred.MAE(y_true, y_pred)"},{"path":"https://sipemu.github.io/fdars/reference/pred.MAE.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mean Absolute Error ‚Äî pred.MAE","text":"y_true Actual values. y_pred Predicted values.","code":""},{"path":"https://sipemu.github.io/fdars/reference/pred.MAE.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mean Absolute Error ‚Äî pred.MAE","text":"mean absolute error.","code":""},{"path":"https://sipemu.github.io/fdars/reference/pred.MAE.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mean Absolute Error ‚Äî pred.MAE","text":"","code":"y_true <- c(1, 2, 3, 4, 5) y_pred <- c(1.1, 2.2, 2.9, 4.1, 4.8) pred.MAE(y_true, y_pred) #> [1] 0.14"},{"path":"https://sipemu.github.io/fdars/reference/pred.MSE.html","id":null,"dir":"Reference","previous_headings":"","what":"Mean Squared Error ‚Äî pred.MSE","title":"Mean Squared Error ‚Äî pred.MSE","text":"Compute Mean Squared Error predicted actual values.","code":""},{"path":"https://sipemu.github.io/fdars/reference/pred.MSE.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mean Squared Error ‚Äî pred.MSE","text":"","code":"pred.MSE(y_true, y_pred)"},{"path":"https://sipemu.github.io/fdars/reference/pred.MSE.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mean Squared Error ‚Äî pred.MSE","text":"y_true Actual values. y_pred Predicted values.","code":""},{"path":"https://sipemu.github.io/fdars/reference/pred.MSE.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mean Squared Error ‚Äî pred.MSE","text":"mean squared error.","code":""},{"path":"https://sipemu.github.io/fdars/reference/pred.MSE.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mean Squared Error ‚Äî pred.MSE","text":"","code":"y_true <- c(1, 2, 3, 4, 5) y_pred <- c(1.1, 2.2, 2.9, 4.1, 4.8) pred.MSE(y_true, y_pred) #> [1] 0.022"},{"path":"https://sipemu.github.io/fdars/reference/pred.R2.html","id":null,"dir":"Reference","previous_headings":"","what":"R-Squared (Coefficient of Determination) ‚Äî pred.R2","title":"R-Squared (Coefficient of Determination) ‚Äî pred.R2","text":"Compute R-squared value predicted actual values.","code":""},{"path":"https://sipemu.github.io/fdars/reference/pred.R2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"R-Squared (Coefficient of Determination) ‚Äî pred.R2","text":"","code":"pred.R2(y_true, y_pred)"},{"path":"https://sipemu.github.io/fdars/reference/pred.R2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"R-Squared (Coefficient of Determination) ‚Äî pred.R2","text":"y_true Actual values. y_pred Predicted values.","code":""},{"path":"https://sipemu.github.io/fdars/reference/pred.R2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"R-Squared (Coefficient of Determination) ‚Äî pred.R2","text":"R-squared value.","code":""},{"path":"https://sipemu.github.io/fdars/reference/pred.R2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"R-Squared (Coefficient of Determination) ‚Äî pred.R2","text":"","code":"y_true <- c(1, 2, 3, 4, 5) y_pred <- c(1.1, 2.2, 2.9, 4.1, 4.8) pred.R2(y_true, y_pred) #> [1] 0.989"},{"path":"https://sipemu.github.io/fdars/reference/pred.RMSE.html","id":null,"dir":"Reference","previous_headings":"","what":"Root Mean Squared Error ‚Äî pred.RMSE","title":"Root Mean Squared Error ‚Äî pred.RMSE","text":"Compute Root Mean Squared Error predicted actual values.","code":""},{"path":"https://sipemu.github.io/fdars/reference/pred.RMSE.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Root Mean Squared Error ‚Äî pred.RMSE","text":"","code":"pred.RMSE(y_true, y_pred)"},{"path":"https://sipemu.github.io/fdars/reference/pred.RMSE.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Root Mean Squared Error ‚Äî pred.RMSE","text":"y_true Actual values. y_pred Predicted values.","code":""},{"path":"https://sipemu.github.io/fdars/reference/pred.RMSE.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Root Mean Squared Error ‚Äî pred.RMSE","text":"root mean squared error.","code":""},{"path":"https://sipemu.github.io/fdars/reference/pred.RMSE.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Root Mean Squared Error ‚Äî pred.RMSE","text":"","code":"y_true <- c(1, 2, 3, 4, 5) y_pred <- c(1.1, 2.2, 2.9, 4.1, 4.8) pred.RMSE(y_true, y_pred) #> [1] 0.148324"},{"path":"https://sipemu.github.io/fdars/reference/predict.fregre.fd.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict Method for Functional Regression (fregre.fd) ‚Äî predict.fregre.fd","title":"Predict Method for Functional Regression (fregre.fd) ‚Äî predict.fregre.fd","text":"Predictions fitted functional regression model (fregre.pc fregre.basis).","code":""},{"path":"https://sipemu.github.io/fdars/reference/predict.fregre.fd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict Method for Functional Regression (fregre.fd) ‚Äî predict.fregre.fd","text":"","code":"# S3 method for class 'fregre.fd' predict(object, newdata = NULL, ...)"},{"path":"https://sipemu.github.io/fdars/reference/predict.fregre.fd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict Method for Functional Regression (fregre.fd) ‚Äî predict.fregre.fd","text":"object fitted model object class 'fregre.fd'. newdata fdata object containing new functional data prediction. NULL, returns fitted values training data. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/predict.fregre.fd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict Method for Functional Regression (fregre.fd) ‚Äî predict.fregre.fd","text":"numeric vector predicted values.","code":""},{"path":"https://sipemu.github.io/fdars/reference/predict.fregre.fd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict Method for Functional Regression (fregre.fd) ‚Äî predict.fregre.fd","text":"","code":"# Create functional data t <- seq(0, 1, length.out = 50) X <- matrix(0, 30, 50) for (i in 1:30) X[i, ] <- sin(2*pi*t) * i/30 + rnorm(50, sd = 0.1) y <- rowMeans(X) + rnorm(30, sd = 0.1) fd <- fdata(X, argvals = t)  # Fit model fit <- fregre.pc(fd, y, ncomp = 3)  # Predict on new data X_new <- matrix(sin(2*pi*t) * 0.5, nrow = 1) fd_new <- fdata(X_new, argvals = t) predict(fit, fd_new) #> [1] -0.006089758"},{"path":"https://sipemu.github.io/fdars/reference/predict.fregre.np.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict Method for Nonparametric Functional Regression (fregre.np) ‚Äî predict.fregre.np","title":"Predict Method for Nonparametric Functional Regression (fregre.np) ‚Äî predict.fregre.np","text":"Predictions fitted nonparametric functional regression model.","code":""},{"path":"https://sipemu.github.io/fdars/reference/predict.fregre.np.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict Method for Nonparametric Functional Regression (fregre.np) ‚Äî predict.fregre.np","text":"","code":"# S3 method for class 'fregre.np' predict(object, newdata = NULL, ...)"},{"path":"https://sipemu.github.io/fdars/reference/predict.fregre.np.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict Method for Nonparametric Functional Regression (fregre.np) ‚Äî predict.fregre.np","text":"object fitted model object class 'fregre.np'. newdata fdata object containing new functional data prediction. NULL, returns fitted values training data. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/predict.fregre.np.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict Method for Nonparametric Functional Regression (fregre.np) ‚Äî predict.fregre.np","text":"numeric vector predicted values.","code":""},{"path":"https://sipemu.github.io/fdars/reference/predict.fregre.np.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict Method for Nonparametric Functional Regression (fregre.np) ‚Äî predict.fregre.np","text":"","code":"# Create functional data t <- seq(0, 1, length.out = 50) X <- matrix(0, 30, 50) for (i in 1:30) X[i, ] <- sin(2*pi*t) * i/30 + rnorm(50, sd = 0.1) y <- rowMeans(X) + rnorm(30, sd = 0.1) fd <- fdata(X, argvals = t)  # Fit model fit <- fregre.np(fd, y)  # Predict on new data X_new <- matrix(sin(2*pi*t) * 0.5, nrow = 1) fd_new <- fdata(X_new, argvals = t) predict(fit, fd_new) #> [1] -0.0289333"},{"path":"https://sipemu.github.io/fdars/reference/predict.fregre.np.multi.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict method for fregre.np.multi ‚Äî predict.fregre.np.multi","title":"Predict method for fregre.np.multi ‚Äî predict.fregre.np.multi","text":"Predict method fregre.np.multi","code":""},{"path":"https://sipemu.github.io/fdars/reference/predict.fregre.np.multi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict method for fregre.np.multi ‚Äî predict.fregre.np.multi","text":"","code":"# S3 method for class 'fregre.np.multi' predict(object, newdata.list = NULL, ...)"},{"path":"https://sipemu.github.io/fdars/reference/predict.fregre.np.multi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict method for fregre.np.multi ‚Äî predict.fregre.np.multi","text":"object Fitted fregre.np.multi object. newdata.list List new fdata objects (length original). ... Additional arguments.","code":""},{"path":"https://sipemu.github.io/fdars/reference/predict.fregre.np.multi.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict method for fregre.np.multi ‚Äî predict.fregre.np.multi","text":"Predicted values.","code":""},{"path":"https://sipemu.github.io/fdars/reference/print.basis.cv.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for basis.cv objects ‚Äî print.basis.cv","title":"Print method for basis.cv objects ‚Äî print.basis.cv","text":"Print method basis.cv objects","code":""},{"path":"https://sipemu.github.io/fdars/reference/print.basis.cv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for basis.cv objects ‚Äî print.basis.cv","text":"","code":"# S3 method for class 'basis.cv' print(x, ...)"},{"path":"https://sipemu.github.io/fdars/reference/print.basis.cv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for basis.cv objects ‚Äî print.basis.cv","text":"x basis.cv object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/print.cluster.fcm.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Method for cluster.fcm Objects ‚Äî print.cluster.fcm","title":"Print Method for cluster.fcm Objects ‚Äî print.cluster.fcm","text":"Print Method cluster.fcm Objects","code":""},{"path":"https://sipemu.github.io/fdars/reference/print.cluster.fcm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Method for cluster.fcm Objects ‚Äî print.cluster.fcm","text":"","code":"# S3 method for class 'cluster.fcm' print(x, ...)"},{"path":"https://sipemu.github.io/fdars/reference/print.cluster.fcm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Method for cluster.fcm Objects ‚Äî print.cluster.fcm","text":"x object class 'cluster.fcm'. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/print.cluster.kmeans.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Method for cluster.kmeans Objects ‚Äî print.cluster.kmeans","title":"Print Method for cluster.kmeans Objects ‚Äî print.cluster.kmeans","text":"Print Method cluster.kmeans Objects","code":""},{"path":"https://sipemu.github.io/fdars/reference/print.cluster.kmeans.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Method for cluster.kmeans Objects ‚Äî print.cluster.kmeans","text":"","code":"# S3 method for class 'cluster.kmeans' print(x, ...)"},{"path":"https://sipemu.github.io/fdars/reference/print.cluster.kmeans.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Method for cluster.kmeans Objects ‚Äî print.cluster.kmeans","text":"x object class 'cluster.kmeans'. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/print.cluster.optim.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Method for cluster.optim Objects ‚Äî print.cluster.optim","title":"Print Method for cluster.optim Objects ‚Äî print.cluster.optim","text":"Print Method cluster.optim Objects","code":""},{"path":"https://sipemu.github.io/fdars/reference/print.cluster.optim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Method for cluster.optim Objects ‚Äî print.cluster.optim","text":"","code":"# S3 method for class 'cluster.optim' print(x, ...)"},{"path":"https://sipemu.github.io/fdars/reference/print.cluster.optim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Method for cluster.optim Objects ‚Äî print.cluster.optim","text":"x object class 'cluster.optim'. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/print.fbplot.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Method for fbplot Objects ‚Äî print.fbplot","title":"Print Method for fbplot Objects ‚Äî print.fbplot","text":"Print Method fbplot Objects","code":""},{"path":"https://sipemu.github.io/fdars/reference/print.fbplot.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Method for fbplot Objects ‚Äî print.fbplot","text":"","code":"# S3 method for class 'fbplot' print(x, ...)"},{"path":"https://sipemu.github.io/fdars/reference/print.fbplot.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Method for fbplot Objects ‚Äî print.fbplot","text":"x object class 'fbplot'. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/print.fdata.bootstrap.ci.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for bootstrap CI ‚Äî print.fdata.bootstrap.ci","title":"Print method for bootstrap CI ‚Äî print.fdata.bootstrap.ci","text":"Print method bootstrap CI","code":""},{"path":"https://sipemu.github.io/fdars/reference/print.fdata.bootstrap.ci.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for bootstrap CI ‚Äî print.fdata.bootstrap.ci","text":"","code":"# S3 method for class 'fdata.bootstrap.ci' print(x, ...)"},{"path":"https://sipemu.github.io/fdars/reference/print.fdata.bootstrap.ci.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for bootstrap CI ‚Äî print.fdata.bootstrap.ci","text":"x fdata.bootstrap.ci object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/print.fdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for fdata objects ‚Äî print.fdata","title":"Print method for fdata objects ‚Äî print.fdata","text":"Print method fdata objects","code":""},{"path":"https://sipemu.github.io/fdars/reference/print.fdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for fdata objects ‚Äî print.fdata","text":"","code":"# S3 method for class 'fdata' print(x, ...)"},{"path":"https://sipemu.github.io/fdars/reference/print.fdata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for fdata objects ‚Äî print.fdata","text":"x object class 'fdata'. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/print.fdata2pc.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Method for FPCA Results ‚Äî print.fdata2pc","title":"Print Method for FPCA Results ‚Äî print.fdata2pc","text":"Print Method FPCA Results","code":""},{"path":"https://sipemu.github.io/fdars/reference/print.fdata2pc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Method for FPCA Results ‚Äî print.fdata2pc","text":"","code":"# S3 method for class 'fdata2pc' print(x, ...)"},{"path":"https://sipemu.github.io/fdars/reference/print.fdata2pc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Method for FPCA Results ‚Äî print.fdata2pc","text":"x object class 'fdata2pc'. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/print.fregre.fd.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for fregre objects ‚Äî print.fregre.fd","title":"Print method for fregre objects ‚Äî print.fregre.fd","text":"Print method fregre objects","code":""},{"path":"https://sipemu.github.io/fdars/reference/print.fregre.fd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for fregre objects ‚Äî print.fregre.fd","text":"","code":"# S3 method for class 'fregre.fd' print(x, ...)"},{"path":"https://sipemu.github.io/fdars/reference/print.fregre.fd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for fregre objects ‚Äî print.fregre.fd","text":"x fregre.fd object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/print.fregre.np.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for fregre.np objects ‚Äî print.fregre.np","title":"Print method for fregre.np objects ‚Äî print.fregre.np","text":"Print method fregre.np objects","code":""},{"path":"https://sipemu.github.io/fdars/reference/print.fregre.np.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for fregre.np objects ‚Äî print.fregre.np","text":"","code":"# S3 method for class 'fregre.np' print(x, ...)"},{"path":"https://sipemu.github.io/fdars/reference/print.fregre.np.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for fregre.np objects ‚Äî print.fregre.np","text":"x fregre.np object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/print.fregre.np.multi.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for fregre.np.multi ‚Äî print.fregre.np.multi","title":"Print method for fregre.np.multi ‚Äî print.fregre.np.multi","text":"Print method fregre.np.multi","code":""},{"path":"https://sipemu.github.io/fdars/reference/print.fregre.np.multi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for fregre.np.multi ‚Äî print.fregre.np.multi","text":"","code":"# S3 method for class 'fregre.np.multi' print(x, ...)"},{"path":"https://sipemu.github.io/fdars/reference/print.fregre.np.multi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for fregre.np.multi ‚Äî print.fregre.np.multi","text":"x fregre.np.multi object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/print.group.distance.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for group.distance ‚Äî print.group.distance","title":"Print method for group.distance ‚Äî print.group.distance","text":"Print method group.distance","code":""},{"path":"https://sipemu.github.io/fdars/reference/print.group.distance.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for group.distance ‚Äî print.group.distance","text":"","code":"# S3 method for class 'group.distance' print(x, digits = 3, ...)"},{"path":"https://sipemu.github.io/fdars/reference/print.group.distance.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for group.distance ‚Äî print.group.distance","text":"x group.distance object. digits Number digits printing (default 3). ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/print.group.test.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for group.test ‚Äî print.group.test","title":"Print method for group.test ‚Äî print.group.test","text":"Print method group.test","code":""},{"path":"https://sipemu.github.io/fdars/reference/print.group.test.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for group.test ‚Äî print.group.test","text":"","code":"# S3 method for class 'group.test' print(x, ...)"},{"path":"https://sipemu.github.io/fdars/reference/print.group.test.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for group.test ‚Äî print.group.test","text":"x group.test object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/print.kernel.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Method for Covariance Functions ‚Äî print.kernel","title":"Print Method for Covariance Functions ‚Äî print.kernel","text":"Print Method Covariance Functions","code":""},{"path":"https://sipemu.github.io/fdars/reference/print.kernel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Method for Covariance Functions ‚Äî print.kernel","text":"","code":"# S3 method for class 'kernel' print(x, ...)"},{"path":"https://sipemu.github.io/fdars/reference/print.kernel.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Method for Covariance Functions ‚Äî print.kernel","text":"x covariance function object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/print.magnitudeshape.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Method for magnitudeshape Objects ‚Äî print.magnitudeshape","title":"Print Method for magnitudeshape Objects ‚Äî print.magnitudeshape","text":"Print Method magnitudeshape Objects","code":""},{"path":"https://sipemu.github.io/fdars/reference/print.magnitudeshape.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Method for magnitudeshape Objects ‚Äî print.magnitudeshape","text":"","code":"# S3 method for class 'magnitudeshape' print(x, ...)"},{"path":"https://sipemu.github.io/fdars/reference/print.magnitudeshape.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Method for magnitudeshape Objects ‚Äî print.magnitudeshape","text":"x object class 'magnitudeshape'. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/print.outliergram.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Method for Outliergram Objects ‚Äî print.outliergram","title":"Print Method for Outliergram Objects ‚Äî print.outliergram","text":"Print Method Outliergram Objects","code":""},{"path":"https://sipemu.github.io/fdars/reference/print.outliergram.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Method for Outliergram Objects ‚Äî print.outliergram","text":"","code":"# S3 method for class 'outliergram' print(x, ...)"},{"path":"https://sipemu.github.io/fdars/reference/print.outliergram.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Method for Outliergram Objects ‚Äî print.outliergram","text":"x object class 'outliergram'. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/print.outliers.fdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for outliers.fdata objects ‚Äî print.outliers.fdata","title":"Print method for outliers.fdata objects ‚Äî print.outliers.fdata","text":"Print method outliers.fdata objects","code":""},{"path":"https://sipemu.github.io/fdars/reference/print.outliers.fdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for outliers.fdata objects ‚Äî print.outliers.fdata","text":"","code":"# S3 method for class 'outliers.fdata' print(x, ...)"},{"path":"https://sipemu.github.io/fdars/reference/print.outliers.fdata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for outliers.fdata objects ‚Äî print.outliers.fdata","text":"x outliers.fdata object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/print.pspline.2d.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for pspline.2d objects ‚Äî print.pspline.2d","title":"Print method for pspline.2d objects ‚Äî print.pspline.2d","text":"Print method pspline.2d objects","code":""},{"path":"https://sipemu.github.io/fdars/reference/print.pspline.2d.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for pspline.2d objects ‚Äî print.pspline.2d","text":"","code":"# S3 method for class 'pspline.2d' print(x, ...)"},{"path":"https://sipemu.github.io/fdars/reference/print.pspline.2d.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for pspline.2d objects ‚Äî print.pspline.2d","text":"x pspline.2d object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/print.pspline.html","id":null,"dir":"Reference","previous_headings":"","what":"Print method for pspline objects ‚Äî print.pspline","title":"Print method for pspline objects ‚Äî print.pspline","text":"Print method pspline objects","code":""},{"path":"https://sipemu.github.io/fdars/reference/print.pspline.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print method for pspline objects ‚Äî print.pspline","text":"","code":"# S3 method for class 'pspline' print(x, ...)"},{"path":"https://sipemu.github.io/fdars/reference/print.pspline.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print method for pspline objects ‚Äî print.pspline","text":"x pspline object. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/print.register.fd.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Method for register.fd Objects ‚Äî print.register.fd","title":"Print Method for register.fd Objects ‚Äî print.register.fd","text":"Print Method register.fd Objects","code":""},{"path":"https://sipemu.github.io/fdars/reference/print.register.fd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Method for register.fd Objects ‚Äî print.register.fd","text":"","code":"# S3 method for class 'register.fd' print(x, ...)"},{"path":"https://sipemu.github.io/fdars/reference/print.register.fd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Method for register.fd Objects ‚Äî print.register.fd","text":"x object class 'register.fd'. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/pspline.2d.html","id":null,"dir":"Reference","previous_headings":"","what":"P-spline Smoothing for 2D Functional Data ‚Äî pspline.2d","title":"P-spline Smoothing for 2D Functional Data ‚Äî pspline.2d","text":"Fits 2D P-splines anisotropic penalties directions.","code":""},{"path":"https://sipemu.github.io/fdars/reference/pspline.2d.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"P-spline Smoothing for 2D Functional Data ‚Äî pspline.2d","text":"","code":"pspline.2d(   fdataobj,   nbasis.s = 10,   nbasis.t = 10,   lambda.s = 1,   lambda.t = 1,   order = 2,   lambda.select = FALSE,   criterion = c(\"GCV\", \"AIC\", \"BIC\") )"},{"path":"https://sipemu.github.io/fdars/reference/pspline.2d.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"P-spline Smoothing for 2D Functional Data ‚Äî pspline.2d","text":"fdataobj 2D fdata object. nbasis.s Number B-spline basis functions s direction. nbasis.t Number B-spline basis functions t direction. lambda.s Smoothing parameter s direction. lambda.t Smoothing parameter t direction. order Order difference penalty (default 2). lambda.select Logical. TRUE, select lambdas automatically. criterion Criterion selection: \"GCV\", \"AIC\", \"BIC\".","code":""},{"path":"https://sipemu.github.io/fdars/reference/pspline.2d.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"P-spline Smoothing for 2D Functional Data ‚Äî pspline.2d","text":"list class \"pspline.2d\" similar pspline().","code":""},{"path":"https://sipemu.github.io/fdars/reference/pspline.2d.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"P-spline Smoothing for 2D Functional Data ‚Äî pspline.2d","text":"2D penalty uses Kronecker product structure: $$P = \\lambda_s (I_t \\otimes P_s) + \\lambda_t (P_t \\otimes I_s)$$","code":""},{"path":"https://sipemu.github.io/fdars/reference/pspline.html","id":null,"dir":"Reference","previous_headings":"","what":"P-spline Smoothing for Functional Data ‚Äî pspline","title":"P-spline Smoothing for Functional Data ‚Äî pspline","text":"Fits penalized B-splines (P-splines) functional data automatic manual selection smoothing parameter.","code":""},{"path":"https://sipemu.github.io/fdars/reference/pspline.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"P-spline Smoothing for Functional Data ‚Äî pspline","text":"","code":"pspline(   fdataobj,   nbasis = 20,   lambda = 1,   order = 2,   lambda.select = FALSE,   criterion = c(\"GCV\", \"AIC\", \"BIC\"),   lambda.range = 10^seq(-4, 4, length.out = 50) )"},{"path":"https://sipemu.github.io/fdars/reference/pspline.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"P-spline Smoothing for Functional Data ‚Äî pspline","text":"fdataobj fdata object. nbasis Number B-spline basis functions (default 20). lambda Smoothing parameter. Higher values give smoother curves. NULL lambda.select = TRUE, selected automatically. order Order difference penalty (default 2, second derivative penalty). lambda.select Logical. TRUE, select lambda automatically using specified criterion. criterion Criterion lambda selection: \"GCV\" (default), \"AIC\", \"BIC\". lambda.range Range lambda values search (log10 scale). Default: 10^seq(-4, 4, length.= 50).","code":""},{"path":"https://sipemu.github.io/fdars/reference/pspline.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"P-spline Smoothing for Functional Data ‚Äî pspline","text":"list class \"pspline\" : fdata Smoothed fdata object coefs Coefficient matrix lambda Used selected lambda value edf Effective degrees freedom gcv/aic/bic Criterion values nbasis Number basis functions used","code":""},{"path":"https://sipemu.github.io/fdars/reference/pspline.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"P-spline Smoothing for Functional Data ‚Äî pspline","text":"P-splines minimize: $$||y - B c||^2 + \\lambda c' D' D c$$ B B-spline basis matrix, c coefficients, D difference matrix specified order.","code":""},{"path":"https://sipemu.github.io/fdars/reference/pspline.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"P-spline Smoothing for Functional Data ‚Äî pspline","text":"Eilers, P.H.C. Marx, B.D. (1996). Flexible smoothing B-splines penalties. Statistical Science, 11(2), 89-121.","code":""},{"path":"https://sipemu.github.io/fdars/reference/pspline.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"P-spline Smoothing for Functional Data ‚Äî pspline","text":"","code":"# Create noisy data t <- seq(0, 1, length.out = 100) true_signal <- sin(2 * pi * t) noisy <- true_signal + rnorm(100, sd = 0.3) fd <- fdata(matrix(noisy, nrow = 1), argvals = t)  # Smooth with P-splines result <- pspline(fd, nbasis = 20, lambda = 10) plot(fd)  lines(t, result$fdata$data[1, ], col = \"red\", lwd = 2) #> Error in plot.xy(xy.coords(x, y), type = type, ...): plot.new has not been called yet  # Automatic lambda selection result_auto <- pspline(fd, nbasis = 20, lambda.select = TRUE)"},{"path":"https://sipemu.github.io/fdars/reference/r.bridge.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Brownian Bridge ‚Äî r.bridge","title":"Generate Brownian Bridge ‚Äî r.bridge","text":"Simulate sample paths Brownian bridge, Brownian motion conditioned return 0 time 1.","code":""},{"path":"https://sipemu.github.io/fdars/reference/r.bridge.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Brownian Bridge ‚Äî r.bridge","text":"","code":"r.bridge(n, t, sigma = 1, seed = NULL)"},{"path":"https://sipemu.github.io/fdars/reference/r.bridge.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Brownian Bridge ‚Äî r.bridge","text":"n Number sample paths. t Evaluation points (include 0 1 standard bridge). sigma Volatility (default 1). seed Optional random seed.","code":""},{"path":"https://sipemu.github.io/fdars/reference/r.bridge.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Brownian Bridge ‚Äî r.bridge","text":"fdata object containing simulated paths.","code":""},{"path":"https://sipemu.github.io/fdars/reference/r.bridge.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Brownian Bridge ‚Äî r.bridge","text":"","code":"t <- seq(0, 1, length.out = 100) bb_data <- r.bridge(n = 20, t = t) plot(bb_data)"},{"path":"https://sipemu.github.io/fdars/reference/r.brownian.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Brownian Motion ‚Äî r.brownian","title":"Generate Brownian Motion ‚Äî r.brownian","text":"Simulate sample paths standard Brownian motion (Wiener process).","code":""},{"path":"https://sipemu.github.io/fdars/reference/r.brownian.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Brownian Motion ‚Äî r.brownian","text":"","code":"r.brownian(n, t, sigma = 1, x0 = 0, seed = NULL)"},{"path":"https://sipemu.github.io/fdars/reference/r.brownian.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Brownian Motion ‚Äî r.brownian","text":"n Number sample paths. t Evaluation points. sigma Volatility (standard deviation per unit time, default 1). x0 Initial value (default 0). seed Optional random seed.","code":""},{"path":"https://sipemu.github.io/fdars/reference/r.brownian.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Brownian Motion ‚Äî r.brownian","text":"fdata object containing simulated paths.","code":""},{"path":"https://sipemu.github.io/fdars/reference/r.brownian.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Brownian Motion ‚Äî r.brownian","text":"","code":"t <- seq(0, 1, length.out = 100) bm_data <- r.brownian(n = 20, t = t) plot(bm_data)"},{"path":"https://sipemu.github.io/fdars/reference/r.ou.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Ornstein-Uhlenbeck Process ‚Äî r.ou","title":"Generate Ornstein-Uhlenbeck Process ‚Äî r.ou","text":"Simulate sample paths Ornstein-Uhlenbeck process using Euler-Maruyama discretization scheme.","code":""},{"path":"https://sipemu.github.io/fdars/reference/r.ou.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Ornstein-Uhlenbeck Process ‚Äî r.ou","text":"","code":"r.ou(n, t, mu = 0, theta = 1, sigma = 1, x0 = 0, seed = NULL)"},{"path":"https://sipemu.github.io/fdars/reference/r.ou.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Ornstein-Uhlenbeck Process ‚Äî r.ou","text":"n Number sample paths generate. t Evaluation points (numeric vector). mu Long-term mean (default 0). theta Mean reversion rate (default 1). sigma Volatility (default 1). x0 Initial value (default 0). seed Optional random seed.","code":""},{"path":"https://sipemu.github.io/fdars/reference/r.ou.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Ornstein-Uhlenbeck Process ‚Äî r.ou","text":"fdata object containing simulated paths.","code":""},{"path":"https://sipemu.github.io/fdars/reference/r.ou.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Ornstein-Uhlenbeck Process ‚Äî r.ou","text":"OU process satisfies SDE: dX(t) = -theta * X(t) dt + sigma * dW(t)","code":""},{"path":"https://sipemu.github.io/fdars/reference/r.ou.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Ornstein-Uhlenbeck Process ‚Äî r.ou","text":"","code":"t <- seq(0, 1, length.out = 100) ou_data <- r.ou(n = 20, t = t, theta = 2, sigma = 1) plot(ou_data)"},{"path":"https://sipemu.github.io/fdars/reference/register.fd.html","id":null,"dir":"Reference","previous_headings":"","what":"Curve Registration (Alignment) ‚Äî register.fd","title":"Curve Registration (Alignment) ‚Äî register.fd","text":"Aligns functional data horizontal shifting target curve. reduces phase variation sample.","code":""},{"path":"https://sipemu.github.io/fdars/reference/register.fd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Curve Registration (Alignment) ‚Äî register.fd","text":"","code":"register.fd(fdataobj, target = NULL, max.shift = 0.2)"},{"path":"https://sipemu.github.io/fdars/reference/register.fd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Curve Registration (Alignment) ‚Äî register.fd","text":"fdataobj object class 'fdata'. target Target curve align . NULL (default), uses mean. max.shift Maximum allowed shift proportion domain (default 0.2).","code":""},{"path":"https://sipemu.github.io/fdars/reference/register.fd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Curve Registration (Alignment) ‚Äî register.fd","text":"list class 'register.fd' components: registered fdata object registered (aligned) curves. shifts Numeric vector shift amounts curve. target target curve used alignment. fdataobj Original (unregistered) functional data.","code":""},{"path":"https://sipemu.github.io/fdars/reference/register.fd.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Curve Registration (Alignment) ‚Äî register.fd","text":"Shift registration finds horizontal translation maximizes cross-correlation curve target. appropriate curves similar shapes differ mainly timing. complex warping, consider DTW-based methods.","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/reference/register.fd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Curve Registration (Alignment) ‚Äî register.fd","text":"","code":"# Create phase-shifted curves set.seed(42) t <- seq(0, 1, length.out = 100) X <- matrix(0, 20, 100) for (i in 1:20) {   phase <- runif(1, -0.1, 0.1)   X[i, ] <- sin(2*pi*(t + phase)) + rnorm(100, sd = 0.1) } fd <- fdata(X, argvals = t)  # Register curves reg <- register.fd(fd) print(reg) #> Curve Registration #> ================== #> Number of curves: 20  #> Shift statistics: #>   Min: -0.1212  #>   Max: 0.1212  #>   Mean: -5e-04  #>   SD: 0.0856   # Compare original vs registered par(mfrow = c(1, 2)) plot(fd)  plot(reg$registered)"},{"path":"https://sipemu.github.io/fdars/reference/sd.html","id":null,"dir":"Reference","previous_headings":"","what":"Functional Standard Deviation ‚Äî sd","title":"Functional Standard Deviation ‚Äî sd","text":"Computes pointwise standard deviation function functional data.","code":""},{"path":"https://sipemu.github.io/fdars/reference/sd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functional Standard Deviation ‚Äî sd","text":"","code":"sd(fdataobj, ...)"},{"path":"https://sipemu.github.io/fdars/reference/sd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functional Standard Deviation ‚Äî sd","text":"fdataobj object class 'fdata'. ... Additional arguments (currently ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/sd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functional Standard Deviation ‚Äî sd","text":"fdata object containing standard deviation function (1D 2D).","code":""},{"path":"https://sipemu.github.io/fdars/reference/sd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Functional Standard Deviation ‚Äî sd","text":"","code":"# 1D functional data fd <- fdata(matrix(rnorm(100), 10, 10)) s <- sd(fd)  # 2D functional data X <- array(rnorm(500), dim = c(5, 10, 10)) fd2d <- fdata(X, argvals = list(1:10, 1:10), fdata2d = TRUE) s2d <- sd(fd2d)"},{"path":"https://sipemu.github.io/fdars/reference/seasonal_strength.html","id":null,"dir":"Reference","previous_headings":"","what":"Measure Seasonal Strength ‚Äî seasonal_strength","title":"Measure Seasonal Strength ‚Äî seasonal_strength","text":"Computes strength seasonality functional data. Values range 0 (seasonality) 1 (pure seasonal signal).","code":""},{"path":"https://sipemu.github.io/fdars/reference/seasonal_strength.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Measure Seasonal Strength ‚Äî seasonal_strength","text":"","code":"seasonal_strength(   fdataobj,   period = NULL,   method = c(\"variance\", \"spectral\"),   n_harmonics = 3 )"},{"path":"https://sipemu.github.io/fdars/reference/seasonal_strength.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Measure Seasonal Strength ‚Äî seasonal_strength","text":"fdataobj fdata object. period Known estimated period. NULL, period estimated automatically using FFT. method Method computing strength: \"variance\" Variance decomposition: Var(seasonal) / Var(total) \"spectral\" Spectral: power seasonal frequencies / total power n_harmonics Number Fourier harmonics use (variance method). Default: 3.","code":""},{"path":"https://sipemu.github.io/fdars/reference/seasonal_strength.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Measure Seasonal Strength ‚Äî seasonal_strength","text":"numeric value 0 1 representing seasonal strength.","code":""},{"path":"https://sipemu.github.io/fdars/reference/seasonal_strength.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Measure Seasonal Strength ‚Äî seasonal_strength","text":"variance method decomposes signal seasonal component (using Fourier basis specified period) computes proportion variance explained seasonal component. spectral method computes proportion total spectral power falls seasonal frequency harmonics.","code":""},{"path":"https://sipemu.github.io/fdars/reference/seasonal_strength.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Measure Seasonal Strength ‚Äî seasonal_strength","text":"","code":"# Pure seasonal signal t <- seq(0, 10, length.out = 200) X <- matrix(sin(2 * pi * t / 2), nrow = 1) fd_seasonal <- fdata(X, argvals = t) seasonal_strength(fd_seasonal, period = 2)  # Should be close to 1 #> [1] 1  # Pure noise X_noise <- matrix(rnorm(200), nrow = 1) fd_noise <- fdata(X_noise, argvals = t) seasonal_strength(fd_noise, period = 2)  # Should be close to 0 #> [1] 0.02783907"},{"path":"https://sipemu.github.io/fdars/reference/seasonal_strength_curve.html","id":null,"dir":"Reference","previous_headings":"","what":"Time-Varying Seasonal Strength ‚Äî seasonal_strength_curve","title":"Time-Varying Seasonal Strength ‚Äî seasonal_strength_curve","text":"Computes seasonal strength time point using sliding window, allowing detection seasonality changes time.","code":""},{"path":"https://sipemu.github.io/fdars/reference/seasonal_strength_curve.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Time-Varying Seasonal Strength ‚Äî seasonal_strength_curve","text":"","code":"seasonal_strength_curve(   fdataobj,   period,   window_size = NULL,   method = c(\"variance\", \"spectral\") )"},{"path":"https://sipemu.github.io/fdars/reference/seasonal_strength_curve.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Time-Varying Seasonal Strength ‚Äî seasonal_strength_curve","text":"fdataobj fdata object. period Known estimated period. window_size Width sliding window. Recommended: 2 * period. method Method computing strength: \"variance\" \"spectral\".","code":""},{"path":"https://sipemu.github.io/fdars/reference/seasonal_strength_curve.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Time-Varying Seasonal Strength ‚Äî seasonal_strength_curve","text":"fdata object containing time-varying seasonal strength curve.","code":""},{"path":"https://sipemu.github.io/fdars/reference/seasonal_strength_curve.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Time-Varying Seasonal Strength ‚Äî seasonal_strength_curve","text":"","code":"# Signal that transitions from seasonal to non-seasonal t <- seq(0, 20, length.out = 400) X <- ifelse(t < 10, sin(2 * pi * t / 2), rnorm(length(t[t >= 10]), sd = 0.5)) X <- matrix(X, nrow = 1) fd <- fdata(X, argvals = t)  # Compute time-varying strength ss <- seasonal_strength_curve(fd, period = 2, window_size = 4) # plot(ss)  # Shows strength declining around t = 10"},{"path":"https://sipemu.github.io/fdars/reference/semimetric.basis.html","id":null,"dir":"Reference","previous_headings":"","what":"Semi-metric based on Basis Expansion ‚Äî semimetric.basis","title":"Semi-metric based on Basis Expansion ‚Äî semimetric.basis","text":"Computes semi-metric based L2 distance basis expansion coefficients. Supports B-spline Fourier basis.","code":""},{"path":"https://sipemu.github.io/fdars/reference/semimetric.basis.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Semi-metric based on Basis Expansion ‚Äî semimetric.basis","text":"","code":"semimetric.basis(   fdata1,   fdata2 = NULL,   nbasis = 5,   basis = \"bspline\",   nderiv = 0,   ... )"},{"path":"https://sipemu.github.io/fdars/reference/semimetric.basis.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Semi-metric based on Basis Expansion ‚Äî semimetric.basis","text":"fdata1 object class 'fdata'. fdata2 object class 'fdata'. NULL, uses fdata1. nbasis Number basis functions. Default 5. basis Type basis: \"bspline\" (default) \"fourier\". nderiv Derivative order compute distance (default 0). ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/semimetric.basis.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Semi-metric based on Basis Expansion ‚Äî semimetric.basis","text":"distance matrix based basis coefficients.","code":""},{"path":"https://sipemu.github.io/fdars/reference/semimetric.basis.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Semi-metric based on Basis Expansion ‚Äî semimetric.basis","text":"","code":"# Create curves t <- seq(0, 1, length.out = 100) X <- matrix(0, 10, 100) for (i in 1:10) X[i, ] <- sin(2*pi*t + i/5) + rnorm(100, sd = 0.1) fd <- fdata(X, argvals = t)  # Compute distance based on B-spline coefficients D <- semimetric.basis(fd, nbasis = 7)"},{"path":"https://sipemu.github.io/fdars/reference/semimetric.deriv.html","id":null,"dir":"Reference","previous_headings":"","what":"Semi-metric based on Derivatives ‚Äî semimetric.deriv","title":"Semi-metric based on Derivatives ‚Äî semimetric.deriv","text":"Computes semi-metric based Lp distance nderiv-th derivative functional data.","code":""},{"path":"https://sipemu.github.io/fdars/reference/semimetric.deriv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Semi-metric based on Derivatives ‚Äî semimetric.deriv","text":"","code":"semimetric.deriv(fdata1, fdata2 = NULL, nderiv = 1, lp = 2, ...)"},{"path":"https://sipemu.github.io/fdars/reference/semimetric.deriv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Semi-metric based on Derivatives ‚Äî semimetric.deriv","text":"fdata1 object class 'fdata'. fdata2 object class 'fdata'. NULL, uses fdata1. nderiv Derivative order (1, 2, ...). Default 1. lp p Lp metric. Default 2 (L2 distance). ... Additional arguments passed deriv.","code":""},{"path":"https://sipemu.github.io/fdars/reference/semimetric.deriv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Semi-metric based on Derivatives ‚Äî semimetric.deriv","text":"distance matrix based derivative distances.","code":""},{"path":"https://sipemu.github.io/fdars/reference/semimetric.deriv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Semi-metric based on Derivatives ‚Äî semimetric.deriv","text":"","code":"# Create smooth curves t <- seq(0, 2*pi, length.out = 100) X <- matrix(0, 10, 100) for (i in 1:10) X[i, ] <- sin(t + i/5) fd <- fdata(X, argvals = t)  # Compute distance based on first derivative D <- semimetric.deriv(fd, nderiv = 1)"},{"path":"https://sipemu.github.io/fdars/reference/semimetric.fourier.html","id":null,"dir":"Reference","previous_headings":"","what":"Semi-metric based on Fourier Coefficients (FFT) ‚Äî semimetric.fourier","title":"Semi-metric based on Fourier Coefficients (FFT) ‚Äî semimetric.fourier","text":"Computes semi-metric based L2 distance Fourier coefficients computed via Fast Fourier Transform (FFT). efficient Fourier basis option semimetric.basis large nfreq.","code":""},{"path":"https://sipemu.github.io/fdars/reference/semimetric.fourier.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Semi-metric based on Fourier Coefficients (FFT) ‚Äî semimetric.fourier","text":"","code":"semimetric.fourier(fdata1, fdata2 = NULL, nfreq = 5, ...)"},{"path":"https://sipemu.github.io/fdars/reference/semimetric.fourier.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Semi-metric based on Fourier Coefficients (FFT) ‚Äî semimetric.fourier","text":"fdata1 object class 'fdata'. fdata2 object class 'fdata'. NULL, uses fdata1. nfreq Number Fourier frequencies use (excluding DC). Default 5. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/semimetric.fourier.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Semi-metric based on Fourier Coefficients (FFT) ‚Äî semimetric.fourier","text":"distance matrix based Fourier coefficients.","code":""},{"path":"https://sipemu.github.io/fdars/reference/semimetric.fourier.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Semi-metric based on Fourier Coefficients (FFT) ‚Äî semimetric.fourier","text":"Fourier coefficients computed using FFT normalized number points. distance L2 distance magnitude first nfreq+1 coefficients (DC + nfreq frequencies). function uses Rust's rustfft library efficient FFT computation, making faster R's base fft large datasets.","code":""},{"path":"https://sipemu.github.io/fdars/reference/semimetric.fourier.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Semi-metric based on Fourier Coefficients (FFT) ‚Äî semimetric.fourier","text":"","code":"# Create curves with different frequency content t <- seq(0, 1, length.out = 100) X <- matrix(0, 10, 100) for (i in 1:10) X[i, ] <- sin(2*pi*i*t) + rnorm(100, sd = 0.1) fd <- fdata(X, argvals = t)  # Compute distance based on Fourier coefficients D <- semimetric.fourier(fd, nfreq = 10)"},{"path":"https://sipemu.github.io/fdars/reference/semimetric.hshift.html","id":null,"dir":"Reference","previous_headings":"","what":"Semi-metric based on Horizontal Shift (Time Warping) ‚Äî semimetric.hshift","title":"Semi-metric based on Horizontal Shift (Time Warping) ‚Äî semimetric.hshift","text":"Computes semi-metric based minimum L2 distance optimal horizontal shifting curves. useful comparing curves may phase differences.","code":""},{"path":"https://sipemu.github.io/fdars/reference/semimetric.hshift.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Semi-metric based on Horizontal Shift (Time Warping) ‚Äî semimetric.hshift","text":"","code":"semimetric.hshift(fdata1, fdata2 = NULL, max_shift = -1, ...)"},{"path":"https://sipemu.github.io/fdars/reference/semimetric.hshift.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Semi-metric based on Horizontal Shift (Time Warping) ‚Äî semimetric.hshift","text":"fdata1 object class 'fdata'. fdata2 object class 'fdata'. NULL, uses fdata1. max_shift Maximum shift number grid points. Default m/4 m number evaluation points. Use -1 automatic. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/semimetric.hshift.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Semi-metric based on Horizontal Shift (Time Warping) ‚Äî semimetric.hshift","text":"distance matrix based minimum L2 distance shift.","code":""},{"path":"https://sipemu.github.io/fdars/reference/semimetric.hshift.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Semi-metric based on Horizontal Shift (Time Warping) ‚Äî semimetric.hshift","text":"pair curves, function computes: $$d(f, g) = \\min_{|h| \\le h_{max}} ||f(t) - g(t+h)||$$ h horizontal shift discrete units. semi-metric useful comparing curves phase shifts, ECG signals different heart rates periodic signals different phases.","code":""},{"path":"https://sipemu.github.io/fdars/reference/semimetric.hshift.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Semi-metric based on Horizontal Shift (Time Warping) ‚Äî semimetric.hshift","text":"","code":"# Create curves with phase shifts t <- seq(0, 2*pi, length.out = 100) X <- matrix(0, 10, 100) for (i in 1:10) X[i, ] <- sin(t + i*0.2) + rnorm(100, sd = 0.1) fd <- fdata(X, argvals = t)  # Compute distance accounting for phase shifts D <- semimetric.hshift(fd, max_shift = 10)"},{"path":"https://sipemu.github.io/fdars/reference/semimetric.pca.html","id":null,"dir":"Reference","previous_headings":"","what":"Semi-metric based on Principal Components ‚Äî semimetric.pca","title":"Semi-metric based on Principal Components ‚Äî semimetric.pca","text":"Computes semi-metric based first ncomp principal component scores.","code":""},{"path":"https://sipemu.github.io/fdars/reference/semimetric.pca.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Semi-metric based on Principal Components ‚Äî semimetric.pca","text":"","code":"semimetric.pca(fdata1, fdata2 = NULL, ncomp = 2, ...)"},{"path":"https://sipemu.github.io/fdars/reference/semimetric.pca.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Semi-metric based on Principal Components ‚Äî semimetric.pca","text":"fdata1 object class 'fdata'. fdata2 object class 'fdata'. NULL, uses fdata1. ncomp Number principal components use. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/semimetric.pca.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Semi-metric based on Principal Components ‚Äî semimetric.pca","text":"distance matrix based PC scores.","code":""},{"path":"https://sipemu.github.io/fdars/reference/semimetric.pca.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Semi-metric based on Principal Components ‚Äî semimetric.pca","text":"","code":"fd <- fdata(matrix(rnorm(200), 20, 10)) D <- semimetric.pca(fd, ncomp = 3)"},{"path":"https://sipemu.github.io/fdars/reference/sub-.fdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Subset method for fdata objects ‚Äî [.fdata","title":"Subset method for fdata objects ‚Äî [.fdata","text":"Subset method fdata objects","code":""},{"path":"https://sipemu.github.io/fdars/reference/sub-.fdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Subset method for fdata objects ‚Äî [.fdata","text":"","code":"# S3 method for class 'fdata' x[i, j, drop = FALSE]"},{"path":"https://sipemu.github.io/fdars/reference/sub-.fdata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Subset method for fdata objects ‚Äî [.fdata","text":"x object class 'fdata'. Row indices (curves keep). j Column indices (time points keep). drop Logical. TRUE one curve selected, return vector.","code":""},{"path":"https://sipemu.github.io/fdars/reference/summary.fdata.html","id":null,"dir":"Reference","previous_headings":"","what":"Summary method for fdata objects ‚Äî summary.fdata","title":"Summary method for fdata objects ‚Äî summary.fdata","text":"Summary method fdata objects","code":""},{"path":"https://sipemu.github.io/fdars/reference/summary.fdata.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summary method for fdata objects ‚Äî summary.fdata","text":"","code":"# S3 method for class 'fdata' summary(object, ...)"},{"path":"https://sipemu.github.io/fdars/reference/summary.fdata.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summary method for fdata objects ‚Äî summary.fdata","text":"object object class 'fdata'. ... Additional arguments (ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/trimmed.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Functional Trimmed Mean ‚Äî trimmed","title":"Compute Functional Trimmed Mean ‚Äî trimmed","text":"Computes trimmed mean excluding curves lowest depth.","code":""},{"path":"https://sipemu.github.io/fdars/reference/trimmed.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Functional Trimmed Mean ‚Äî trimmed","text":"","code":"trimmed(   fdataobj,   trim = 0.1,   method = c(\"FM\", \"mode\", \"RP\", \"RT\", \"BD\", \"MBD\", \"FSD\", \"KFSD\", \"RPD\"),   ... )"},{"path":"https://sipemu.github.io/fdars/reference/trimmed.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Functional Trimmed Mean ‚Äî trimmed","text":"fdataobj object class 'fdata'. trim Proportion curves trim (default 0.1). method Depth method use. One \"FM\", \"mode\", \"RP\", \"RT\", \"BD\", \"MBD\", \"FSD\", \"KFSD\", \"RPD\". Default \"FM\". ... Additional arguments passed depth function.","code":""},{"path":"https://sipemu.github.io/fdars/reference/trimmed.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Functional Trimmed Mean ‚Äî trimmed","text":"fdata object containing trimmed mean function.","code":""},{"path":"https://sipemu.github.io/fdars/reference/trimmed.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Functional Trimmed Mean ‚Äî trimmed","text":"","code":"fd <- fdata(matrix(rnorm(100), 10, 10)) tm <- trimmed(fd, trim = 0.2) tm_mode <- trimmed(fd, trim = 0.2, method = \"mode\")"},{"path":"https://sipemu.github.io/fdars/reference/trimvar.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Functional Trimmed Variance ‚Äî trimvar","title":"Compute Functional Trimmed Variance ‚Äî trimvar","text":"Computes trimmed variance excluding curves lowest depth.","code":""},{"path":"https://sipemu.github.io/fdars/reference/trimvar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Functional Trimmed Variance ‚Äî trimvar","text":"","code":"trimvar(   fdataobj,   trim = 0.1,   method = c(\"FM\", \"mode\", \"RP\", \"RT\", \"BD\", \"MBD\", \"FSD\", \"KFSD\", \"RPD\"),   ... )"},{"path":"https://sipemu.github.io/fdars/reference/trimvar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Functional Trimmed Variance ‚Äî trimvar","text":"fdataobj object class 'fdata'. trim Proportion curves trim (default 0.1). method Depth method use. One \"FM\", \"mode\", \"RP\", \"RT\", \"BD\", \"MBD\", \"FSD\", \"KFSD\", \"RPD\". Default \"FM\". ... Additional arguments passed depth function.","code":""},{"path":"https://sipemu.github.io/fdars/reference/trimvar.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Functional Trimmed Variance ‚Äî trimvar","text":"fdata object containing trimmed variance function.","code":""},{"path":"https://sipemu.github.io/fdars/reference/trimvar.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Functional Trimmed Variance ‚Äî trimvar","text":"","code":"fd <- fdata(matrix(rnorm(100), 10, 10)) tv <- trimvar(fd, trim = 0.2) tv_mode <- trimvar(fd, trim = 0.2, method = \"mode\")"},{"path":"https://sipemu.github.io/fdars/reference/var.html","id":null,"dir":"Reference","previous_headings":"","what":"Functional Variance ‚Äî var","title":"Functional Variance ‚Äî var","text":"Computes pointwise variance function functional data.","code":""},{"path":"https://sipemu.github.io/fdars/reference/var.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Functional Variance ‚Äî var","text":"","code":"var(fdataobj, ...)"},{"path":"https://sipemu.github.io/fdars/reference/var.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Functional Variance ‚Äî var","text":"fdataobj object class 'fdata'. ... Additional arguments (currently ignored).","code":""},{"path":"https://sipemu.github.io/fdars/reference/var.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Functional Variance ‚Äî var","text":"fdata object containing variance function (1D 2D).","code":""},{"path":"https://sipemu.github.io/fdars/reference/var.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Functional Variance ‚Äî var","text":"","code":"# 1D functional data fd <- fdata(matrix(rnorm(100), 10, 10)) v <- var(fd)  # 2D functional data X <- array(rnorm(500), dim = c(5, 10, 10)) fd2d <- fdata(X, argvals = list(1:10, 1:10), fdata2d = TRUE) v2d <- var(fd2d)"},{"path":[]},{"path":[]},{"path":"https://sipemu.github.io/fdars/news/index.html","id":"optimal-cluster-selection-0-2-0","dir":"Changelog","previous_headings":"New Features","what":"Optimal Cluster Selection","title":"fdars 0.2.0","text":"Added optim.kmeans.fd() function automatically determine optimal number clusters functional k-means Silhouette score: Measures cluster cohesion vs separation (-1 1, higher better) Calinski-Harabasz index: Ratio /within cluster variance (higher better) Elbow method: Visual inspection within-cluster sum squares Added print() plot() methods optim.kmeans.fd objects Silhouette Calinski-Harabasz computations implemented Rust performance","code":""},{"path":"https://sipemu.github.io/fdars/news/index.html","id":"k-nn-bandwidth-selection-for-nonparametric-regression-0-2-0","dir":"Changelog","previous_headings":"New Features","what":"k-NN Bandwidth Selection for Nonparametric Regression","title":"fdars 0.2.0","text":"\"kNN.gCV\": Global cross-validation (single k observations) \"kNN.lCV\": Local cross-validation (adaptive k per observation) Extended predict.fregre.np() handle k-NN models","code":""},{"path":"https://sipemu.github.io/fdars/news/index.html","id":"flexible-metrics-in-clustering-0-2-0","dir":"Changelog","previous_headings":"New Features","what":"Flexible Metrics in Clustering","title":"fdars 0.2.0","text":"kmeans.fd() now accepts string metrics (\"L2\", \"L1\", \"Linf\") metric/semimetric functions String metrics use fast Rust-path; function metrics provide flexibility custom distances","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/news/index.html","id":"ggplot2-visualizations-0-2-0","dir":"Changelog","previous_headings":"Improvements","what":"ggplot2 Visualizations","title":"fdars 0.2.0","text":"plot.fdata(): Functional data curves minimal theme plot.kmeans.fd(): Cluster-colored curves dashed cluster centers plot.optim.kmeans.fd(): Criterion scores optimal k highlighted plot.outliers.fdata(): Outlier/normal curves color legend","code":""},{"path":[]},{"path":"https://sipemu.github.io/fdars/news/index.html","id":"vignettes-0-2-0","dir":"Changelog","previous_headings":"Documentation","what":"Vignettes","title":"fdars 0.2.0","text":"Added 6 comprehensive vignettes: - Introduction fdars - Functional Depth Functions - Distance Metrics Semimetrics - Functional Regression - Functional Clustering - Outlier Detection","code":""},{"path":"https://sipemu.github.io/fdars/news/index.html","id":"api-documentation-0-2-0","dir":"Changelog","previous_headings":"Documentation","what":"API Documentation","title":"fdars 0.2.0","text":"Complete roxygen2 documentation exported functions","code":""},{"path":"https://sipemu.github.io/fdars/news/index.html","id":"bug-fixes-0-2-0","dir":"Changelog","previous_headings":"","what":"Bug Fixes","title":"fdars 0.2.0","text":"Fixed namespace issues stats utils imports Fixed ggplot2 .data pronoun import R CMD check compliance","code":""},{"path":"https://sipemu.github.io/fdars/news/index.html","id":"fdars-010","dir":"Changelog","previous_headings":"","what":"fdars 0.1.0","title":"fdars 0.1.0","text":"Initial release Core functional data class (fdata) 1D 2D support 7 depth functions: FM, mode, RP, RT, FSD, KFSD, RPD Distance metrics: Lp, Hausdorff, DTW, KL Semimetrics: PCA, derivative, basis, Fourier, hshift Functional regression: PC, basis, nonparametric K-means clustering k-means++ initialization Outlier detection: depth-based LRT methods Statistical tests: flm.test, fmean.test Bootstrap inference confidence intervals High-performance Rust backend parallel processing","code":""}]
